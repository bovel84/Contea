<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Il Conte – Simulatore Medievale Completo</title>

    <!-- ===================== STILI BASE + ESPANSIONI ===================== -->
    <style>
        :root {
            --bg-main: #050505;
            --bg-panel: #0f0f0f;
            --bg-panel-alt: #171717;
            --border-soft: #2a2a2a;
            --border-strong: #3a3a3a;
            --accent: #d4af37;
            --accent-muted: #b68a1f;
            --text: #f2f2f2;
            --text-soft: #b3b3b3;
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Georgia', serif;
            background: radial-gradient(circle at top, #171717, var(--bg-main));
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
            overflow-y: auto;
        }

        h1, h2, h3 {
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 0;
        }

        .screen {
            display: none;
            flex: 1;
            overflow-y: auto;
            padding: clamp(16px, 4vw, 28px);
            background: linear-gradient(145deg, rgba(15,15,15,0.95), rgba(8,8,8,0.9));
        }
        .screen.active { display: flex; flex-direction: column; }

        input, textarea, select {
            width: 100%;
            padding: 12px;
            background: #121212;
            border: 1px solid var(--border-soft);
            border-radius: 6px;
            color: var(--text);
            margin-bottom: 15px;
        }

        .btn-main {
            width: 100%;
            padding: 14px;
            background: linear-gradient(120deg, var(--accent), #a7720d);
            color: black;
            font-weight: bold;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 6px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.45);
        }

        .btn-sec {
            padding: 8px 12px;
            background: var(--bg-panel-alt);
            border: 1px solid var(--border-soft);
            border-radius: 8px;
            color: var(--text-soft);
            cursor: pointer;
            transition: border-color 0.2s ease;
        }

        .btn-sec:hover { border-color: var(--accent-muted); }

        .panel {
            background: var(--bg-panel);
            border: 1px solid var(--border-soft);
            border-radius: 18px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.35);
        }

        #screen-start {
            background: radial-gradient(circle at top, #101010, #030303);
        }

        .start-hero {
            text-align: center;
            margin-bottom: 24px;
        }

        .start-hero h1 {
            font-size: clamp(1.8rem, 5vw, 2.8rem);
            margin-bottom: 6px;
        }

        .start-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 18px;
        }

        .start-card {
            background: rgba(8,8,8,0.92);
            border: 1px solid var(--border-soft);
            border-radius: 18px;
            padding: 18px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.45);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .start-card h3 {
            margin: 0;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.9em;
        }

        /* Small transient delta indicators for stats (pop, gold, food, health) */
        .stat-delta {
            font-size: 0.8em;
            color: var(--text-soft);
            margin-top: 6px;
            height: 18px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            transition: opacity 0.35s cubic-bezier(.2,.9,.2,1), transform 0.35s cubic-bezier(.2,.9,.2,1);
            opacity: 0;
            transform: translateY(0) scale(1);
            will-change: opacity, transform;
        }
        .stat-delta.active { opacity: 1; transform: translateY(-4px) scale(1.04); }
        .stat-delta.up { color: #7be36a; }
        .stat-delta.down { color: #ff7c7c; }
        .stat-delta svg { width: 12px; height: 12px; vertical-align: middle; }
        /* Backwards-compatible alias for old pop-delta */
        .pop-delta { all: unset; }

        .save-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid rgba(255,255,255,0.06);
            border-radius: 12px;
            padding: 10px 12px;
            margin-bottom: 8px;
            background: rgba(6,6,6,0.9);
            gap: 10px;
        }

        .save-entry-details {
            display: flex;
            flex-direction: column;
            font-size: 0.8em;
            color: var(--text-soft);
        }

        .save-entry-actions {
            display: flex;
            gap: 6px;
        }

        .save-empty {
            font-size: 0.85em;
            color: var(--text-soft);
        }

        .game-toolbar {
            display: flex;
            flex-wrap: nowrap;
            gap: 10px;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 14px;
        }

        .toolbar-status {
            font-size: 0.75em;
            color: var(--text-soft);
        }

        .season-banner {
            border: 1px solid var(--border-soft);
            border-radius: 12px;
            padding: 8px 14px;
            margin-bottom: 18px;
            background: rgba(12,12,12,0.85);
            display: flex;
            justify-content: space-between;
            gap: 10px;
            font-size: 0.85em;
            color: var(--text);
        }

        .season-highlight {
            color: var(--accent);
            font-weight: 600;
        }

        .resource-grid .stat-card {
            position: relative;
        }

        .res-delta {
            position: absolute;
            right: 10px;
            bottom: 8px;
            font-size: 0.75em;
            color: var(--text-soft);
        }

        .res-delta.positive { color: #6ada91; }
        .res-delta.negative { color: #ff7c7c; }

        .faction-effects {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px,1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .faction-effect-card {
            border: 1px solid var(--border-soft);
            border-radius: 12px;
            padding: 12px;
            background: rgba(10,10,10,0.85);
            font-size: 0.85em;
        }

        .faction-effect-card strong {
            color: var(--accent);
            display: block;
            margin-bottom: 4px;
        }

        .tax-panel {
            border: 1px solid var(--border-soft);
            border-radius: 14px;
            padding: 14px;
            margin-bottom: 20px;
            background: rgba(6,6,6,0.9);
        }

        .tax-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px,1fr));
            gap: 12px;
            margin-bottom: 12px;
        }

        .tax-card {
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 12px;
            padding: 10px;
            background: rgba(12,12,12,0.85);
        }

        .tax-card label {
            display: flex;
            justify-content: space-between;
            font-size: 0.8em;
            text-transform: uppercase;
            color: var(--text-soft);
        }

        .tax-card input[type=range] {
            width: 100%;
        }

        .tax-summary {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            font-size: 0.85em;
            color: var(--text);
        }

        .law-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px,1fr));
            gap: 12px;
        }

        .law-card {
            border: 1px solid var(--border-soft);
            border-radius: 14px;
            padding: 12px;
            background: rgba(10,10,10,0.88);
        }

        .law-card h4 {
            margin: 0 0 6px 0;
            color: var(--accent);
        }

        .law-card p {
            margin: 0 0 10px 0;
            font-size: 0.85em;
            color: var(--text-soft);
        }

        .section-toggle {
            width: 100%;
            margin: 12px 0 6px;
            padding: 10px 14px;
            text-align: left;
            background: rgba(12,12,12,0.85);
            color: var(--text);
            border: 1px solid var(--border-soft);
            border-radius: 10px;
            font-size: 0.95em;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .section-toggle span {
            font-size: 0.85em;
            color: var(--text-soft);
        }

        .section-panel {
            border: 1px solid rgba(255,255,255,0.05);
            border-radius: 14px;
            padding: 12px;
            background: rgba(5,5,5,0.85);
            margin-bottom: 10px;
        }

        .section-panel.collapsed {
            display: none;
        }

        .asset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 12px;
        }

        .asset-card {
            border: 1px solid var(--border-soft);
            border-radius: 12px;
            padding: 12px;
            background: rgba(8,8,8,0.9);
            font-size: 0.85em;
        }

        .asset-card h4 {
            margin: 0 0 6px 0;
            color: var(--accent);
        }

        .asset-flow {
            font-size: 0.8em;
            color: var(--text-soft);
            margin-top: 4px;
        }

        .law-creator {
            border-top: 1px dashed rgba(255,255,255,0.08);
            margin-top: 12px;
            padding-top: 12px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px,1fr));
            gap: 10px;
        }

        .law-creator textarea,
        .law-creator input,
        .law-creator select {
            margin: 0;
        }

        .law-creator button {
            grid-column: 1 / -1;
        }

        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.65);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
            z-index: 100;
        }

        .modal.active { display: flex; }

        .modal-content {
            background: var(--bg-panel);
            border: 1px solid var(--border-soft);
            border-radius: 18px;
            width: min(520px, 92vw);
            max-height: 90vh;
            overflow-y: auto;
            padding: 20px;
            box-shadow: 0 30px 70px rgba(0,0,0,0.65);
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .close-btn {
            background: none;
            border: none;
            color: var(--text);
            font-size: 1.2em;
            cursor: pointer;
        }

        .personality-form label {
            font-size: 0.85em;
            color: var(--text-soft);
        }

        .personality-form textarea { min-height: 80px; }

        /* ===================== NAVIGAZIONE ===================== */
        .bottom-nav {
            display: flex;
            height: 60px;
            background: rgba(5,5,5,0.95);
            border-top: 1px solid var(--border-soft);
            align-items: center;
            justify-content: space-around;
            position: sticky;
            bottom: 0;
            z-index: 10;
            backdrop-filter: blur(10px);
        }

        .nav-btn {
            background: none;
            border: none;
            color: var(--text-soft);
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 0.77em;
            gap: 3px;
        }
        .nav-btn.active { color: #d4af37; }

        .nav-icon { font-size: 1.4em; }

        /* ===================== TAB VIEW ===================== */
        .tab-view {
            display: none;
            height: 100%;
            overflow-y: auto;
            padding: clamp(16px, 4vw, 26px);
            background: linear-gradient(135deg, rgba(12,12,12,0.95), rgba(5,5,5,0.92));
            border: 1px solid var(--border-soft);
            border-radius: 20px;
            margin-bottom: 70px;
            box-shadow: 0 20px 45px rgba(0,0,0,0.4);
        }
        .tab-view.active-tab { display: flex; flex-direction: column; gap: 16px; }

        /* ===================== STATISTICHE ===================== */
        .grid-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 20px;
        }

        .resource-grid {
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        }

        .stat-card {
            background: var(--bg-panel);
            border: 1px solid var(--border-soft);
            padding: 14px;
            border-radius: 14px;
            text-align: center;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.03);
        }

        .stat-val { font-size: 1.3em; font-weight: bold; }

        /* ===================== BARS ===================== */
        .need-row { margin-bottom: 15px; }
        .need-header {
            display: flex;
            justify-content: space-between;
            font-size: 0.85em;
            margin-bottom: 4px;
        }
        /* ===================== MAGAZZINO ===================== */
        .warehouse-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
            margin-bottom: 20px;
        }

        .warehouse-stat {
            background: var(--bg-panel);
            border: 1px solid var(--border-soft);
            border-radius: 12px;
            padding: 16px;
            text-align: center;
        }

        .warehouse-stat-value {
            font-size: 2em;
            font-weight: bold;
            color: var(--accent);
            margin-bottom: 5px;
        }

        .warehouse-stat-label {
            font-size: 0.85em;
            color: var(--text-soft);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .warehouse-section {
            background: var(--bg-panel);
            border: 1px solid var(--border-soft);
            border-radius: 14px;
            padding: 20px;
            margin-bottom: 15px;
        }

        .resource-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 12px;
        }

        .resource-item {
            background: rgba(8,8,8,0.6);
            border: 2px solid var(--border-soft);
            border-radius: 10px;
            padding: 14px;
            transition: all 0.3s ease;
        }

        .resource-item.critical {
            border-color: #f44336;
            background: rgba(244, 67, 54, 0.08);
        }

        .resource-item.warning {
            border-color: #ff9800;
            background: rgba(255, 152, 0, 0.08);
        }

        .resource-item.healthy {
            border-color: #4caf50;
            background: rgba(76, 175, 80, 0.08);
        }

        .resource-header-w {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .resource-name-w {
            font-size: 1.1em;
            font-weight: bold;
            color: var(--accent);
        }

        .resource-icon-w {
            font-size: 1.5em;
            margin-right: 8px;
        }

        .resource-quantity {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .resource-item.critical .resource-quantity {
            color: #f44336;
        }

        .resource-item.warning .resource-quantity {
            color: #ff9800;
        }

        .resource-item.healthy .resource-quantity {
            color: #4caf50;
        }

        .resource-details-w {
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 0.85em;
            color: var(--text-soft);
            margin-bottom: 10px;
        }

        .resource-row-w {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
        }

        .resource-row-w.positive {
            color: #4caf50;
        }

        .resource-row-w.negative {
            color: #f44336;
        }

        .resource-autonomy {
            background: rgba(212, 175, 55, 0.1);
            border: 1px solid var(--accent-muted);
            border-radius: 6px;
            padding: 8px;
            text-align: center;
            font-weight: bold;
            margin-top: 8px;
        }

        .resource-autonomy.critical {
            background: rgba(244, 67, 54, 0.15);
            border-color: #f44336;
            color: #f44336;
        }

        .resource-autonomy.warning {
            background: rgba(255, 152, 0, 0.15);
            border-color: #ff9800;
            color: #ff9800;
        }

        .resource-autonomy.infinite {
            background: rgba(76, 175, 80, 0.15);
            border-color: #4caf50;
            color: #4caf50;
        }

        .population-needs {
            background: var(--bg-panel);
            border: 1px solid var(--border-soft);
            border-radius: 14px;
            padding: 20px;
            margin-top: 20px;
        }

        .needs-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
        }

        .need-card {
            background: rgba(8,8,8,0.6);
            border: 1px solid var(--border-soft);
            border-radius: 8px;
            padding: 12px;
        }

        .need-title {
            font-weight: bold;
            color: var(--accent);
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .need-value {
            font-size: 1.3em;
            font-weight: bold;
            color: var(--text);
        }

        .need-desc {
            font-size: 0.8em;
            color: var(--text-soft);
            margin-top: 4px;
        }

        .need-bar-bg {
            background: #333;
            height: 8px;
            border-radius: 4px;
            width: 100%;
        }
        .need-bar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s;
        }
        .fill-food { background: #e6bf00; }
        .fill-health { background: #4caf50; }
        .fill-happy { background: #2196f3; }
        .fill-stability { background: #9c27b0; }

        /* ===================== DIPLOMAZIA ===================== */
        .diplomacy-card {
            background: linear-gradient(140deg, rgba(22,22,22,0.95), rgba(12,12,12,0.9));
            border: 1px solid var(--border-soft);
            padding: 14px 16px;
            border-radius: 14px;
            margin-bottom: 14px;
            box-shadow: 0 12px 26px rgba(0,0,0,0.4);
        }

        .relation-row {
            display: flex;
            justify-content: space-between;
            border-bottom: 1px dashed rgba(255,255,255,0.05);
            padding: 6px 0;
            font-size: 0.92em;
        }

        .relation-row span:first-child { color: var(--text-soft); }

        /* ===================== SALA DEL TRONO (CHAT) - VERSIONE LEGGIBILE ===================== */
        .chat-panel {
            /* Sfondo schiarito: da nero #111 a grigio scuro #1a1a1a */
            background: #1a1a1a;
            border: 1px solid #333; /* Bordo più visibile */
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            height: 75vh; 
            min-height: 600px; /* Minimo garantito su desktop */
            background: #111; /* Sfondo più scuro per immersione */
            border: 1px solid #444;
            box-shadow: 0 0 30px rgba(0,0,0,0.8); /* Ombra profonda */
            position: relative;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        /* Texture sfondo: Molto più leggera, non copre il testo */
        .chat-panel::before {
            content: "";
            position: absolute;
            inset: 0;
            /* Gradiente ridotto drasticamente: dal 90% di opacità al 20% */
            background: radial-gradient(circle at 50% 30%, rgba(40, 35, 30, 0.1), rgba(0,0,0,0.4));
            pointer-events: none;
            z-index: 0;
        }

        .chat-header {
            z-index: 2;
            /* Sfondo più chiaro e distinto */
            background: #252525;
            border-bottom: 1px solid #444;
            padding: 12px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #d4af37; /* Oro leggibile */
            font-family: 'Georgia', serif;
            font-size: 0.95em;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .chat-log {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 25px;
            scroll-behavior: smooth;
            z-index: 1;
            /* Colore testo base molto più chiaro */
            color: #e0e0e0;
            font-size: 1.05em; /* Testo leggermente più grande */
            line-height: 1.6; /* Interlinea per narrativa */
            padding: 25px;
            background: radial-gradient(circle at center, #1a1a1a 0%, #080808 100%); /* Effetto vignetta */
        }

        /* Chips Fazioni (i pulsanti in alto) */
        .faction-chips {
            z-index: 2;
            padding: 10px 15px;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid #333;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .faction-chip {
            background: #2a2a2a; /* Sfondo grigio, non nero */
            border: 1px solid #555; /* Bordo visibile */
            color: #ccc;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.75em;
            cursor: pointer;
            transition: all 0.2s;
        }
        .faction-chip:hover {
            background: #3a3a3a;
            border-color: #d4af37;
            color: #fff;
        }

        /* Area Input (in basso) */
        .input-area {
            z-index: 2;
            background: #202020; /* Ben distinto dallo sfondo */
            padding: 15px;
            border-top: 1px solid #444;
            display: flex;
            gap: 10px;
        }

        .input-area input {
            background: #111;
            border: 1px solid #555;
            color: #fff; /* Testo bianco puro */
            padding: 10px;
            border-radius: 6px;
            font-size: 1em;
        }
        .input-area input::placeholder {
            color: #777;
        }

        /* Pulsante "Avanza Stagione" */
        .season-advance-btn {
            margin: 0; /* Reset margini */
            width: 100%;
            padding: 12px;
            background: #2c2c2c;
            border: 1px solid #555;
            color: #e0e0e0;
            font-weight: bold;
            cursor: pointer;
            border-radius: 0; /* Full width style */
            transition: background 0.2s;
        }
        .season-advance-btn:hover {
            background: #3a3a3a;
            border-color: #d4af37;
            color: #fff;
        }

        /* Messaggi Chat */
        .msg-system {
            background: transparent;
            border: none;
            border-top: 1px solid #333;
            border-bottom: 1px solid #333;
            color: #888;
            font-style: italic;
            text-align: left;
            padding: 10px 0;
            margin: 15px 0;
        }

        /* Correzione colori Messaggi Fazione per leggibilità */
        .msg-faction {
            background: #222;
            border: 1px solid #444;
            color: #eee; /* Testo chiaro */
        }
        .msg-faction .msg-text {
            color: #dcdcdc; /* Grigio chiarissimo */
        }
        .faction-title {
            font-weight: bold;
            letter-spacing: 1px;
            margin-bottom: 5px;
            display: block;
        }

        /* ===================== EVENTI & AZIONI ===================== */
        .panel-title {
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--accent);
            margin-bottom: 8px;
        }

        .event-panel,
        .action-panel,
        .advice-panel {
            background: linear-gradient(135deg, rgba(16,16,16,0.92), rgba(8,8,8,0.9));
            border: 1px solid var(--border-soft);
            border-radius: 18px;
            padding: 18px;
            box-shadow: 0 15px 30px rgba(0,0,0,0.4);
        }

        .event-feed {
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-height: 320px;
            overflow-y: auto;
        }

        .event-card {
            background: linear-gradient(135deg, rgba(212,175,55,0.12), rgba(255,255,255,0.03));
            border: 1px solid rgba(212,175,55,0.2);
            border-radius: 14px;
            padding: 12px 14px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.35);
        }

        .event-time {
            font-size: 0.7em;
            color: var(--text-soft);
            text-align: right;
            margin-bottom: 6px;
        }

        .event-empty,
        .action-empty {
            color: var(--text-soft);
            font-size: 0.85em;
            margin: 0;
        }

        .action-panel { margin-top: 16px; }

        .action-prompt {
            margin: 0 0 8px 0;
            font-size: 0.85em;
            color: #ccc;
        }

        .action-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .action-card {
            border: 1px solid rgba(52,152,219,0.35);
            background: rgba(36,75,95,0.35);
            color: #e4f4ff;
            border-radius: 12px;
            padding: 12px;
            text-align: left;
            display: flex;
            flex-direction: column;
            gap: 4px;
            cursor: pointer;
            font-size: 0.95em;
            transition: transform 0.15s ease, border-color 0.15s ease;
        }

        .legend-circle {
            background: #f4d88b;
            box-shadow: inset 0 0 4px rgba(0,0,0,0.4);
        }

        .legend-diamond {
            background: #c27b26;
            transform: rotate(45deg);
        }

        .legend-triangle {
            display: inline-block;
            width: 0;
            height: 0;
            border-left: 9px solid transparent;
            border-right: 9px solid transparent;
            border-bottom: 16px solid #5ba86c;
            border-radius: 2px;
        }

        .legend-square {
            background: #cfcfcf;
        }

        .legend-cross {
            position: relative;
            width: 18px;
            height: 18px;
        }

        .legend-cross::before,
        .legend-cross::after {
            content: "";
            position: absolute;
            background: #f5f0d0;
            border-radius: 2px;
        }

        .legend-cross::before {
            width: 6px;
            height: 18px;
            left: 6px;
        }

        .legend-cross::after {
            width: 18px;
            height: 6px;
            top: 6px;
        }

        /* ===================== POPOLAZIONE ===================== */
        .pop-grid {
            display: grid;
            grid-template-columns: repeat(2,1fr);
            gap: 10px;
        }

        .pop-card {
            background: linear-gradient(135deg, rgba(28,28,28,0.95), rgba(14,14,14,0.92));
            border: 1px solid var(--border-soft);
            padding: 14px;
            border-radius: 12px;
            box-shadow: 0 10px 22px rgba(0,0,0,0.35);
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            gap: 10px;
            font-size: 0.95em;
        }

        .pop-card strong { color: var(--accent); }
        .pop-card span { color: var(--text); }

        /* ===================== PERSONAGGI (FAZIONI) ===================== */
        .person-card {
            background: linear-gradient(120deg, rgba(20,20,20,0.95), rgba(10,10,10,0.92));
            border: 1px solid var(--border-soft);
            padding: 16px;
            border-radius: 16px;
            margin-bottom: 14px;
            box-shadow: 0 15px 30px rgba(0,0,0,0.4);
        }
        .person-name {
            color: #d4af37;
            font-size: 1.1em;
            margin-bottom: 6px;
        }

        .private-selector {
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            background: rgba(8,8,8,0.85);
            border: 1px solid var(--border-soft);
            border-radius: 18px;
            padding: 14px;
        }

.building-card-ui {
    background: rgba(18, 18, 18, 0.95);
    border: 1px solid var(--border-soft);
    border-radius: 12px;
    padding: 14px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    transition: transform 0.2s;
}
.building-card-ui:hover {
    border-color: var(--accent);
    transform: translateY(-2px);
}
.b-header {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    border-bottom: 1px dashed rgba(255,255,255,0.1);
    padding-bottom: 6px;
    margin-bottom: 4px;
}
.b-title { color: var(--accent); font-weight: bold; font-size: 0.95em; }
.b-time { font-size: 0.75em; color: #aaa; }
.b-desc { font-size: 0.85em; color: #ddd; line-height: 1.3; flex-grow: 1; }
.b-effect { font-size: 0.75em; color: #81c784; margin-top: 4px; }
.b-cost { 
    display: flex; 
    gap: 8px; 
    flex-wrap: wrap; 
    font-size: 0.75em; 
    color: var(--text-soft); 
    background: rgba(0,0,0,0.3);
    padding: 6px;
    border-radius: 6px;
}
.cost-item { display: flex; align-items: center; gap: 3px; }
.cost-item.missing { color: #ff6b6b; }

/* Stile per il pannello cantieri */
.const-card {
    background: linear-gradient(90deg, rgba(20,20,20,0.9), rgba(30,30,30,0.9));
    border: 1px solid var(--border-soft);
    border-left: 3px solid var(--accent);
    padding: 10px 12px;
    border-radius: 8px;
    margin-bottom: 8px;
    display: flex;
    flex-direction: column;
    gap: 6px;
}

.const-header {
    display: flex;
    justify-content: space-between;
    font-size: 0.9em;
    color: var(--text);
}

.const-meta {
    font-size: 0.75em;
    color: var(--text-soft);
    display: flex;
    justify-content: space-between;
}

.const-progress-bg {
    background: #333;
    height: 6px;
    width: 100%;
    border-radius: 3px;
    overflow: hidden;
}

.const-progress-fill {
    background: var(--accent);
    height: 100%;
    width: 0%;
    transition: width 0.4s ease;
    box-shadow: 0 0 8px rgba(212, 175, 55, 0.4);
}

/* ===================== MEDIA QUERIES PER MOBILE ===================== */
@media (max-width: 768px) {
    body {
        font-size: 14px;
    }

    .screen {
        padding: clamp(8px, 2vw, 16px);
    }

    .screen.active {
        display: flex;
        flex-direction: column;
    }

    #screen-game {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr auto;
        gap: 10px;
    }

    .start-grid {
        grid-template-columns: 1fr;
        gap: 12px;
    }

    .start-card {
        padding: 12px;
    }

    .game-toolbar {
        flex-wrap: wrap;
        gap: 6px;
        font-size: 0.8em;
    }

    .toolbar-status {
        font-size: 0.7em;
    }

    .season-banner {
        padding: 6px 10px;
        font-size: 0.8em;
        flex-direction: column;
        gap: 4px;
        align-items: flex-start;
    }

    .tab-view {
        padding: clamp(12px, 3vw, 20px);
        margin-bottom: 60px;
    }

    .grid-stats {
        grid-template-columns: 1fr;
        gap: 8px;
    }

    .resource-grid {
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    }

    .stat-card {
        padding: 10px;
        font-size: 0.9em;
    }

    .stat-val {
        font-size: 1.1em;
    }

    .need-row {
        margin-bottom: 12px;
    }

    .need-header {
        font-size: 0.8em;
    }

    .diplomacy-card {
        padding: 10px 12px;
        margin-bottom: 10px;
    }

    .relation-row {
        font-size: 0.85em;
        padding: 4px 0;
    }

    .chat-panel {
        height: calc(100vh - 130px);
        min-height: auto;
    }

    .chat-log {
        padding: 15px;
        gap: 10px;
    }

    .msg {
        padding: 10px 12px;
        max-width: 95%;
        font-size: 0.9em;
    }

    .input-area {
        padding: 12px;
        gap: 8px;
    }

    .send-btn {
        width: 44px;
        font-size: 1em;
    }

    .season-advance-btn {
        padding: 8px 10px;
        font-size: 0.85em;
    }

    .event-feed {
        max-height: 250px;
    }

    .event-card {
        padding: 10px 12px;
        font-size: 0.9em;
    }

    .action-card {
        padding: 10px;
        font-size: 0.9em;
    }

    .pop-grid {
        grid-template-columns: 1fr;
        gap: 8px;
    }

    .pop-card {
        padding: 10px;
        font-size: 0.9em;
    }

    .person-card {
        padding: 8px;
        margin-bottom: 6px;
        font-size: 0.9em;
    }

    .representatives-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
    }

    .person-name {
        font-size: 1em;
    }

    .private-selector {
        padding: 10px;
        gap: 8px;
    }

    .private-selector button {
        font-size: 0.8em;
        padding: 6px 8px;
    }

    .faction-effects {
        grid-template-columns: 1fr;
        gap: 8px;
    }

    .faction-effect-card {
        padding: 10px;
        font-size: 0.9em;
    }

    .tax-grid {
        grid-template-columns: 1fr;
        gap: 8px;
    }

    .tax-card {
        padding: 8px;
    }

    .law-list {
        grid-template-columns: 1fr;
        gap: 8px;
    }

    .law-card {
        padding: 10px;
        font-size: 0.9em;
    }

    .law-creator {
        grid-template-columns: 1fr;
        gap: 8px;
    }

    .asset-grid {
        grid-template-columns: 1fr;
        gap: 8px;
    }

    .asset-card {
        padding: 10px;
        font-size: 0.9em;
    }

    .modal-content {
        width: 95vw;
        max-height: 85vh;
        padding: 16px;
    }

    .modal-header {
        margin-bottom: 4px;
    }

    .close-btn {
        font-size: 1.1em;
    }

    .bottom-nav {
        height: 50px;
        font-size: 0.75em;
    }

    .nav-btn {
        font-size: 0.7em;
    }

    .nav-icon {
        font-size: 1.2em;
    }

    canvas {
        max-width: 100%;
        height: auto;
    }

    .map-legend {
        font-size: 0.9em;
    }

    .legend-item {
        margin-bottom: 6px;
    }

    .building-card-ui {
        padding: 12px;
        font-size: 0.9em;
    }

    .b-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 4px;
    }

    .b-title {
        font-size: 0.95em;
    }

    .b-time {
        font-size: 0.75em;
    }

    .b-desc {
        font-size: 0.85em;
    }

    .b-cost {
        font-size: 0.75em;
        padding: 6px;
    }

    .const-card {
        padding: 8px 10px;
        font-size: 0.9em;
    }

    .const-header {
        font-size: 0.9em;
    }

    .const-meta {
        font-size: 0.75em;
    }

    .save-entry {
        padding: 8px 10px;
        font-size: 0.85em;
    }

    .save-entry-details {
        font-size: 0.8em;
    }

    .save-entry-actions {
        gap: 4px;
    }

    .panel {
        border-radius: 12px;
    }

    .btn-main {
        padding: 12px;
        font-size: 0.9em;
    }

    .btn-sec {
        padding: 6px 10px;
        font-size: 0.85em;
    }

    h1, h2, h3 {
        font-size: clamp(1.4rem, 4vw, 2.2rem);
        margin-bottom: 12px;
    }

    .section-toggle {
        padding: 8px 12px;
        font-size: 0.9em;
    }

    .section-panel {
        padding: 10px;
    }

    .faction-chips {
        padding: 8px 15px 0;
    }

    .faction-chip {
        font-size: 0.7em;
        padding: 3px 8px;
    }

    .msg-system {
        font-size: 0.65em;
    }

    .msg-meta {
        font-size: 0.65em;
    }

    .panel-title {
        font-size: 0.8em;
    }

    .event-empty,
    .action-empty {
        font-size: 0.8em;
    }

    .action-prompt {
        font-size: 0.8em;
    }

    .toolbar-status {
        font-size: 0.7em;
    }

    .season-highlight {
        font-size: 0.9em;
    }

    .res-delta {
        font-size: 0.7em;
    }

    .need-bar-bg {
        height: 6px;
    }

    .need-bar-fill {
        height: 100%;
    }

    .legend-circle,
    .legend-diamond,
    .legend-square,
    .legend-cross {
        width: 16px;
        height: 16px;
    }

    .legend-triangle {
        border-left-width: 8px;
        border-right-width: 8px;
        border-bottom-width: 14px;
    }

    .legend-cross::before,
    .legend-cross::after {
        width: 5px;
        height: 16px;
        left: 5.5px;
    }

    .legend-cross::after {
        width: 16px;
        height: 5px;
        top: 5.5px;
    }

    .const-progress-bg {
        height: 5px;
    }

    .const-progress-fill {
        height: 100%;
    }

    .court-layout {
        flex-direction: column;
    }

    .court-main, .court-sidebar {
        flex: none;
        width: 100%;
    }
}

@media (max-width: 480px) {
    body {
        font-size: 13px;
    }

    .screen {
        padding: clamp(6px, 2vw, 12px);
    }

    .tab-view {
        padding: clamp(10px, 3vw, 16px);
        margin-bottom: 55px;
    }

    .chat-panel {
        height: 50vh;
    }

    .chat-log {
        padding: 12px;
        gap: 8px;
    }

    .msg {
        padding: 8px 10px;
        max-width: 98%;
        font-size: 0.85em;
    }

    .input-area {
        padding: 10px;
    }

    .send-btn {
        width: 40px;
        font-size: 0.9em;
    }

    .bottom-nav {
        height: 45px;
        font-size: 0.7em;
    }

    .nav-btn {
        font-size: 0.65em;
    }

    .nav-icon {
        font-size: 1.1em;
    }

    .modal-content {
        width: 98vw;
        padding: 12px;
    }

    .btn-main {
        padding: 10px;
        font-size: 0.85em;
    }

    .btn-sec {
        padding: 5px 8px;
        font-size: 0.8em;
    }

    h1, h2, h3 {
        font-size: clamp(1.3rem, 4vw, 2rem);
        margin-bottom: 10px;
    }

    .stat-card {
        padding: 8px;
    }

    .stat-val {
        font-size: 1em;
    }

    .pop-card {
        padding: 8px;
    }

    .person-card {
        padding: 10px;
    }

    .diplomacy-card {
        padding: 8px 10px;
    }

    .law-card {
        padding: 8px;
    }

    .asset-card {
        padding: 8px;
    }

    .faction-effect-card {
        padding: 8px;
    }

    .tax-card {
        padding: 6px;
    }

    .event-card {
        padding: 8px 10px;
    }

    .action-card {
        padding: 8px;
    }

    .building-card-ui {
        padding: 10px;
    }

    .save-entry {
        padding: 6px 8px;
    }

    .section-toggle {
        padding: 6px 10px;
    }

    .section-panel {
        padding: 8px;
    }

    .private-selector button {
        font-size: 0.75em;
        padding: 5px 6px;
    }

    .faction-chip {
        font-size: 0.65em;
        padding: 2px 6px;
    }

    .panel-title {
        font-size: 0.75em;
    }

    .event-empty,
    .action-empty {
        font-size: 0.75em;
    }

    .action-prompt {
        font-size: 0.75em;
    }

    .toolbar-status {
        font-size: 0.65em;
    }

    .season-highlight {
        font-size: 0.85em;
    }

    .res-delta {
        font-size: 0.65em;
    }

    .need-header {
        font-size: 0.75em;
    }

    .relation-row {
        font-size: 0.8em;
    }

    .const-card {
        padding: 6px 8px;
    }

    .const-header {
        font-size: 0.85em;
    }

    .const-meta {
        font-size: 0.7em;
    }

    .map-legend {
        font-size: 0.85em;
    }

    .legend-item {
        margin-bottom: 4px;
    }

    .legend-circle,
    .legend-diamond,
    .legend-square,
    .legend-cross {
        width: 14px;
        height: 14px;
    }

    .legend-triangle {
        border-left-width: 7px;
        border-right-width: 7px;
        border-bottom-width: 12px;
    }

    .legend-cross::before,
    .legend-cross::after {
        width: 4px;
        height: 14px;
        left: 5px;
    }

    .legend-cross::after {
        width: 14px;
        height: 4px;
        top: 5px;
    }

    .const-progress-bg {
        height: 4px;
    }

    .const-progress-fill {
        height: 100%;
    }
}

.court-layout {
    display: grid;
    grid-template-columns: 1fr 300px;
    gap: 20px;
    align-items: start;
}

.court-main {
    min-width: 0;
}

.court-sidebar {
    min-width: 0;
}

.sidebar-panel {
    background: #161616;
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 8px;
    margin-bottom: 8px;
}

.event-feed.compact {
    max-height: 200px;
    overflow-y: auto;
}

.panel-title {
    font-size: 0.9em;
    font-weight: bold;
    margin-bottom: 6px;
}

.faction-chips-inline {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
    align-items: center;
}

.faction-chip {
    font-size: 0.75em;
    padding: 2px 6px;
    border-radius: 4px;
    background: var(--accent);
    color: #000;
}

@media (max-width: 900px) {
    .court-layout {
        grid-template-columns: 1fr;
        gap: 10px;
    }

    .court-sidebar {
        order: -1;
    }
}

/* ===================== MODALE BILANCIO (TESORERIA) ===================== */
.budget-container {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.budget-columns {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
}

@media (max-width: 600px) {
    .budget-columns { grid-template-columns: 1fr; }
}

.budget-col h4 {
    border-bottom: 1px solid var(--border-soft);
    padding-bottom: 8px;
    margin-bottom: 10px;
    color: var(--text-soft);
    text-transform: uppercase;
    font-size: 0.85em;
}

.budget-row {
    display: flex;
    justify-content: space-between;
    padding: 6px 0;
    border-bottom: 1px dashed rgba(255,255,255,0.05);
    font-size: 0.9em;
}

.budget-row.total {
    border-top: 1px solid var(--border-soft);
    border-bottom: none;
    margin-top: 10px;
    padding-top: 10px;
    font-weight: bold;
    font-size: 1.1em;
}

.money-plus { color: #6ada91; }
.money-minus { color: #ff7c7c; }

.net-balance-card {
    background: rgba(0,0,0,0.3);
    border: 1px solid var(--border-soft);
    border-radius: 12px;
    padding: 15px;
    text-align: center;
    margin-top: 10px;
}

.net-balance-val {
    font-size: 1.8em;
    font-weight: bold;
    margin: 5px 0;
}

#modal-budget {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.7);
    z-index: 1000;
    justify-content: center;
    align-items: center;
}

#modal-budget.active {
    display: flex;
}

#budget-content {
    background: var(--bg-card);
    padding: 20px;
    border-radius: 12px;
    max-width: 600px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
}

.budget-section {
    margin-bottom: 20px;
}

.budget-section h3 {
    margin-bottom: 10px;
    color: var(--accent);
}

.budget-row {
    display: flex;
    justify-content: space-between;
    padding: 5px 0;
    border-bottom: 1px solid var(--border-soft);
}

.budget-total {
    font-weight: bold;
    margin-top: 10px;
}

.money-plus {
    color: #4caf50;
}

.money-minus {
    color: #f44336;
}

.budget-net {
    text-align: center;
    font-size: 1.2em;
    margin-top: 20px;
    padding: 10px;
    border-radius: 8px;
    background: var(--bg-hover);
}

/* Stile per il nome del personaggio */
.chat-name {
    display: block;
    font-size: 0.85em;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--accent); /* Oro */
    margin-bottom: 4px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    padding-bottom: 2px;
    width: fit-content;
}

/* Stile per il testo del messaggio */
.chat-content {
    color: #e0e0e0;
    font-size: 1em;
    line-height: 1.5;
}

/* Stile specifico per la Narrazione (SCENA) */
.msg-narrative {
    background: rgba(0, 0, 0, 0.4);
    border-left: 3px solid #555;
    color: #aaa;
    font-style: italic;
    padding: 10px 15px;
    margin: 10px 0;
    border-radius: 0 8px 8px 0;
}

/* ===================== NUOVI STILI MESSAGGI ===================== */

/* 1. LA SCENA (Narrativa) - Sfondo scuro, corsivo, centrato o largo */
.msg-scene {
    background: rgba(20, 20, 25, 0.6);
    border-left: 4px solid #666;
    color: #aaa; /* Grigio chiaro */
    font-family: 'Georgia', serif;
    font-style: italic;
    padding: 12px 16px;
    margin: 15px 0; /* Spazio sopra e sotto */
    border-radius: 4px;
    font-size: 0.95em;
    box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
}

/* 2. IL DIALOGO (Personaggi) - Bolle separate */
.msg-char {
    background: #1e1e1e;
    border: 1px solid #333;
    border-radius: 12px;
    padding: 12px 16px;
    margin-bottom: 10px; /* Separazione tra messaggi */
    position: relative;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    max-width: 90%; /* Non prende tutta la larghezza */
}

/* Nome del personaggio sopra il messaggio */
.char-name {
    color: var(--accent); /* Oro */
    font-size: 0.75em;
    text-transform: uppercase;
    letter-spacing: 1px;
    font-weight: bold;
    margin-bottom: 4px;
    display: block;
    border-bottom: 1px solid rgba(255,255,255,0.05);
    padding-bottom: 4px;
}

.char-text {
    color: #eee;
    line-height: 1.5;
    font-size: 1em;
}

/* 3. LE AZIONI (Proposte) - Contenitore dedicato */
.msg-actions {
    margin-top: 15px;
    padding: 10px;
    background: rgba(44, 62, 80, 0.3); /* Bluastro scuro */
    border: 1px dashed var(--accent);
    border-radius: 12px;
    text-align: center;
}

.action-header {
    font-size: 0.8em;
    text-transform: uppercase;
    color: #888;
    margin-bottom: 8px;
}

.market-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 12px;
}

.market-item {
    border: 1px solid var(--border-soft);
    border-radius: 12px;
    padding: 12px;
    background: var(--bg-panel);
}

.market-header {
    display: flex;
    justify-content: space-between;
    font-weight: bold;
    margin-bottom: 8px;
}

.market-prices {
    display: flex;
    gap: 8px;
    margin-bottom: 8px;
}

.market-stats {
    font-size: 0.8em;
    color: var(--text-soft);
}

.resource-stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 8px;
}

.resource-stat-item {
    border: 1px solid var(--border-soft);
    border-radius: 8px;
    padding: 8px;
    background: var(--bg-panel);
}

.resource-stat-header {
    font-weight: bold;
    margin-bottom: 4px;
}

.resource-stat-values {
    display: flex;
    justify-content: space-between;
    font-size: 0.8em;
}

.resource-stat-values .positive { color: #6ada91; }
.resource-stat-values .negative { color: #ff7c7c; }

.market-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 12px;
}

.market-item {
    border: 1px solid var(--border-soft);
    border-radius: 12px;
    padding: 12px;
    background: var(--bg-panel);
}

.market-item.special {
    border-color: var(--accent);
    background: rgba(212, 175, 55, 0.1);
}

.market-header {
    display: flex;
    justify-content: space-between;
    font-weight: bold;
    margin-bottom: 8px;
}

.market-prices {
    display: flex;
    gap: 8px;
    margin-bottom: 8px;
}

.market-stats {
    font-size: 0.8em;
    color: var(--text-soft);
}

.market-desc {
    font-size: 0.8em;
    color: var(--text-soft);
    margin-top: 4px;
}

.diplomacy-actions {
    margin-top: 12px;
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
}

.market-section {
    margin-bottom: 20px;
}

.market-section h5 {
    color: var(--accent);
    margin-bottom: 8px;
    font-size: 0.9em;
}

.market-item.surplus {
    border-color: #4CAF50;
    background: rgba(76, 175, 80, 0.1);
}

.market-item.deficit {
    border-color: #f44336;
    background: rgba(244, 67, 54, 0.1);
}

.market-table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 20px;
    background: var(--bg-panel);
    border: 1px solid var(--border-soft);
    border-radius: 8px;
    overflow: hidden;
}

.market-table th {
    background: var(--bg-panel-alt);
    color: var(--accent);
    padding: 12px 8px;
    text-align: left;
    font-weight: bold;
    border-bottom: 1px solid var(--border-soft);
}

.market-table td {
    padding: 10px 8px;
    border-bottom: 1px solid var(--border-soft);
    vertical-align: middle;
}

.market-table tr:hover {
    background: rgba(212, 175, 55, 0.05);
}

.market-table .btn-sec {
    margin: 0 2px;
    padding: 4px 8px;
    font-size: 0.8em;
}

/* ===================== CLASSI SOCIALI ===================== */
.social-classes-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    gap: 8px;
    margin-bottom: 16px;
}

.social-class-card {
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 10px;
    text-align: center;
    transition: all 0.2s ease;
}

.social-class-card:hover {
    border-color: var(--accent);
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.social-class-header {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    margin-bottom: 8px;
    font-size: 0.9em;
    font-weight: 500;
}

.social-class-icon {
    font-size: 1.2em;
}

.social-class-name {
    color: var(--text);
}

.social-class-stats {
    display: flex;
    flex-direction: column;
    gap: 2px;
}

.social-class-count {
    font-size: 1.1em;
    font-weight: bold;
    color: var(--text);
}

.social-class-wealth {
    font-size: 0.8em;
    color: var(--text-soft);
}

/* ===================== STILI MERCATO MIGLIORATI ===================== */

.market-qty-input {
    width: 60px !important; /* Forza larghezza fissa */
    padding: 6px !important;
    text-align: center;
    margin: 0 4px;
    background: #222;
    border: 1px solid var(--border-soft);
    color: var(--text);
    border-radius: 4px;
}

/* Nascondi le frecce input number (opzionale, per pulizia) */
.market-qty-input::-webkit-outer-spin-button,
.market-qty-input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
}

/* Responsive Table: Trasforma la tabella in card su mobile */
@media (max-width: 768px) {
    .market-table, .market-table tbody, .market-table tr, .market-table td {
        display: block;
        width: 100%;
    }
    
    .market-table thead {
        display: none; /* Nascondi intestazione su mobile */
    }
    
    .market-table tr {
        margin-bottom: 15px;
        background: var(--bg-panel);
        border: 1px solid var(--border-soft);
        border-radius: 12px;
        padding: 12px;
        box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    }
    
    .market-table td {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 0;
        border-bottom: 1px solid rgba(255,255,255,0.05);
        text-align: right;
    }
    
    .market-table td:last-child {
        border-bottom: none;
        padding-top: 12px;
        justify-content: center;
        flex-wrap: wrap;
        gap: 8px;
    }

    /* Aggiunge etichette simulate via CSS per ogni cella */
    .market-table td:nth-of-type(1):before { content: "Risorsa"; font-weight: bold; color: var(--accent); }
    .market-table td:nth-of-type(2):before { content: "In Stock"; color: var(--text-soft); }
    .market-table td:nth-of-type(3):before { content: "Fabbisogno"; color: var(--text-soft); }
    .market-table td:nth-of-type(4):before { content: "Domanda"; color: var(--text-soft); }
    .market-table td:nth-of-type(5):before { content: "Offerta"; color: var(--text-soft); }
    .market-table td:nth-of-type(6):before { content: "Prezzo Acquisto"; color: #ff7c7c; }
    .market-table td:nth-of-type(7):before { content: "Prezzo Vendita"; color: #6ada91; }

    /* Nascondi il label per la cella delle azioni */
    .market-table td:last-child:before { content: ""; display: none; }

    /* Stile risorsa principale più grande */
    .market-table td:nth-of-type(1) {
        font-size: 1.1em;
        border-bottom: 1px solid var(--accent);
        margin-bottom: 8px;
        padding-bottom: 8px;
    }
}

/* ===================== STILI DINASTIA ===================== */

.dynasty-header-card {
    background: linear-gradient(135deg, #2c1e10, #1a1a1a);
    border: 2px solid var(--accent);
    padding: 20px;
    border-radius: 12px;
    text-align: center;
    margin-bottom: 20px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
}

.dynasty-role {
    font-size: 0.8em;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--text-soft);
    margin-bottom: 5px;
}

.dynasty-stats {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin: 10px 0;
    font-size: 1.1em;
}

.dynasty-traits {
    font-style: italic;
    color: #aaa;
}

.dynasty-section {
    margin-bottom: 20px;
    background: rgba(255,255,255,0.03);
    padding: 15px;
    border-radius: 12px;
    border: 1px solid var(--border-soft);
}

.dynasty-section h4 {
    border-bottom: 1px solid var(--border-soft);
    padding-bottom: 8px;
    margin-bottom: 15px;
    color: var(--accent);
}

.dynasty-empty-slot {
    text-align: center;
    padding: 20px;
    border: 2px dashed var(--border-soft);
    border-radius: 8px;
    color: var(--text-soft);
}

.heir-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 10px;
}

.person-card-ui {
    background: #222;
    border: 1px solid #444;
    padding: 10px;
    border-radius: 8px;
    text-align: center;
}

.person-card-ui.heir { border-color: #6ada91; }
.person-card-ui.spouse { border-color: #d4af37; }

.candidate-card {
    background: #1a1a1a;
    border: 1px solid #444;
    padding: 15px;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.candidate-origin { font-size: 0.8em; color: var(--accent); }
.candidate-bonus { font-size: 0.9em; color: #81c784; }

/* ===================== NUOVO HUD (STILE DARK MEDIEVAL) ===================== */

/* Barra Superiore (Contenitore Generale) */
.top-hud {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    /* Sfondo scuro semitrasparente uniforme al gioco */
    background: rgba(12, 12, 12, 0.95); 
    border-bottom: 1px solid var(--border-soft);
    z-index: 1000;
    padding: 10px 20px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.6);
    backdrop-filter: blur(8px);
    display: flex;
    justify-content: space-between;
    align-items: center;
    height: 60px; /* Altezza fissa desktop */
}

/* Statistiche (Sinistra/Alto) */
.hud-stats-bar {
    display: flex;
    gap: 20px;
    align-items: center;
}

.hud-stats-bar .stat {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.95em;
    color: var(--text);
    font-family: 'Georgia', serif;
}

.hud-stats-bar .stat i {
    color: var(--accent); /* Oro */
    font-size: 1.1em;
}

/* Navigazione (Destra/Basso) */
.hud-nav-bar {
    display: flex;
    gap: 8px;
}

.hud-nav-bar button {
    background: transparent;
    border: 1px solid transparent;
    color: var(--text-soft);
    padding: 6px 12px;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
    font-family: 'Georgia', serif;
    font-size: 0.85em;
    text-transform: uppercase;
    letter-spacing: 1px;
    display: flex;
    align-items: center;
    gap: 6px;
}

/* Hover e Stato Attivo */
.hud-nav-bar button:hover {
    background: rgba(255, 255, 255, 0.05);
    color: var(--text);
}

.hud-nav-bar button.active {
    background: rgba(212, 175, 55, 0.15); /* Oro scuro trasparente */
    border-color: var(--accent);
    color: var(--accent);
    box-shadow: 0 0 10px rgba(212, 175, 55, 0.1);
}

/* Spaziatura contenuto principale per non finire sotto la barra */
.system-toolbar {
    margin-top: 80px; 
    padding: 20px;
}

/* ===================== MOBILE REDESIGN (USER FRIENDLY) ===================== */
@media (max-width: 768px) {
    
    /* 1. La barra superiore tiene SOLO le statistiche */
    .top-hud {
        height: 50px;
        padding: 0 12px;
        justify-content: center;
        background: #080808; /* Nero quasi totale */
        border-bottom: 1px solid #333;
    }

    .hud-stats-bar {
        width: 100%;
        justify-content: space-between;
        gap: 0;
        font-size: 0.8em; /* Testo più piccolo */
    }
    
    /* Nascondiamo l'icona o riduciamo spazio se necessario */
    .hud-stats-bar .stat { gap: 4px; }

    /* 2. La barra di navigazione scende in BASSO (App Style) */
    .hud-nav-bar {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: #121212; /* Grigio scuro */
        border-top: 1px solid var(--accent); /* Linea dorata sopra */
        height: 70px; /* Altezza fissa per il tocco */
        z-index: 2000;
        
        /* Abilita lo scroll orizzontale se i pulsanti sono troppi */
        overflow-x: auto;
        overflow-y: hidden;
        white-space: nowrap;
        
        /* Centratura e spaziatura */
        padding: 8px 10px;
        gap: 12px;
        justify-content: flex-start; /* Allinea a sinistra per lo scroll */
        
        /* Nascondi scrollbar nativa ma permetti scroll */
        -webkit-overflow-scrolling: touch; 
        scrollbar-width: none; /* Firefox */
    }
    
    .hud-nav-bar::-webkit-scrollbar { 
        display: none; /* Chrome/Safari */
    }

    /* Stile Pulsanti Mobile */
    .hud-nav-bar button {
        flex: 0 0 auto; /* Non schiacciare i pulsanti */
        display: flex;
        flex-direction: column; /* Icona sopra, testo sotto */
        justify-content: center;
        align-items: center;
        min-width: 65px;
        padding: 4px;
        font-size: 0.65em; /* Testo molto piccolo leggibile */
        background: #1a1a1a;
        border: 1px solid #333;
        border-radius: 8px;
        color: #aaa;
    }
    
    /* Rimuoviamo emoji dal testo se necessario o le ingrandiamo */
    .hud-nav-bar button {
        gap: 4px;
    }

    /* Stato attivo mobile molto visibile */
    .hud-nav-bar button.active {
        background: #252525;
        border-color: var(--accent);
        color: #fff;
        transform: translateY(-2px);
    }

    /* Aggiustiamo i margini del contenuto */
    .system-toolbar {
        margin-top: 60px; /* Spazio per stats sopra */
        margin-bottom: 80px; /* Spazio per nav sotto */
        padding: 10px;
    }
    
    /* Nascondiamo la vecchia bottom-nav se presente nel codice originale per evitare duplicati */
    .bottom-nav {
        display: none !important; 
    }
}

/* Stili Pannello Bisogni */
.needs-legend {
    font-size: 0.75em;
    margin-bottom: 10px;
    display: flex;
    gap: 15px;
    justify-content: flex-end;
}

.need-entry {
    background: rgba(12,12,12,0.6);
    border: 1px solid var(--border-soft);
    border-radius: 8px;
    padding: 10px;
    margin-bottom: 8px;
    display: flex;
    flex-direction: column;
    gap: 6px;
}

.need-entry-header {
    display: flex;
    justify-content: space-between;
    font-size: 0.9em;
    font-weight: bold;
    color: var(--accent);
}

.need-bars-container {
    display: flex;
    flex-direction: column;
    gap: 6px;
}

.need-bar-row {
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 0.75em;
    color: var(--text-soft);
}

.need-track {
    flex: 1;
    height: 6px;
    background: #222;
    border-radius: 3px;
    overflow: hidden;
}

.need-fill {
    height: 100%;
    border-radius: 3px;
    transition: width 0.5s ease;
}

.fill-prim { background: #6ada91; }
.fill-sec { background: #64b5f6; }

/* Status Warning */
.need-warning {
    color: #ff7c7c;
    font-size: 0.8em;
    margin-top: 4px;
    font-style: italic;
    background: rgba(255, 0, 0, 0.1);
    padding: 4px 8px;
    border-radius: 4px;
/* Stile per il Modale Cronache */
.chronicle-content {
    max-width: 650px;
    background: #1a1612; /* Sfondo scuro caldo/marrone */
    border: 2px solid var(--accent);
    box-shadow: 0 0 50px rgba(0,0,0,0.9);
    text-align: left;
    font-family: 'Georgia', serif; /* Font serif per la narrativa */
    line-height: 1.6;
    color: #e0d8c0; /* Colore pergamena chiaro per il testo */
}

.chronicle-header {
    text-align: center;
}

.chronicle-header h2 {
    font-family: 'Cinzel', serif; /* Se disponibile, o Georgia */
    color: var(--accent);
    letter-spacing: 2px;
    margin-bottom: 5px;
}

.chronicle-text {
    font-size: 1.1em;
    min-height: 200px;
    white-space: pre-wrap; /* Mantiene i paragrafi dell'IA */
}

.chronicle-text p {
    margin-bottom: 15px;
}

/* Animazione caricamento */
.loading-story {
    text-align: center;
    padding: 40px;
    color: #888;
    font-style: italic;
}

.scribe-icon {
    font-size: 3em;
    display: block;
    margin-bottom: 15px;
    animation: writing 1s infinite alternate;
}

@keyframes writing {
    from { transform: rotate(-5deg); }
    to { transform: rotate(5deg); }
}

/* Messaggi dei Sovrani Stranieri */
.msg-foreign {
    border-left: 4px solid; 
    background: rgba(30, 20, 20, 0.8);
    padding: 15px;
    margin: 10px 0;
    border-radius: 0 10px 10px 0;
    position: relative;
}

.msg-foreign.auvrey { border-color: #d32f2f; } /* Rosso per Auvrey (Aggressivi) */
.msg-foreign.falken { border-color: #1976d2; } /* Blu per Falken (Commerciali) */

.foreign-badge {
    font-size: 0.7em;
    text-transform: uppercase;
    background: #000;
    padding: 2px 6px;
    border-radius: 4px;
    margin-bottom: 5px;
    display: inline-block;
    letter-spacing: 1px;
}

.msg-actions {
    margin-top: 15px;
    padding: 15px;
    background: rgba(44, 62, 80, 0.5);
    border: 1px dashed var(--accent);
    border-radius: 12px;
    text-align: center;
    position: relative; /* Importante */
    z-index: 10;        /* Assicura che sia sopra lo sfondo */
}

.action-card {
    display: block;
    width: 100%;
    margin-bottom: 8px;
    padding: 12px;
    background: #1f2a36;
    border: 1px solid #34495e;
    color: #ecf0f1;
    border-radius: 8px;
    cursor: pointer; /* Fondamentale per UX */
    text-align: left;
    transition: background 0.2s, transform 0.1s;
    pointer-events: auto; /* Assicura che riceva i click */
}

.action-card:hover {
    background: #2c3e50;
    border-color: var(--accent);
    transform: translateX(5px);
}

.action-card:active {
    transform: scale(0.98);
}

    </style>
</head>

<body>

<!-- MENU INIZIALE -->
<div id="screen-start" class="screen active">
    <div class="start-hero">
        <h1>Il Conte a Corte</h1>
        <p>Gestisci il tuo dominio, conserva la memoria delle partite e prepara il tono della corte.</p>
    </div>

    <div class="start-grid">
        <div class="start-card">
            <h3>Chiave API Groq</h3>
            <p class="toolbar-status">Archivia la chiave per evitarne l'inserimento a ogni avvio.</p>
            <input id="api-key-start" type="password" placeholder="gsk_xxxxxxxxx" />
            <div style="display:flex; gap:10px; flex-wrap:wrap;">
                <button class="btn-main" onclick="saveApiKeyFromStart()">Salva chiave</button>
                <button class="btn-sec" onclick="clearStoredApiKey()">Rimuovi</button>
                <button class="btn-sec" onclick="openLoginScreen()">Accedi</button>
            </div>
            <span id="api-key-status" class="toolbar-status">Chiave non impostata.</span>
        </div>

        <div class="start-card">
            <h3>Nuova Partita</h3>
            <p class="toolbar-status">Prepara un nuovo regno e configura i tuoi consiglieri.</p>
            <button class="btn-main" onclick="goToEditorScreen()">Crea nuovo regno</button>
            <button class="btn-sec" onclick="openLoginScreen()">Gestisci accesso</button>
        </div>

        <div class="start-card">
            <h3>Partite Salvate</h3>
            <div id="save-list"></div>
            <button class="btn-sec" onclick="openLoadModal()">Gestisci salvataggi</button>
            <div class="start-nav-icons" style="margin-top:12px; display:flex; gap:18px; justify-content:space-between; align-items:center; padding-top:10px; border-top:1px dashed var(--border-soft);">
                <div style="text-align:center; flex:1;">
                    <div style="font-size:20px">🏰</div>
                    <div style="font-size:12px; color:var(--text-soft);">Dominio</div>
                </div>
                <div style="text-align:center; flex:1;">
                    <div style="font-size:20px">⚖️</div>
                    <div style="font-size:12px; color:var(--text-soft);">Diplomazia</div>
                </div>
                <div style="text-align:center; flex:1;">
                    <div style="font-size:20px">🗺️</div>
                    <div style="font-size:12px; color:var(--text-soft);">Mappa</div>
                </div>
                <div style="text-align:center; flex:1;">
                    <div style="font-size:20px">📜</div>
                    <div style="font-size:12px; color:var(--text-soft);">Cronache</div>
                </div>
                <div style="text-align:center; flex:1;">
                    <div style="font-size:20px">🗣️</div>
                    <div style="font-size:12px; color:var(--text-soft);">Interlocutori</div>
                </div>
            </div>
        </div>

        <div class="start-card personality-form">
            <h3>Editor Personalità</h3>
            <label for="personality-tone">Tono del Consigliere</label>
            <select id="personality-tone">
                <option value="saggio">Saggio</option>
                <option value="pragmatico">Pragmatico</option>
                <option value="ambizioso">Ambizioso</option>
                <option value="misterioso">Misterioso</option>
            </select>

            <label for="personality-mood">Atmosfera della Corte</label>
            <select id="personality-mood">
                <option value="prudente">Prudente</option>
                <option value="bellicosa">Bellicosa</option>
                <option value="visionaria">Visionaria</option>
                <option value="ombrosa">Ombrosa</option>
            </select>

            <label for="personality-notes">Appunti della Corte</label>
            <textarea id="personality-notes" placeholder="Annota mantra, paure o principi che guidano il regno..."></textarea>

            <button class="btn-main" onclick="savePersonalitySettingsForm()">Salva Personalità</button>
        </div>
    </div>
</div>

<!-- SCHERMATA LOGIN -->
<div id="screen-login" class="screen">
    <h2>Accesso al Regno</h2>
    <label>Chiave API Groq:</label>
    <input id="api-key-input" type="text" placeholder="gsk_xxxxxxxxx" />

    <button class="btn-main" onclick="loginManual()">Entra</button>
</div>

<!-- EDITOR INIZIALE -->
<div id="screen-editor" class="screen">
    <h2>Crea il tuo Regno</h2>

    <label>Nome del Conte:</label>
    <input id="hero-name" type="text" placeholder="Es. Conte Alaric" />

    <label>Descrivi la tua Contea iniziale:</label>
    <textarea id="county-desc-init"></textarea>

    <label>Consigliere – Nome:</label>
    <input id="adv-name" type="text" placeholder="Es. Ser Dorian" />

    <label>Consigliere – Personalità:</label>
    <select id="adv-pers">
        <option value="saggio">Saggio</option>
        <option value="pragmatico">Pragmatico</option>
        <option value="ambizioso">Ambizioso</option>
        <option value="pauroso">Pauroso</option>
        <option value="corrotto">Corrotto</option>
    </select>

    <button class="btn-main" onclick="startGame()">Inizia il Regno</button>
</div>

<!-- SCHERMATA DI GIOCO PRINCIPALE -->
<div id="screen-game" class="screen">
    <div class="top-hud">
        <div class="hud-stats-bar">
            <div class="stat"><i class="fas fa-calendar-alt"></i> <span id="hud-season">Primavera 1325</span></div>
            <div class="stat"><i class="fas fa-coins"></i> <span id="hud-gold">0</span></div>
            <div class="stat"><i class="fas fa-users"></i> <span id="hud-pop">0</span></div>
            <div class="stat"><i class="fas fa-smile"></i> <span id="hud-happy">50</span></div>
            <div class="stat"><i class="fas fa-shield-alt"></i> <span id="hud-security">50</span></div>
        </div>
        <div class="hud-nav-bar">
            <button onclick="switchTab('tab-chat', this)" class="active">📜 Cronache</button>
            <button onclick="switchTab('tab-dominio', this)">🏰 Dominio</button>
            <button onclick="switchTab('tab-warehouse', this)">📦 Magazzino</button>
            <button onclick="switchTab('tab-diplomacy', this)">⚔️ Guerra</button>
            <button onclick="switchTab('tab-map', this)">🗺️ Mappa</button>
            <button onclick="switchTab('tab-market', this)">🏪 Mercato</button>
            <button onclick="switchTab('tab-dynasty', this)">👑 Dinastia</button>
            <button onclick="switchTab('tab-private', this)">🗣️ Interlocutori</button>
            <button onclick="openBuildingModal()">🔨 Costruzioni</button>
        </div>
    </div>

    <div class="system-toolbar">
        <div class="season-effects-text" id="season-effects-text">Il clima è mite, i raccolti prosperano.</div>

<!-- ================= TAB: DOMINIO ================= -->
<div id="tab-dominio" class="tab-view">

    <h2>Il Dominio del Conte</h2>

    <h3>Descrizione</h3>
    <p id="visual-desc">Una giovane contea in attesa del suo destino…</p>

    <!-- ===================== STATISTICHE GENERALI ===================== -->
    <h3>Statistiche</h3>
    <div class="grid-stats">
        <div class="stat-card">
            <div class="stat-val" id="val-pop">0</div>
            <div id="pop-delta" class="stat-delta pop-delta"></div>
            <div class="stat-sub">Popolazione</div>
        </div>

        <div class="stat-card" style="cursor:pointer;" onclick="openBudgetModal()">
            <div class="stat-val" id="val-gold">0</div>
            <div id="gold-delta" class="stat-delta" aria-hidden="true"></div>
            <div class="stat-sub">Oro</div>
        </div>
    </div>

    <!-- ===================== NEED BARS ===================== -->
    <div class="need-row">
        <div class="need-header">
            <span>Cibo</span>
            <span id="txt-food">0%</span>
            <span id="food-delta" class="stat-delta" aria-hidden="true"></span>
        </div>
        <div class="need-bar-bg">
            <div class="need-bar-fill fill-food" id="bar-food"></div>
        </div>
    </div>

    <div class="need-row">
        <div class="need-header">
            <span>Salute</span>
            <span id="txt-health">0%</span>
            <span id="health-delta" class="stat-delta" aria-hidden="true"></span>
        </div>
        <div class="need-bar-bg">
            <div class="need-bar-fill fill-health" id="bar-health"></div>
        </div>
    </div>

    <div class="need-row">
        <div class="need-header">
            <span>Felicità</span>
            <span id="txt-happy">0%</span>
        </div>
        <div class="need-bar-bg">
            <div class="need-bar-fill fill-happy" id="bar-happy"></div>
        </div>
    </div>

    <div class="need-row">
        <div class="need-header">
            <span>Stabilità Sociale</span>
            <span id="txt-stability">0%</span>
        </div>
        <div class="need-bar-bg">
            <div class="need-bar-fill fill-stability" id="bar-stability"></div>
        </div>
    </div>

    <!-- ===================== CLASSI SOCIALI ===================== -->
    <h3>Classi Sociali</h3>
    <div class="social-classes-grid">
        <div class="social-class-card">
            <div class="social-class-header">
                <span class="social-class-icon">👑</span>
                <span class="social-class-name">Nobiltà</span>
            </div>
            <div class="social-class-stats">
                <div class="social-class-count" id="nobility-count">0</div>
                <div class="social-class-wealth" id="nobility-wealth">0💰</div>
            </div>
        </div>
        
        <div class="social-class-card">
            <div class="social-class-header">
                <span class="social-class-icon">⛪</span>
                <span class="social-class-name">Clero</span>
            </div>
            <div class="social-class-stats">
                <div class="social-class-count" id="clergy-count">0</div>
                <div class="social-class-wealth" id="clergy-wealth">0💰</div>
            </div>
        </div>
        
        <div class="social-class-card">
            <div class="social-class-header">
                <span class="social-class-icon">⚔️</span>
                <span class="social-class-name">Milizia</span>
            </div>
            <div class="social-class-stats">
                <div class="social-class-count" id="militia-count">0</div>
                <div class="social-class-wealth" id="militia-wealth">0💰</div>
            </div>
        </div>
        
        <div class="social-class-card">
            <div class="social-class-header">
                <span class="social-class-icon">🏛️</span>
                <span class="social-class-name">Borghesi</span>
            </div>
            <div class="social-class-stats">
                <div class="social-class-count" id="burghers-count">0</div>
                <div class="social-class-wealth" id="burghers-wealth">0💰</div>
            </div>
        </div>
        
        <div class="social-class-card">
            <div class="social-class-header">
                <span class="social-class-icon">👥</span>
                <span class="social-class-name">Contadini</span>
            </div>
            <div class="social-class-stats">
                <div class="social-class-count" id="peasants-count">0</div>
                <div class="social-class-wealth" id="peasants-wealth">0💰</div>
            </div>
        </div>
        
        <div class="social-class-card">
            <div class="social-class-header">
                <span class="social-class-icon">🔮</span>
                <span class="social-class-name">Mistici</span>
            </div>
            <div class="social-class-stats">
                <div class="social-class-count" id="mystics-count">0</div>
                <div class="social-class-wealth" id="mystics-wealth">0💰</div>
            </div>
        </div>
        
        <div class="social-class-card">
            <div class="social-class-header">
                <span class="social-class-icon">🏚️</span>
                <span class="social-class-name">Emarginati</span>
            </div>
            <div class="social-class-stats">
                <div class="social-class-count" id="outcasts-count">0</div>
                <div class="social-class-wealth" id="outcasts-wealth">0💰</div>
            </div>
        </div>
        
        <div class="social-class-card">
            <div class="social-class-header">
                <span class="social-class-icon">⚖️</span>
                <span class="social-class-name">Mercanti</span>
            </div>
            <div class="social-class-stats">
                <div class="social-class-count" id="merchants-count">0</div>
                <div class="social-class-wealth" id="merchants-wealth">0💰</div>
            </div>
        </div>
    </div>

    <!-- ===================== BISOGNI E CONSUMI ===================== -->
    <button class="section-toggle" onclick="togglePanel('panel-needs')">
        Soddisfazione e Potere d'Acquisto
        <span>Analisi Consumi</span>
    </button>
    <div id="panel-needs" class="section-panel collapsed">
        <div class="needs-legend">
            <span style="color:#6ada91">■ Primari (Sopravvivenza)</span>
            <span style="color:#64b5f6">■ Secondari (Comfort)</span>
        </div>
        <div id="needs-list-container">
            <div class="save-empty">Dati disponibili dopo il primo turno.</div>
        </div>
    </div>

    <!-- ===================== RISORSE INVENTARIO ===================== -->
    <h3>Territorio</h3>

    <div class="grid-stats">
        <div class="stat-card">
            <div class="stat-val" id="land-count">0</div>
            <div class="stat-sub">Terre del Conte</div>
        </div>
        <div class="stat-card">
            <div class="stat-val" id="land-nobility">0</div>
            <div class="stat-sub">Nobiltà</div>
        </div>
        <div class="stat-card">
            <div class="stat-val" id="land-clergy">0</div>
            <div class="stat-sub">Clero</div>
        </div>
        <div class="stat-card">
            <div class="stat-val" id="land-commons">0</div>
            <div class="stat-sub">Comuni</div>
        </div>
    </div>

    <!-- ===================== RISORSE INVENTARIO ===================== -->
    <button class="section-toggle" onclick="togglePanel('panel-resources')">
        Risorse e Magazzini
        <span>Apri/chiudi elenco</span>
    </button>
    <div id="panel-resources" class="section-panel">
        <div class="grid-stats resource-grid">
            <div class="stat-card">
                <div class="stat-val" id="res-wood">0</div>
                <div class="stat-sub">Legno</div>
                <small class="res-delta" id="res-wood-delta">—</small>
            </div>
            <div class="stat-card">
                <div class="stat-val" id="res-stone">0</div>
                <div class="stat-sub">Pietra</div>
                <small class="res-delta" id="res-stone-delta">—</small>
            </div>
            <div class="stat-card">
                <div class="stat-val" id="res-iron">0</div>
                <div class="stat-sub">Ferro</div>
                <small class="res-delta" id="res-iron-delta">—</small>
            </div>
            <div class="stat-card">
                <div class="stat-val" id="res-copper">0</div>
                <div class="stat-sub">Rame</div>
                <small class="res-delta" id="res-copper-delta">—</small>
            </div>
            <div class="stat-card">
                <div class="stat-val" id="res-gold">0</div>
                <div class="stat-sub">Oro grezzo</div>
                <small class="res-delta" id="res-gold-delta">—</small>
            </div>
            <div class="stat-card">
                <div class="stat-val" id="res-herbs">0</div>
                <div class="stat-sub">Erbe medicinali</div>
                <small class="res-delta" id="res-herbs-delta">—</small>
            </div>
            <div class="stat-card">
                <div class="stat-val" id="res-grain">0</div>
                <div class="stat-sub">Grano</div>
                <small class="res-delta" id="res-grain-delta">—</small>
            </div>
            <div class="stat-card">
                <div class="stat-val" id="res-livestock">0</div>
                <div class="stat-sub">Bestiame</div>
                <small class="res-delta" id="res-livestock-delta">—</small>
            </div>
            <div class="stat-card">
                <div class="stat-val" id="res-textiles">0</div>
                <div class="stat-sub">Tessuti</div>
                <small class="res-delta" id="res-textiles-delta">—</small>
            </div>
            <div class="stat-card">
                <div class="stat-val" id="res-luxuries">0</div>
                <div class="stat-sub">Beni di pregio</div>
                <small class="res-delta" id="res-luxuries-delta">—</small>
            </div>
            <div class="stat-card">
                <div class="stat-val" id="res-arcane">0</div>
                <div class="stat-sub">Essenza arcana</div>
                <small class="res-delta" id="res-arcane-delta">—</small>
            </div>
            <div class="stat-card">
                <div class="stat-val" id="res-weapons">0</div>
                <div class="stat-sub">Armi</div>
                <small class="res-delta" id="res-weapons-delta">—</small>
            </div>
            <div class="stat-card">
                <div class="stat-val" id="res-armor">0</div>
                <div class="stat-sub">Armature</div>
                <small class="res-delta" id="res-armor-delta">—</small>
            </div>
        </div>
    </div>

    <button class="section-toggle" onclick="togglePanel('panel-assets')">
        Sintesi Insediamenti
        <span>Case, botteghe, campi…</span>
    </button>
    <div id="panel-assets" class="section-panel collapsed">
        <div id="asset-summary" class="asset-grid">
            <div class="asset-card">I dettagli compariranno dopo l'avvio.</div>
        </div>
    </div>

    <button class="section-toggle" onclick="togglePanel('panel-factions')">
        Influenze delle Fazioni
        <span>Mostra condizioni correnti</span>
    </button>
    <div id="panel-factions" class="section-panel collapsed">
        <div id="faction-impact-list" class="faction-effects">
            <div class="faction-effect-card">Le fazioni reagiranno dopo il primo turno.</div>
        </div>
    </div>

    <button class="section-toggle" onclick="togglePanel('panel-taxes')">
        Politica Fiscale
        <span>Modifica categorie</span>
    </button>
    <div id="panel-taxes" class="section-panel collapsed">
        <div class="tax-panel">
            <div id="tax-grid" class="tax-grid"></div>
            <div class="tax-summary">
                <span>Entrate ultimo turno: <strong id="tax-last">0</strong> oro</span>
                <span>Trend: <strong id="tax-trend">—</strong></span>
            </div>
        </div>
    </div>

    <button class="section-toggle" onclick="togglePanel('panel-laws')">
        Leggi e Decreti
        <span>Gestisci editti</span>
    </button>
    <div id="panel-laws" class="section-panel collapsed">
        <div id="law-list" class="law-list" style="margin-bottom:12px;"></div>
        <div class="law-creator">
            <input id="law-custom-name" type="text" placeholder="Nome della legge" />
            <textarea id="law-custom-desc" placeholder="Descrivi obiettivi e vincoli"></textarea>
            <select id="law-custom-type">
                <option value="production">Bonus produzione</option>
                <option value="taxes">Modifica tassazione</option>
                <option value="factions">Influenza fazioni</option>
            </select>
            <select id="law-custom-target"></select>
            <input id="law-custom-value" type="number" step="0.5" placeholder="Valore (es. 10)" />
            <button class="btn-main" onclick="createCustomLaw()">Istituisci nuova legge</button>
        </div>
    </div>

    <!-- ===================== RAPPRESENTANTI DELLE FAZIONI ===================== -->
    <h3>Rappresentanti delle Fazioni</h3>

    <div class="representatives-grid">
        <div class="person-card">
            <div class="person-name">Lord Emeric di Montferrand</div>
            <div>Nobiltà — 46 anni. Orgoglioso e ambizioso.</div>
        </div>

        <div class="person-card">
            <div class="person-name">Vescovo Aldebrando di Sorenza</div>
            <div>Clero — 62 anni. Inflessibile e calcolatore.</div>
        </div>

        <div class="person-card">
            <div class="person-name">Capitano Ronan il Ferro</div>
            <div>Milizia — 38 anni. Diretto, leale, irritabile.</div>
        </div>

        <div class="person-card">
            <div class="person-name">Odric il Lavoratore</div>
            <div>Contadini — 33 anni. Paziente ma oppresso.</div>
        </div>

        <div class="person-card">
            <div class="person-name">Maestro Bernard Forgiatore</div>
            <div>Artigiani — 51 anni. Orgoglioso del mestiere.</div>
        </div>

        <div class="person-card">
            <div class="person-name">Ser Lothar dei Ponti</div>
            <div>Mercanti — 42 anni. Subdolo, affabile.</div>
        </div>

        <div class="person-card">
            <div class="person-name">Madre Elowen la Veggente</div>
            <div>Mistici — 67 anni. Enigmatica, calma.</div>
        </div>

        <div class="person-card">
            <div class="person-name">Rasko il Senzapatria</div>
            <div>Emarginati — 29 anni. Imprevedibile e rapido.</div>
        </div>
    </div>

</div>
<!-- ====================== TAB: MAGAZZINO ====================== -->
<div id="tab-warehouse" class="tab-view">

    <h2>📦 Magazzino e Risorse</h2>
    <p style="color: var(--text-soft); font-size: 0.9em; margin-bottom: 20px;">
        Monitora lo stock, la produzione, il consumo e l'autonomia di tutte le risorse.
    </p>
    
    <!-- Riepilogo veloce -->
    <div class="warehouse-summary" id="warehouse-summary"></div>

    <!-- Risorse critiche -->
    <div class="warehouse-section" id="critical-resources-section" style="display: none;">
        <h3 style="color: var(--accent); margin-top: 0;">⚠️ Risorse Critiche</h3>
        <div class="resource-list" id="critical-resources"></div>
    </div>

    <!-- Risorse in attenzione -->
    <div class="warehouse-section" id="warning-resources-section" style="display: none;">
        <h3 style="color: var(--accent); margin-top: 0;">⚡ Risorse in Attenzione</h3>
        <div class="resource-list" id="warning-resources"></div>
    </div>

    <!-- Tutte le risorse -->
    <div class="warehouse-section">
        <h3 style="color: var(--accent); margin-top: 0;">📊 Tutte le Risorse</h3>
        <div class="resource-list" id="all-resources"></div>
    </div>

    <!-- Bisogni popolazione -->
    <div class="population-needs">
        <h3 style="color: var(--accent); margin-top: 0;">👥 Bisogni della Popolazione</h3>
        <div class="needs-grid" id="population-needs"></div>
    </div>

</div>
<!-- ====================== TAB: DIPLOMAZIA ====================== -->
<div id="tab-diplomacy" class="tab-view">
    <h2>Sala della Guerra e Diplomazia</h2>
    
    <div class="panel" style="border-color: #f44336; margin-bottom: 20px;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
            <h3 style="color:#f44336; margin:0;">⚔️ Gestione Esercito</h3>
            <span id="army-status" style="font-size:0.9em; color:#aaa;">Stato: Pace</span>
        </div>
        
        <div class="grid-stats">
            <div class="stat-card">
                <div class="stat-val" id="mil-soldiers">0</div>
                <div class="stat-sub">Milizia (Professionisti)</div>
            </div>
            <div class="stat-card">
                <div class="stat-val" id="mil-levies">0</div>
                <div class="stat-sub">Leva (Contadini)</div>
            </div>
            <div class="stat-card">
                <div class="stat-val" id="mil-power">0</div>
                <div class="stat-sub">Potenza Totale</div>
            </div>
            <div class="stat-card">
                <div class="stat-val" id="mil-weapons">0</div>
                <div class="stat-sub">Armi in Magazzino</div>
            </div>
            <div class="stat-card">
                <div class="stat-val" id="mil-efficiency">100%</div>
                <div class="stat-sub">Efficienza Bellica</div>
            </div>
        </div>

        <div style="background:#220a0a; padding:10px; border-radius:8px; margin-top:10px; border:1px dashed #522;">
            <p style="font-size:0.9em; color:#ccc; margin-top:0;">
                Mobilitare i contadini fornisce un esercito numeroso ma distrugge l'economia agricola e riduce le tasse.
            </p>
            <button id="btn-mobilize" class="btn-main" style="background: linear-gradient(120deg, #8b0000, #4a0000); color:white;" onclick="toggleMobilization()">
                🔔 Chiama la Leva (Mobilita Contadini)
            </button>
        </div>
    </div>

    <div id="diplomacy-list">
        </div>
</div>


<!-- ====================== TAB: MAPPA ====================== -->
<div id="tab-map" class="tab-view">

    <h2>Mappa della Contea</h2>
    <canvas id="county-map" width="480" height="480"
            style="border:1px solid #333; width:100%; margin-bottom:20px;"></canvas>

    <div class="map-legend">
        <div class="legend-item">
            <span class="legend-marker legend-circle"></span>
            <span>Villaggi e borghi del Conte</span>
        </div>
        <div class="legend-item">
            <span class="legend-marker legend-diamond"></span>
            <span>Miniere (metalli preziosi)</span>
        </div>
        <div class="legend-item">
            <span class="legend-triangle"></span>
            <span>Segherie e taglialegna</span>
        </div>
        <div class="legend-item">
            <span class="legend-marker legend-square"></span>
            <span>Cave e cantieri di pietra</span>
        </div>
        <div class="legend-item">
            <span class="legend-marker legend-cross"></span>
            <span>Monasteri e luoghi sacri</span>
        </div>
    </div>

    <h3>Mappa Regionale</h3>
    <canvas id="region-map" width="320" height="320"
            style="border:1px solid #333; width:100%;"></canvas>

</div>


<!-- ====================== TAB: MERCATO ====================== -->
<div id="tab-market" class="tab-view">
    <h3>Mercato Commerciale</h3>
    <p>Scambia risorse con le contee vicine e gestisci il mercato interno. I prezzi esterni riflettono gli accordi commerciali, mentre il mercato interno mostra surplus e deficit locali.</p>
    
    <div id="market-content">
        <!-- Contenuto popolato da renderMarket() -->
    </div>
</div>

<!-- ====================== TAB: DINASTIA ====================== -->
<div id="tab-dynasty" class="tab-view">
    <h2>Casata Reale</h2>
    
    <div class="dynasty-header-card">
        <div class="dynasty-role">Regnante Attuale</div>
        <h3 id="dynasty-ruler-name">Conte Alaric</h3>
        <div class="dynasty-stats">
            <span>Età: <strong id="dynasty-ruler-age">25</strong></span>
            <span>Salute: <strong id="dynasty-ruler-health">Ottima</strong></span>
        </div>
        <p id="dynasty-ruler-traits" class="dynasty-traits">Tratti: Ambizioso, Carismatico</p>
    </div>

    <div class="dynasty-section">
        <h4>Consorte</h4>
        <div id="spouse-container">
            <div class="dynasty-empty-slot">
                <p>Il Conte non è sposato.</p>
                <button class="btn-main" onclick="openMarriageMarket()">Cerca Pretendenti</button>
            </div>
        </div>
    </div>

    <div class="dynasty-section">
        <h4>Eredi e Figli</h4>
        <div id="heirs-list" class="heir-grid">
            <p class="text-soft">Nessun erede. La linea di successione è a rischio!</p>
        </div>
    </div>

    <div class="dynasty-section">
        <button class="section-toggle" onclick="togglePanel('court-marriage-panel')">
            Matrimoni di Corte
            <span>Fai sposare i consiglieri</span>
        </button>
        <div id="court-marriage-panel" class="section-panel collapsed">
            <p class="text-soft">Puoi combinare matrimoni per i tuoi consiglieri per rafforzare la lealtà delle fazioni.</p>
            <div id="court-marriage-list"></div>
        </div>
    </div>
</div>

<!-- ====================== TAB: CRONACHE (CHAT PUBBLICA) ====================== -->
<div id="tab-chat" class="tab-view active-tab">
    <div class="court-layout">
        
        <div class="court-main">
            <div class="chat-panel">
                <div class="chat-header">
                    <div style="display:flex; align-items:center; gap:10px;">
                        <span>👑 SALA DEL TRONO</span>
                        <span id="chat-turn" style="opacity:0.6; font-size:0.8em;">Anno 1325</span>
                    </div>
                    <div id="chat-faction-chips" class="faction-chips-inline"></div>
                </div>

                <div id="chat-log" class="chat-log"></div>

                <div class="input-area">
                    <input type="text" id="u-input" 
                           placeholder="Pronuncia un ordine, Conte..." 
                           autocomplete="off"
                           onkeypress="if(event.key==='Enter') send()">
                    <button class="send-btn" onclick="send()">➤</button>
                </div>
                
                <button class="season-advance-btn" onclick="advanceSeasonManually()">
                    🔔 Suona la campana (Avanza Stagione)
                </button>
            </div>
        </div>

        <div class="court-sidebar">
            
            <div class="sidebar-panel">
                <div class="panel-title">🏗️ Cantieri Reali</div>
                <div id="construction-feed" class="event-feed">
                    <p class="event-empty">Nessun cantiere.</p>
                </div>
            </div>

            <div class="sidebar-panel">
                <div class="panel-title">📜 Dispacci</div>
                <div id="event-feed" class="event-feed compact">
                    <p class="event-empty">Tutto tace.</p>
                </div>
            </div>

            <div class="sidebar-panel action-wrapper">
                <div class="panel-title">⚖️ Proposte</div>
                <div id="action-list" class="action-list compact"></div>
                <button class="btn-sec small" onclick="askAdvisor()">🧠 Chiedi consiglio</button>
            </div>

            <div class="sidebar-panel">
                <div class="panel-title">🧠 I Consigli di Ser Dorian</div>
                <div id="advice-feed" class="event-feed compact" style="min-height: 100px;">
                    <p class="advice-empty">Sono al vostro servizio, mio Signore.</p>
                </div>
            </div>

        </div>
    </div>
</div>


<!-- ====================== TAB: INTERLOCUTORI (CHAT PRIVATE) ====================== -->
<div id="tab-private" class="tab-view">
    <h2>Colloqui Privati</h2>

    <div id="family-chat-buttons" style="border-bottom:1px dashed #444; padding-bottom:10px; margin-bottom:10px; display:none;">
        <h4 style="margin:0 0 5px 0; color:var(--accent);">Casata Reale</h4>
        <div id="family-selector" class="private-selector" style="margin:0;">
            </div>
    </div>

    <h4 style="margin:0 0 5px 0; color:#888;">Fazioni e Vicini</h4>
    <div id="private-selector" class="private-selector">
        <button class="btn-sec" onclick="openPrivateChat('nobility')">Lord Emeric (Nobiltà)</button>
        <button class="btn-sec" onclick="openPrivateChat('clergy')">Vescovo Aldebrando (Clero)</button>
        <button class="btn-sec" onclick="openPrivateChat('militia')">Cap. Ronan (Milizia)</button>
        <button class="btn-sec" onclick="openPrivateChat('peasants')">Odric (Contadini)</button>
        <button class="btn-sec" onclick="openPrivateChat('burghers')">Bernard Forgiatore (Artigiani)</button>
        <button class="btn-sec" onclick="openPrivateChat('merchants')">Ser Lothar (Mercanti)</button>
        <button class="btn-sec" onclick="openPrivateChat('mystics')">Madre Elowen (Mistici)</button>
        <button class="btn-sec" onclick="openPrivateChat('outcasts')">Rasko (Emarginati)</button>
        <button class="btn-sec" onclick="openPrivateChat('auvrey')">Messo di Auvrey</button>
        <button class="btn-sec" onclick="openPrivateChat('falken')">Ambasciatrice di Falken</button>
    </div>

    <div id="private-chat-box" style="display:none;">
        <div class="chat-panel">
            <div class="chat-header" id="private-chat-title">Colloquio</div>
            <div id="private-chat-log" class="chat-log"></div>
            <div class="input-area">
                <input id="private-input" type="text" placeholder="Parla privatamente..." onkeypress="if(event.key==='Enter') sendPrivate()" />
                <button class="send-btn" onclick="sendPrivate()">➤</button>
            </div>
        </div>
        <button class="btn-main" style="margin-top:10px;" onclick="closePrivateChat()">Concludi colloquio</button>
    </div>
</div>

</div>

</div>

<div id="load-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Salvataggi</h3>
            <button class="close-btn" onclick="closeLoadModal()">✕</button>
        </div>

        <label for="save-slot-name">Nome salvataggio</label>
        <input id="save-slot-name" type="text" placeholder="Es. dopo assedio" />
        <button class="btn-main" onclick="manualSaveFromModal()">Salva in nuovo slot</button>

        <div id="modal-save-list"></div>
    </div>
</div>

<div id="modal-buildings" class="modal">
    <div class="modal-content" style="width: min(700px, 95vw);">
        <div class="modal-header">
            <h3>Registro dell'Architetto</h3>
            <button class="close-btn" onclick="closeBuildingModal()">✕</button>
        </div>
        <p style="font-size:0.9em; color:#aaa; margin-bottom:15px;">
            Seleziona un progetto per avviare il cantiere. Le risorse verranno dedotte immediatamente.
        </p>
        <div id="building-grid" class="start-grid">
            </div>
    </div>
</div>

<div id="modal-marriage" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Proposte di Matrimonio</h3>
            <button class="close-btn" onclick="closeMarriageModal()">✕</button>
        </div>
        <div id="marriage-candidates" class="start-grid"></div>
    </div>
</div>

<div id="modal-gameover" class="modal" style="z-index: 9999; background: rgba(0,0,0,0.95);">
    <div class="modal-content" style="text-align:center; border: 1px solid #d32f2f; background: #1a0505; max-width: 600px;">
        <h1 style="color:#d32f2f; font-family: 'Cinzel', serif; font-size: 3em; margin-bottom: 10px;">IL REGNO È CADUTO</h1>
        
        <div id="death-icon" style="font-size: 4em; margin: 20px 0;">☠️</div>
        
        <div id="gameover-story" style="font-style: italic; color: #e0e0e0; margin-bottom: 30px; line-height: 1.6;">
            </div>
        
        <div class="stat-summary" style="display:flex; justify-content:center; gap:20px; color:#888; font-size:0.9em; margin-bottom:30px;">
            <span>Anni di Regno: <strong id="go-years">0</strong></span>
            <span>Eredità: <strong id="go-legacy">Dimenticato</strong></span>
        </div>

        <button class="btn-main" onclick="location.reload()">👑 Nuova Dinastia (Ricomincia)</button>
    </div>
</div>

<script>
/* ============================================================
   =================== VARIABILI PRINCIPALI ====================
   ============================================================ */

let apiKey = "";
let heroName = "";

// Helper per formattare denaro a centesimi
function fmtMoney(v) {
    const n = Number(v) || 0;
    return n.toFixed(2);
}

// --- DATI DINASTIA ---
let dynasty = {
    ruler: {
        name: "Conte", // Sarà sovrascritto da heroName
        age: 25,
        maxAge: 75 + Math.floor(Math.random() * 15), // Morte naturale tra 75 e 90
        health: 100,
        traits: ["Fondatore"]
    },
    spouse: null, // Oggetto { name, age, origin, bonus }
    heirs: []     // Array di oggetti { name, age, gender, traits }
};

let activeSuitorsList = []; // Per tenere traccia dei pretendenti generati

// Tracciamento della rabbia accumulata per fazione
let rebellionState = {
    nobility: 0, clergy: 0, militia: 0, peasants: 0,
    burghers: 0, merchants: 0, mystics: 0, outcasts: 0
};

// Soglie di pericolo
const UNREST_WARNING = 5; // Dopo 5 turni di infelicità: Avvertimento (era 3)
const UNREST_DANGER = 8;  // Dopo 8 turni: Tentativo di sabotaggio (era 5)
const UNREST_REVOLT = 12;  // Dopo 12 turni: GAME OVER / Tentativo di uccisione (era 8)

// Memoria della chat pubblica (ultimi 10-15 scambi)
let publicChatHistory = [];

const RESOURCE_KEYS = [
    // Materie Prime
    "wood","stone","iron","copper","gold","grain","livestock","wool","herbs","clay",
    // Semilavorati
    "flour", "iron_ingots", "fabric", "leather",
    // Prodotti Finiti (Alto valore)
    "bread", "tools", "clothes", "weapons", "armor", "furniture", "pottery",
    // Speciali
    "luxuries","arcane","textiles","cotton"
];

const resourceLabels = {
    wood: "Legno",
    stone: "Pietra",
    iron: "Ferro",
    copper: "Rame",
    gold: "Oro",
    herbs: "Erbe",
    grain: "Grano",
    livestock: "Bestiame",
    wool: "Lana",
    clay: "Argilla",
    flour: "Farina",
    iron_ingots: "Lingotti di Ferro",
    fabric: "Stoffa",
    leather: "Pelle",
    bread: "Pane",
    tools: "Utensili",
    clothes: "Vestiti",
    furniture: "Mobili",
    pottery: "Ceramica",
    textiles: "Tessuti",
    luxuries: "Beni di pregio",
    arcane: "Essenza arcana",
    weapons: "Armi",
    armor: "Armature",
    cotton: "Cotone"
};

const POP_NEEDS = {
    peasants: {
        // Mangiano pane (o grano se poveri)
        primary: { bread: 0.5 }, 
        // Vestiti base
        secondary: { clothes: 0.1, tools: 0.05 } 
    },
    burghers: {
        primary: { bread: 1.0, clothes: 0.2 },
        secondary: { furniture: 0.1, luxuries: 0.05 }
    },
    nobility: {
        primary: { bread: 1.5, clothes: 0.5 }, // Vestiti di lusso (consumano di più)
        secondary: { luxuries: 0.5, weapons: 0.1, furniture: 0.2 }
    },
    militia: {
        primary: { bread: 1.2 },
        secondary: { weapons: 0.1, armor: 0.05 } // La milizia consuma equipaggiamento
    },
    merchants: {
        primary: { bread: 0.8, clothes: 0.3 },
        secondary: { luxuries: 0.1, furniture: 0.1 }
    },
    clergy: {
        primary: { bread: 0.7, clothes: 0.2 },
        secondary: { luxuries: 0.05, arcane: 0.02 }
    },
    mystics: {
        primary: { bread: 0.3, herbs: 0.1 },
        secondary: { arcane: 0.05, luxuries: 0.01 }
    },
    outcasts: {
        primary: { bread: 0.2 }, // Mangiano poco
        secondary: { wood: 0.02 }
    }
};

const SEASON_CYCLE = [
    {
        key: "spring",
        label: "Primavera",
        description: "Il disgelo porta nuova linfa ai campi.",
        production: { grain: 1.15, livestock: 1.05, herbs: 1.1 },
        warCost: 1,
        morale: { peasants: 2 }
    },
    {
        key: "summer",
        label: "Estate",
        description: "I mercati sono colmi e le strade sicure.",
        production: { grain: 1.05, livestock: 1.1, luxuries: 1.05 },
        warCost: 1.05,
        morale: { merchants: 2 }
    },
    {
        key: "autumn",
        label: "Autunno",
        description: "Si raccolgono tributi e si preparano le scorte.",
        production: { grain: 0.85, livestock: 0.9, herbs: 1.05 },
        warCost: 1.1,
        morale: { nobility: 1 }
    },
    {
        key: "winter",
        label: "Inverno",
        description: "La neve blocca i raccolti e le campagne militari sono dispendiose.",
        production: { grain: 0.2, livestock: 0.35, herbs: 0.6 },
        warCost: 1.35,
        morale: { peasants: -3, militia: -2 }
    }
];

function createDefaultWorldTime() {
    return { year: 1325, seasonIndex: 0 };
}

let worldTime = createDefaultWorldTime();

const TAX_CATEGORIES = [
    { key:"nobility", label:"Nobiltà", wealthFactor:6, tolerance:8 },
    { key:"clergy", label:"Clero", wealthFactor:4, tolerance:6 },
    { key:"militia", label:"Milizia", wealthFactor:3, tolerance:5 },
    { key:"peasants", label:"Contadini", wealthFactor:2, tolerance:4 },
    { key:"burghers", label:"Artigiani", wealthFactor:5, tolerance:7 },
    { key:"merchants", label:"Mercanti", wealthFactor:7, tolerance:9 },
    { key:"mystics", label:"Mistici", wealthFactor:3, tolerance:5 },
    { key:"outcasts", label:"Emarginati", wealthFactor:1, tolerance:3 }
];

function createDefaultTaxPolicy() {
    const policy = {};
    TAX_CATEGORIES.forEach(cat => { policy[cat.key] = 5; });
    return policy;
}

let taxPolicy = createDefaultTaxPolicy();
let taxHistory = [];

const BASE_LAW_LIBRARY = [
    {
        key: "grain_subsidy",
        name: "Sussidi Agricoli",
        description: "Il Conte paga parte delle sementi.",
        upkeepCost: 20, // Costo fisso in Oro per turno
        effects: {
            production: { grain: 1.25 },
            factions: { peasants: 4, nobility: -1 }
        }
    },
    {
        key: "bread_for_poor",
        name: "Pane per i Poveri",
        description: "Distribuzione gratuita di cibo agli indigenti.",
        upkeepCost: 50, // Costoso!
        consumeResource: { grain: 20 }, // Consuma anche cibo fisico
        effects: {
            factions: { peasants: 10, outcasts: 10, nobility: -5 },
            county: { health: 2, happy: 5 }
        }
    },
    {
        key: "road_maintenance",
        name: "Manutenzione Strade Reali",
        description: "Investimento costante nella viabilità.",
        upkeepCost: 30,
        effects: {
            production: { gold: 1.1 }, // Aumenta efficienza commerciale
            factions: { merchants: 5 }
        }
    },
    {
        key: "trade_charter",
        name: "Carta dei Mercanti",
        description: "Agevolazioni per i mercanti: aumenta beni di pregio e oro, ma l'artigianato subisce concorrenza.",
        effects: {
            production: { luxuries: 1.2, textiles: 0.95 },
            taxes: { merchants: 2, burghers: -1 },
            factions: { merchants: 5, burghers: -3 }
        }
    },
    {
        key: "conscription_edict",
        name: "Editto di Leva",
        description: "Arruola contadini e artigiani nella milizia. Più sicurezza, ma malcontento tra i campi.",
        effects: {
            production: { grain: 0.9 },
            military: { manpower: 1.15 },
            factions: { militia: 5, peasants: -4, burghers: -2 }
        }
    }
];

function calculateDetailedUpkeep(targetState = null) {
    const buildingList = targetState ? targetState.buildings : buildings;
    const landCount = targetState ? targetState.landOwnership.count : landOwnership.count;
    
    let military = 0;
    let civil = 0;
    let court = 0;

    // 1. Mantenimento Edifici Specifici
    buildingList.forEach(b => {
        if (b.stage !== 'complete') return;
        const data = buildingData[b.type];
        if (!data || !data.upkeep) return;

        const cost = data.upkeep;

        // Categorizzazione
        if (['watchtower','barracks','stone_walls','mercenary_camp'].includes(b.type)) {
            military += cost;
        } else if (['noble_estate','grand_cathedral','library','theater'].includes(b.type)) {
            court += cost;
        } else {
            civil += cost; // Mercati, pozzi, ecc.
        }
    });

    // 2. Mantenimento Infrastrutture (Strade e Ponti astratti)
    // Costo basato sulla dimensione del territorio controllato (1 oro per tile)
    const infra = Math.floor(landCount * 1.5); 

    return { military, civil, court, infrastructure: infra };
}

let customLaws = [];
let activeLaws = [];
let lastResourceSnapshot = null;
let lastResourceDelta = null;

const RESERVED_SAVE_SLOTS = ["autosave", "quick"];
const DEFAULT_PERSONALITY = { advisorTone:"saggio", courtMood:"prudente", notes:"" };
let personalitySettings = { ...DEFAULT_PERSONALITY };

function createDefaultResources() {
    return {
        wood: 40,
        stone: 20,
        iron: 10,
        copper: 5,
        gold: 50,
        herbs: 25,
        grain: 180,
        livestock: 80,
        textiles: 35,
        luxuries: 20,
        arcane: 15,
        weapons: 0,
        armor: 0
    };
}

function createDefaultCounty() {
    return {
        desc: "",
        pop: 1200,
        gold: 500,
        food: 50,
        health: 50,
        happy: 50,
        security: 50,
        turn: 1,
        resources: createDefaultResources()
    };
}

let county = createDefaultCounty();
lastResourceSnapshot = cloneResourceBag(county.resources);
lastResourceDelta = createEmptyResourceDelta();
let industrySummary = null;

// Tracciamo l'ultimo stato per mostrare delta stagionale (pop, gold, food, health)
let lastPop = county.pop;
let lastGold = county.gold;
let lastFood = county.food;
let lastHealth = county.health;

// Memoria dell'ultimo stato dei bisogni per l'IA
let lastNeedsReport = {};

// AGGIUNGI QUESTO OGGETTO GLOBALE PER LA GUERRA
let warState = {
    active: false,           // Siamo in guerra?
    enemy: null,             // Contro chi? (key della contea)
    mobilized: false,        // Abbiamo chiamato la leva?
    leviesCount: 0,          // Contadini prestati alla guerra
    armyMorale: 50,          // Morale dell'esercito
    lastBattleResult: null   // Ultimo esito per la cronaca
};

// Variabile per tracciare se siamo in una negoziazione attiva
let activeDiplomacy = {
    active: false,
    partner: null, // 'auvrey' o 'falken'
    type: null     // 'demand_gold', 'demand_land', 'offer_alliance', 'threat_war'
};

// Struttura globale per il bilancio dettagliato
let detailedBudget = {
    income: {
        taxes_nobility: 0,
        taxes_burghers: 0,
        taxes_peasants: 0,
        taxes_other: 0,
        trade_export: 0,
        production_mint: 0 // Zecca
    },
    expenses: {
        upkeep_military: 0,      // Soldati, torri, mura
        upkeep_civil: 0,         // Mercati, pozzi, edifici pubblici
        upkeep_court: 0,         // Famiglia reale, lussi, cattedrali
        upkeep_infrastructure: 0,// Strade, ponti (calcolato su estensione territorio)
        welfare_laws: 0,         // Costo leggi attive (es. pane per i poveri)
        import_costs: 0          // Acquisti automatici o manuali
    },
    net: 0
};

// Registro degli eventi del turno corrente
let currentTurnEvents = [];

function logTurnEvent(text) {
    // Aggiunge un evento alla lista (es. "È nato un figlio", "Costruito mercato")
    currentTurnEvents.push(text);
}


// Tracciamento transazioni economiche per il rapporto stagionale
let seasonalTransactions = {
    marketPurchases: 0,
    marketSales: 0,
    specialPurchases: 0,
    taxes: 0,
    maintenance: 0
};

/* ===================== TERRITORIO ===================== */
function createDefaultLand() {
    return {
        count: 25,
        nobility: 55,
        clergy: 15,
        commons: 5
    };
}

let landOwnership = createDefaultLand();

const TOTAL_LAND = 100;

/* ===================== POPOLAZIONE ===================== */
function createDefaultPopulation() {
    return {
        nobility: { count: 25, wealth: 500, literacy: 90, workforceRatio: 0.2, employed: 0, resources: createEmptyResourceBag() },
        clergy: { count: 15, wealth: 200, literacy: 95, workforceRatio: 0.8, employed: 0, resources: createEmptyResourceBag() },
        militia: { count: 60, wealth: 50, literacy: 20, workforceRatio: 1.0, employed: 0, resources: createEmptyResourceBag() },
        peasants: { count: 900, wealth: 10, literacy: 5, workforceRatio: 0.7, employed: 0, resources: createEmptyResourceBag() },
        burghers: { count: 120, wealth: 100, literacy: 40, workforceRatio: 0.8, employed: 0, resources: createEmptyResourceBag() },
        merchants: { count: 80, wealth: 150, literacy: 70, workforceRatio: 0.9, employed: 0, resources: createEmptyResourceBag() },
        mystics: { count: 10, wealth: 30, literacy: 30, workforceRatio: 0.5, employed: 0, resources: createEmptyResourceBag() },
        outcasts: { count: 40, wealth: 5, literacy: 0, workforceRatio: 0.6, employed: 0, resources: createEmptyResourceBag() }
    };
}

let populationGroups = createDefaultPopulation();

function adjustPopulation(group, delta, targetState = null) {
    const groups = targetState ? targetState.populationGroups : populationGroups;
    if (!groups[group]) groups[group] = 0;
    groups[group] = Math.max(0, groups[group] + delta);
    recomputePopulation(targetState);
}

function recomputePopulation(targetState = null) {
    const groups = targetState ? targetState.populationGroups : populationGroups;
    const targetCounty = targetState ? targetState.county : county;
    targetCounty.pop = Object.values(groups).reduce((sum, val) => sum + (val.count || val), 0);
}

/* ===================== SISTEMA DINASTIA ===================== */

// Helper per età leggibile
function getAgeLabel(age) {
    return Math.floor(age);
}

// 1. AVANZAMENTO ETÀ (Da chiamare dentro progressSeason)
/* ===================== CICLO DELLA VITA (EVENTI DINASTICI) ===================== */

// Funzione principale da chiamare dentro progressSeason()
function processLifeEvents() {
    // 1. Invecchiamento e Recupero
    advanceAgeAndRecovery(dynasty.ruler);
    if (dynasty.spouse) advanceAgeAndRecovery(dynasty.spouse);
    
    // Rimuovi eredi morti o processa invecchiamento
    if (dynasty.heirs.length > 0) {
        // Filter crea un nuovo array tenendo solo i vivi
        dynasty.heirs = dynasty.heirs.filter(heir => {
            advanceAgeAndRecovery(heir);
            // Se è morto durante l'invecchiamento (checkDeath chiamato dentro), lo rimuoviamo qui?
            // No, checkDeath gestisce la logica. Qui filtriamo se health <= 0 o flag 'dead'
            return !heir.isDead;
        });
    }

    // 2. Eventi Negativi (Malattia / Incidente)
    // Più bassa è la salute/sicurezza della contea, più alto il rischio
    const illnessRisk = Math.max(0.05, (100 - county.health) / 200); // 5% min, sale se health bassa
    const accidentRisk = Math.max(0.02, (100 - county.security) / 300); // 2% min, sale se security bassa

    // Tenta evento sul Conte
    rollLifeEvent(dynasty.ruler, illnessRisk, accidentRisk);

    // Tenta evento sul Consorte
    if (dynasty.spouse) rollLifeEvent(dynasty.spouse, illnessRisk, accidentRisk);

    // Tenta evento su UN figlio a caso (per non spammare)
    if (dynasty.heirs.length > 0) {
        const randomHeir = dynasty.heirs[Math.floor(Math.random() * dynasty.heirs.length)];
        rollLifeEvent(randomHeir, illnessRisk, accidentRisk);
    }

    // 3. Tentativo di Nascita (solo se c'è consorte)
    if (dynasty.spouse && !dynasty.ruler.isDead && !dynasty.spouse.isDead) {
        checkBirth();
    }

    // 4. Morte (Il Mietitore controlla tutti)
    // Nota: checkDeath viene chiamato dentro advanceAgeAndRecovery per naturale, 
    // ma chiamiamolo qui per eventi traumatici appena accaduti
    checkDeath(dynasty.ruler, "ruler");
    if (dynasty.spouse) checkDeath(dynasty.spouse, "spouse");
    dynasty.heirs.forEach(h => checkDeath(h, "heir"));

    updateDynastyUI();
}

// Gestisce invecchiamento e guarigione naturale
function advanceAgeAndRecovery(person) {
    person.age += 0.25;
    
    // Recupero salute se ha tratti negativi
    if (person.traits.includes("Malato")) {
        // Se la contea ha buona salute o ospedali, guarisce
        const cureChance = county.health > 60 ? 0.4 : 0.1; 
        if (Math.random() < cureChance) {
            removeTrait(person, "Malato");
            addMsg("system", `🌿 <strong>Guarigione:</strong> ${person.name} ha sconfitto la malattia.`);
        }
    }
    
    if (person.traits.includes("Ferito")) {
        const cureChance = 0.5; // Le ferite guariscono più facilmente
        if (Math.random() < cureChance) {
            removeTrait(person, "Ferito");
            addMsg("system", `🩹 <strong>Guarigione:</strong> Le ferite di ${person.name} si sono rimarginate.`);
        }
    }
}

// Tira i dadi per eventi sfortunati
function rollLifeEvent(person, baseIllnessRisk, baseAccidentRisk) {
    if (person.isDead) return;

    // Age multipliers
    let ageMultiplier = 1.0;
    if (person.age < 5) ageMultiplier = 2.0; // Children more vulnerable
    else if (person.age > 60) ageMultiplier = 1.5; // Elderly more vulnerable

    // Illness
    let illnessRisk = baseIllnessRisk * ageMultiplier;
    if (person.traits.includes("Robust")) illnessRisk *= 0.5;
    if (person.traits.includes("Frail")) illnessRisk *= 2.0;
    if (!person.traits.includes("Malato") && Math.random() < illnessRisk) {
        addTrait(person, "Malato");
        addMsg("system", `🤢 <strong>Malattia:</strong> ${person.name} si è ammalato.`);
    }

    // Accident
    let accidentRisk = baseAccidentRisk * ageMultiplier;
    if (person.traits.includes("Clumsy")) accidentRisk *= 2.0;
    if (person.traits.includes("Agile")) accidentRisk *= 0.5;
    if (!person.traits.includes("Ferito") && Math.random() < accidentRisk) {
        addTrait(person, "Ferito");
        addMsg("system", `🤕 <strong>Incidente:</strong> ${person.name} ha subito un incidente.`);
    }
}

// Gestisce la Nascita
function checkBirth() {
    // Età fertile approssimativa
    if (dynasty.ruler.age > 60 || dynasty.spouse.age > 45) return;
    if (dynasty.ruler.age < 16 || dynasty.spouse.age < 16) return;

    let chance = 0.05; // 5% base a stagione
    if (county.happy > 70) chance += 0.05; // Popolo felice = atmosfera migliore?
    if (county.food > 80) chance += 0.02; // Ben nutriti

    if (Math.random() < chance) {
        const isMale = Math.random() > 0.5;
        const name = isMale ? getRandomMaleName() : getRandomFemaleName();
        
        const child = {
            name: name,
            age: 0,
            gender: isMale ? "M" : "F",
            traits: [], // Nasce sano
            health: 100, // Valore salute interno (invisibile, usato per calcoli morte)
            isDead: false,
            maxAge: 70 + Math.floor(Math.random() * 20)
        };
        
        // Possibile complicazione parto (mortalità infantile medievale)
        if (Math.random() < 0.1) {
            addTrait(child, "Debole");
            addMsg("system", `⚠️ Il piccolo ${name} è nato, ma è molto debole.`);
        }

        dynasty.heirs.push(child);
        addMsg("system", `👶 <strong>Lieto Evento:</strong> È nato ${name}! La dinastia cresce.`);
        
        // Bonus felicità
        county.happy = Math.min(100, county.happy + 5);
        updateUI();
    }
}

// Il Tristo Mietitore
function checkDeath(person, role) {
    if (person.isDead) return;

    let deathChance = 0;

    // Età-based mortality curve
    if (person.age < 1) deathChance = 0.10; // Infant mortality
    else if (person.age < 5) deathChance = 0.02;
    else if (person.age < 15) deathChance = 0.005;
    else if (person.age < 30) deathChance = 0.001;
    else if (person.age < 50) deathChance = 0.005;
    else if (person.age < 60) deathChance = 0.02;
    else if (person.age < 70) deathChance = 0.05;
    else if (person.age < 80) deathChance = 0.10;
    else deathChance = 0.20; // Over 80

    // Trait modifiers
    if (person.traits.includes("Robust")) deathChance *= 0.5;
    if (person.traits.includes("Frail")) deathChance *= 2.0;
    if (person.traits.includes("Malato")) deathChance *= 3.0;
    if (person.traits.includes("Ferito")) deathChance *= 1.5;

    // Environmental factors
    if (county.health < 20) deathChance *= 1.5;
    if (county.food < 10) deathChance *= 2.0;
    if (county.security < 20) deathChance *= 1.2;

    // Roll for death
    if (Math.random() < deathChance) {
        person.isDead = true;
        handleDeathEffect(person, role);
    }
}

function handleDeathEffect(person, role) {
    const name = person.name;
    
    // Effetti scenici
    if (role === "ruler") {
        logTurnEvent(`The ruler ${name} has passed away.`);
        handleSuccession(); // Logica successione esistente
    } 
    else if (role === "spouse") {
        addMsg("system", `⚰️ <strong>Lutto Reale:</strong> Il consorte ${name} è deceduto. La corte è in lutto.`);
        logTurnEvent(`The consort ${name} has died.`);
        dynasty.spouse = null; // Rimuovi consorte
        county.happy = Math.max(0, county.happy - 10); // Era -15
    } 
    else if (role === "heir") {
        addMsg("system", `⚰️ <strong>Tragedia:</strong> Il giovane ${name} è morto prematuramente.`);
        logTurnEvent(`The heir ${name} has died prematurely.`);
        // La rimozione dall'array avviene nel filtro all'inizio di processLifeEvents
        county.happy = Math.max(0, county.happy - 7); // Era -10
    }
    
    updateUI();
}

// Helpers per i tratti
function addTrait(person, trait) {
    if (!person.traits) person.traits = [];
    if (!person.traits.includes(trait)) person.traits.push(trait);
}

function removeTrait(person, trait) {
    if (!person.traits) return;
    person.traits = person.traits.filter(t => t !== trait);
}

// 2. CONTROLLO MORTE
function checkRulerDeath() {
    const r = dynasty.ruler;
    const age = r.age;
    
    // Fattore di rischio base
    let deathChance = 0;

    // Vecchiaia
    if (age > 60) deathChance += 0.02; // 2% a stagione
    if (age > r.maxAge) deathChance += 0.50; // Rischio altissimo sopra maxAge

    // Salute
    if (county.health < 30) deathChance += 0.05;
    if (county.food < 10) deathChance += 0.10;

    if (Math.random() < deathChance) {
        handleSuccession();
    }
}

// 3. SUCCESSIONE O GAME OVER
function handleSuccession() {
    const deadRulerName = dynasty.ruler.name;
    
    // Cerca erede maggiorenne (o il più grande)
    const heir = dynasty.heirs.length > 0 ? dynasty.heirs[0] : null;

    if (heir) {
        // Successione riuscita
        alert(`👑 IL RE È MORTO, LUNGA VITA AL RE!\n\n${deadRulerName} è deceduto. Ora governi come ${heir.name}.`);
        addMsg("system", `💀 <b>LUTTO REALE:</b> ${deadRulerName} è morto. ${heir.name} ascende al trono.`);
        
        // Passaggio di consegne
        dynasty.ruler = {
            name: heir.name,
            age: heir.age,
            maxAge: 70 + Math.floor(Math.random() * 20),
            health: 100,
            traits: heir.traits || ["Erede"],
            isDead: false
        };
        
        // Resetta famiglia (il nuovo conte non è sposato con sua madre/padre!)
        dynasty.spouse = null; 
        dynasty.heirs = []; // I fratelli diventano cortigiani (semplificazione)
        
        updateDynastyUI();
        updateUI(); // Aggiorna nome conte
    } else {
        // GAME OVER
        document.getElementById("gameover-reason").innerText = `${deadRulerName} è morto all'età di ${Math.floor(dynasty.ruler.age)} anni senza lasciare eredi. La casata è estinta.`;
        document.getElementById("modal-gameover").classList.add("active");
    }
}

// 4. MATRIMONIO
function openMarriageMarket() {
    const modal = document.getElementById("modal-marriage");
    const grid = document.getElementById("marriage-candidates");
    grid.innerHTML = "";

    if (!activeSuitorsList || activeSuitorsList.length === 0) {
        activeSuitorsList = generateSuitors(); // Genera solo se non esiste
    }

    activeSuitorsList.forEach((suitor, index) => {
        // Inizializza chat temporanea per questo suitor
        const chatKey = `suitor_${index}`;
        privateChats[chatKey] = []; 

        const div = document.createElement("div");
        div.className = "candidate-card";
        div.innerHTML = `
            <strong>${suitor.name}</strong>
            <span class="candidate-origin">${suitor.originLabel}</span>
            <div>Età: ${suitor.age}</div>
            <div>Rapporto: ${suitor.relation}/100</div>
            <div class="candidate-bonus">${suitor.bonusDesc}</div>
            <div style="display:flex; gap:10px; margin-top:10px;">
                <button class="btn-sec" onclick="openPrivateChat('suitor_${index}')">💬 Parla</button>
                <button class="btn-sec" onclick="giveGiftToSuitor(${index})">🎁 Regala</button>
                <button class="btn-main" onclick="marrySuitorIndex(${index})">💍 Sposa</button>
            </div>
        `;
        grid.appendChild(div);
    });

    modal.classList.add("active");
}

function generateSuitors() {
    const suitors = [];
    // Candidato Nobile Locale
    suitors.push({
        name: "Lady Elara di Montferrand",
        age: 18 + Math.floor(Math.random()*10),
        origin: "nobility",
        originLabel: "Nobiltà Locale",
        bonusDesc: "+15 Lealtà Nobiltà, +100 Oro",
        effects: { faction: "nobility", gold: 100 },
        relation: 50
    });
    // Candidato Estero (Auvrey)
    if (neighboringCounties.find(c=>c.key==='auvrey').relations > 30) {
        suitors.push({
            name: "Contessina Isabella d'Auvrey",
            age: 20 + Math.floor(Math.random()*8),
            origin: "auvrey",
            originLabel: "Contea di Auvrey",
            bonusDesc: "Alleanza con Auvrey, Prezzi Mercato ridotti",
            effects: { relation: "auvrey", trade: true },
            relation: 50
        });
    }
    // Candidato Mercante
    suitors.push({
        name: "Ginevra la Ricca",
        age: 25 + Math.floor(Math.random()*15),
        origin: "merchants",
        originLabel: "Gilda Mercanti",
        bonusDesc: "+300 Oro immediato",
        effects: { gold: 300, faction: "merchants" },
        relation: 50
    });

    return suitors;
}

function marrySuitorIndex(index) {
    const suitor = activeSuitorsList[index];
    if(!suitor) return;
    
    if (suitor.relation < 90) {
        addMsg("system", `💔 Il rapporto con ${suitor.name} non è abbastanza alto (${suitor.relation}/100). Continua a parlare e regalare per migliorare il legame.`);
        return;
    }
    
    // Trasferisci la chat del suitor nella chat dello spouse (per mantenere lo storico!)
    const oldChatKey = `suitor_${index}`;
    if (privateChats[oldChatKey]) {
        privateChats['spouse'] = [...privateChats[oldChatKey]];
        // Aggiungi messaggio di sistema
        privateChats['spouse'].push({from:'system', text:'Il matrimonio è stato celebrato.'});
    }

    marrySuitor(suitor); // Chiama la funzione logica originale
}

function marrySuitor(suitor) {
    dynasty.spouse = suitor;
    dynasty.spouse.maxAge = 70 + Math.floor(Math.random() * 20);
    dynasty.spouse.traits = dynasty.spouse.traits || [];
    dynasty.spouse.isDead = false;
    closeMarriageModal();
    
    // Applica effetti
    if (suitor.effects.gold) county.gold += suitor.effects.gold;
    if (suitor.effects.faction) factions[suitor.effects.faction] += 15;
    if (suitor.effects.relation) {
        const n = neighboringCounties.find(c=>c.key === suitor.effects.relation);
        if(n) { n.relations += 30; n.tradeAgreement = true; }
    }

    addMsg("system", `💍 <b>MATRIMONIO REALE:</b> Il Conte ha sposato ${suitor.name}!`);
    logTurnEvent(`Matrimonio reale celebrato con ${suitor.name}`);
    updateDynastyUI();
    updateUI();
}

function closeMarriageModal() {
    document.getElementById("modal-marriage").classList.remove("active");
}

function giveGiftToSuitor(index) {
    const suitor = activeSuitorsList[index];
    if (!suitor) return;
    
    const giftCost = 50;
    if (county.gold < giftCost) {
        addMsg("system", "Non hai abbastanza oro per un regalo adeguato.");
        return;
    }
    
    county.gold -= giftCost;
    const relationGain = 10 + Math.floor(Math.random() * 11); // 10-20
    suitor.relation = Math.min(100, suitor.relation + relationGain);
    
    addMsg("system", `🎁 Hai regalato un dono prezioso a ${suitor.name}. Rapporto aumentato di ${relationGain} punti!`);
    updateUI();
    // Rileggi il modal per aggiornare il rapporto
    openMarriageMarket();
}

// 5. NASCITE
function checkBirth() {
    if (!dynasty.spouse) return;
    
    // Probabilità: più alta se entrambi giovani
    let chance = 0.08; // 8% a stagione base
    if (dynasty.ruler.age < 40 && dynasty.spouse.age < 35) chance += 0.10;
    
    if (Math.random() < chance) {
        const isMale = Math.random() > 0.5;
        const name = isMale ? getRandomMaleName() : getRandomFemaleName();
        
        const child = {
            name: name,
            age: 0,
            gender: isMale ? "M" : "F",
            traits: []
        };
        
        dynasty.heirs.push(child);
        addMsg("system", `👶 <b>LIETO EVENTO:</b> È nato un erede! Benvenuto al piccolo ${name}.`);
        logTurnEvent(`È nato un erede: ${name}`);
        
        // Se è il primo figlio, aumenta stabilità
        if (dynasty.heirs.length === 1) {
            addMsg("system", "La linea di successione è assicurata. Stabilità +10.");
        }
        
        updateDynastyUI();
    }
}

function getRandomMaleName() {
    const names = ["Edward", "William", "Henry", "Richard", "Baldwin", "Godfrey", "Charles"];
    return names[Math.floor(Math.random() * names.length)];
}

function getRandomFemaleName() {
    const names = ["Eleanor", "Matilda", "Isabella", "Adela", "Margaret", "Beatrice"];
    return names[Math.floor(Math.random() * names.length)];
}

// 6. INTERFACCIA UTENTE DINASTIA
function updateDynastyUI() {
    // Ruler
    const r = dynasty.ruler;
    let rulerStatus = "";
    if (r.traits.includes("Malato")) rulerStatus += "🤢 ";
    if (r.traits.includes("Ferito")) rulerStatus += "🤕 ";
    
    document.getElementById("dynasty-ruler-name").innerHTML = `${rulerStatus} ${r.name || heroName}`;
    document.getElementById("dynasty-ruler-age").innerText = Math.floor(r.age);
    document.getElementById("dynasty-ruler-health").innerText = county.health > 70 ? "Eccellente" : county.health > 40 ? "Buona" : "Cagionevole";
    
    // Spouse
    const spouseContainer = document.getElementById("spouse-container");
    if (dynasty.spouse) {
        let sStatus = "";
        if (dynasty.spouse.traits && dynasty.spouse.traits.includes("Malato")) sStatus += "🤢 ";
        
        spouseContainer.innerHTML = `
            <div class="person-card-ui spouse">
                <strong>${sStatus}${dynasty.spouse.name}</strong>
                <div>Età: ${Math.floor(dynasty.spouse.age)}</div>
                <div style="font-size:0.8em; color:#aaa;">${dynasty.spouse.originLabel}</div>
                <div style="font-size:0.8em; color:#ff7c7c;">${dynasty.spouse.traits ? dynasty.spouse.traits.join(", ") : ""}</div>
            </div>
        `;
    } else {
        spouseContainer.innerHTML = `
            <div class="dynasty-empty-slot">
                <p>Nessun consorte.</p>
                <button class="btn-main" onclick="openMarriageMarket()">Cerca Pretendenti</button>
            </div>
        `;
    }

    // Heirs
    const heirsList = document.getElementById("heirs-list");
    heirsList.innerHTML = "";
    if (dynasty.heirs.length === 0) {
        heirsList.innerHTML = `<p class="text-soft" style="grid-column: 1/-1; text-align:center;">Nessun erede.</p>`;
    } else {
        dynasty.heirs.forEach(h => {
            let hStatus = "";
            if (h.traits.includes("Malato")) hStatus += "🤢 ";
            if (h.traits.includes("Ferito")) hStatus += "🤕 ";
            if (h.traits.includes("Debole")) hStatus += "🍃 ";

            const div = document.createElement("div");
            div.className = "person-card-ui heir";
            div.innerHTML = `
                <strong>${hStatus}${h.name}</strong>
                <div>Età: ${Math.floor(h.age)}</div>
                <div style="font-size:0.8em;">${h.traits.join(", ") || "Sano"}</div>
            `;
            heirsList.appendChild(div);
        });
    }

    // --- AGGIORNAMENTO BOTTONI CHAT FAMIGLIA ---
    const familySection = document.getElementById("family-chat-buttons");
    const familySelector = document.getElementById("family-selector");
    
    if (!familySection || !familySelector) return;

    let hasFamily = false;
    let html = "";

    // Bottone Coniuge
    if (dynasty.spouse) {
        hasFamily = true;
        // Crea un ID univoco per la chat, es. 'spouse'
        html += `<button class="btn-sec" style="border-color:#d4af37" onclick="openPrivateChat('spouse')">❤️ ${dynasty.spouse.name} (Consorte)</button>`;
        
        // Assicura che esista l'array della chat in memoria
        if (!privateChats['spouse']) privateChats['spouse'] = [];
    }

    // Bottoni Eredi
    dynasty.heirs.forEach((heir, index) => {
        hasFamily = true;
        const chatKey = `heir_${index}`;
        html += `<button class="btn-sec" style="border-color:#6ada91" onclick="openPrivateChat('${chatKey}')">👶 ${heir.name} (Erede)</button>`;
        
        // Inizializza chat memoria
        if (!privateChats[chatKey]) privateChats[chatKey] = [];
    });

    familySelector.innerHTML = html;
    familySection.style.display = hasFamily ? "block" : "none";
}

// 7. EVENTI BAMBINI (Educazione)
function triggerChildEvent(child) {
    // Semplice scelta tramite prompt o modale (qui uso alert/prompt per semplicità, 
    // meglio sarebbe integrarlo nella chat azioni)
    
    // Per integrazione pulita, lo mandiamo come messaggio in chat azioni
    addMsg("system", `🎓 L'erede ${child.name} ha raggiunto i ${child.age} anni. È tempo di scegliere la sua educazione.`);
    
    // Aggiungiamo trait casuale per ora, in futuro collegare a bottoni azione
    const newTrait = Math.random() > 0.5 ? "Guerriero" : "Erudito";
    child.traits.push(newTrait);
}

/* ===================== FAZIONI ===================== */
const factionOrder = [
    "nobility","clergy","militia","peasants",
    "burghers","merchants","mystics","outcasts"
];

function createDefaultFactions() {
    return {
        nobility: 50,
        clergy: 50,
        militia: 50,
        peasants: 50,
        burghers: 50,
        merchants: 50,
        mystics: 50,
        outcasts: 50
    };
}

let factions = createDefaultFactions();

/* ===================== CONTEE VICINE ===================== */
function createDefaultNeighbors() {
    return [
        { 
            key:"auvrey", 
            name:"Contea di Auvrey", 
            ruler: "Conte Emeric il Giovane",
            traits: ["Aggressivo", "Orgoglioso", "Espansionista"],
            power: 70, 
            wealth: 50, 
            relations: 40, 
            aggression: 40, // Quanto è vicino alla guerra (0-100)
            fear: 10,       // Quanto teme il giocatore
            lastInteraction: 0,
            land:30,
            description: "Una contea ambiziosa guidata dal giovane Conte Emeric, che cerca di espandere i suoi confini attraverso alleanze e conquiste.",
            goals: ["Espandere territorio", "Formare alleanze matrimoniali", "Controllare rotte commerciali"],
            personality: "Ambizioso e calcolatore, ma impulsivo in battaglia.",
            specialResource: "textiles",
            events: []
        },
        { 
            key:"falken", 
            name:"Baronia di Falken", 
            ruler: "Baronessa Lidia",
            traits: ["Pragmatica", "Avida", "Difensiva"],
            power: 40, 
            wealth: 80, 
            relations: 60, 
            aggression: 10,
            fear: 20,
            lastInteraction: 0,
            land:18,
            description: "Una baronia montuosa difesa dal Barone Lothar, noto per le sue miniere e la sua neutralità.",
            goals: ["Mantenere indipendenza", "Sviluppare miniere", "Proteggere confini"],
            personality: "Difensivo e pragmatico, preferisce la diplomazia alla guerra.",
            specialResource: "iron",
            events: []
        }
    ];
}

let neighboringCounties = createDefaultNeighbors();

/* ===================== CONSIGLIERE ===================== */
let advisor = { name:"", personality:"" };

/* ===================== CHAT PRIVATE ===================== */
let activePrivateChat = null;
function createDefaultPrivateChats() {
    return {
        nobility:[], clergy:[], militia:[], peasants:[],
        burghers:[], merchants:[], mystics:[], outcasts:[],
        auvrey:[], falken:[]
    };
}

let privateChats = createDefaultPrivateChats();

function ensureWorldSystems(targetState = null) {
    if (targetState) {
        if (!targetState.worldTime) targetState.worldTime = createDefaultWorldTime();
        if (!targetState.taxPolicy) targetState.taxPolicy = createDefaultTaxPolicy();
        if (!Array.isArray(targetState.activeLaws)) targetState.activeLaws = [];
        if (!Array.isArray(targetState.taxHistory)) targetState.taxHistory = [];
        if (!targetState.lastResourceSnapshot) targetState.lastResourceSnapshot = captureResourceSnapshot(targetState);
        if (!targetState.lastResourceDelta) targetState.lastResourceDelta = createEmptyResourceDelta();
        if (!Array.isArray(targetState.customLaws)) targetState.customLaws = [];
        if (!targetState.industrySummary) targetState.industrySummary = summarizeIndustry(targetState.structures, targetState.settlements);
        if (targetState.county && targetState.county.security === undefined) targetState.county.security = 50;
        return;
    }

    if (!worldTime) worldTime = createDefaultWorldTime();
    if (!taxPolicy) taxPolicy = createDefaultTaxPolicy();
    if (!Array.isArray(activeLaws)) activeLaws = [];
    if (!Array.isArray(taxHistory)) taxHistory = [];
    if (!lastResourceSnapshot) lastResourceSnapshot = captureResourceSnapshot();
    if (!lastResourceDelta) lastResourceDelta = createEmptyResourceDelta();
    if (!Array.isArray(customLaws)) customLaws = [];
    if (!industrySummary) industrySummary = summarizeIndustry(structures, settlements);
    if (county && county.security === undefined) county.security = 50;
}

const FACTION_EFFECT_DESCRIPTIONS = {
    nobility: { bonus:"Sostengono opere e portano oro extra.", malus:"Pretendono privilegi, drenano le casse." },
    clergy: { bonus:"Intercedono per la salute pubblica.", malus:"Condannano il conte, calano devozione." },
    militia: { bonus:"Sorvegliano le strade, meno disordini.", malus:"Disertano e pretendono paga." },
    peasants: { bonus:"Coltivano con zelo, raccolti floridi.", malus:"Scioperano nei campi, raccolti scarsi." },
    burghers: { bonus:"Tessuti di qualità, stabilità urbana.", malus:"Artigiani in protesta, produzione lenta." },
    merchants: { bonus:"Più lussi e oro nei mercati.", malus:"Fuggono i capitali, calano gli scambi." },
    mystics: { bonus:"Rinforzano l'arcano e curano.", malus:"Diffondono superstizioni destabilizzanti." },
    outcasts: { bonus:"Meno crimini e più informatori.", malus:"Disordini e sabotaggi frequenti." }
};

const RESOURCE_FACTION_MAP = {
    grain: { faction:"peasants", scale:0.3 },
    livestock: { faction:"peasants", scale:0.25 },
    textiles: { faction:"burghers", scale:0.25 },
    luxuries: { faction:"merchants", scale:0.3 },
    arcane: { faction:"mystics", scale:0.35 },
    herbs: { faction:"clergy", scale:0.2 }
};

const ASSET_RULES = [
    {
        key:"housing_poor",
        label:"Case Povere",
        getCount: summary => (summary.housing && summary.housing.poor) || 0,
        consume:{ grain:4, wood:0.4 }
    },
    {
        key:"housing_middle",
        label:"Case Medie",
        getCount: summary => (summary.housing && summary.housing.middle) || 0,
        consume:{ grain:3, livestock:0.8, textiles:0.5 },
        gold:1.5
    },
    {
        key:"housing_noble",
        label:"Residenze Nobili",
        getCount: summary => (summary.housing && summary.housing.noble) || 0,
        consume:{ grain:2, livestock:1.5, luxuries:1.2 },
        gold:3
    },
    {
        key:"farms",
        label:"Campi Coltivati",
        getCount: summary => summary.farms || 0,
        produce:{ grain:32 },
        consume:{ wood:0.6 }
    },
    {
        key:"ranches",
        label:"Allevamenti",
        getCount: summary => summary.ranches || 0,
        produce:{ livestock:11 },
        consume:{ grain:7, herbs:0.5 }
    },
    {
        key:"shops",
        label:"Botteghe",
        getCount: summary => summary.shops || 0,
        produce:{ textiles:6, luxuries:1.5 },
        consume:{ grain:1.8, iron:0.6, copper:0.4 },
        gold:4
    },
    {
        key:"churches",
        label:"Chiese",
        getCount: summary => summary.churches || 0,
        produce:{ herbs:2 },
        consume:{ grain:0.8 },
        gold:2
    }
];

function getSeason(timeRef = worldTime) {
    const ref = timeRef || worldTime;
    if (!ref) return SEASON_CYCLE[0];
    return SEASON_CYCLE[(ref.seasonIndex || 0) % SEASON_CYCLE.length];
}

function advanceSeason(targetState = null, options = {}) {
    const timeRef = targetState ? targetState.worldTime : worldTime;
    if (!timeRef) return;
    timeRef.seasonIndex = ((timeRef.seasonIndex || 0) + 1) % SEASON_CYCLE.length;
    if (timeRef.seasonIndex === 0) timeRef.year = (timeRef.year || 1325) + 1;
    applySeasonalMorale(timeRef, targetState);
    
    // Sistema di popolazione dinamica
    if (!targetState) {
        processDemographicEvents();
        processCrimeAndStability();
        processEmigration();
        processSocialMobility();
        updateCategoryWealth();
        
        // Aggiorna domanda/offerta mercato
        const marketDynamics = calculateMarketDemand();
        // Qui possiamo usare marketDynamics per influenzare i prezzi
    }
    
    if (!targetState && !options.silent) {
        const season = getSeason(timeRef);
        addMsg("system", `⏳ Inizia ${season.label}. ${season.description}`);
        updateSeasonUI();
    }
}

function applySeasonalMorale(timeRef, targetState = null) {
    const season = getSeason(timeRef);
    if (!season.morale) return;
    const factionsRef = targetState ? targetState.factions : factions;
    Object.entries(season.morale).forEach(([key, delta]) => {
        factionsRef[key] = clamp((factionsRef[key] || 50) + delta);
    });
}

function updateSeasonUI() {
    const season = getSeason();
    const yearEl = document.getElementById("season-year");
    const nameEl = document.getElementById("season-name");
    const textEl = document.getElementById("season-effects-text");
    if (yearEl) yearEl.innerText = worldTime.year;
    if (nameEl) nameEl.innerText = season.label;
    if (textEl) textEl.innerText = season.description;
}

function getLawLibrary() {
    return [...BASE_LAW_LIBRARY, ...customLaws];
}

function getActiveLawKeys(targetState = null) {
    if (targetState && Array.isArray(targetState.activeLaws)) return targetState.activeLaws;
    return activeLaws;
}

function isLawActive(key, targetState = null) {
    return getActiveLawKeys(targetState).includes(key);
}

function getLawDefinition(key) {
    return getLawLibrary().find(l => l.key === key);
}

function toggleLaw(key) {
    const idx = activeLaws.indexOf(key);
    if (idx >= 0) {
        activeLaws.splice(idx, 1);
        const def = getLawDefinition(key);
        if (def) applyLawFactionShift(def, -1);
    } else {
        activeLaws.push(key);
        const def = getLawDefinition(key);
        if (def) applyLawFactionShift(def, 1);
    }
    renderLawList();
    updateUI();
}

function applyLawFactionShift(law, direction = 1, targetState = null) {
    if (!law.effects || !law.effects.factions) return;
    const factionsRef = targetState ? targetState.factions : factions;
    Object.entries(law.effects.factions).forEach(([key, delta]) => {
        factionsRef[key] = clamp((factionsRef[key] || 50) + delta * direction);
    });
}

function renderLawList() {
    const list = document.getElementById("law-list");
    if (!list) return;
    list.innerHTML = "";
    const library = getLawLibrary();
    library.forEach(law => {
        const card = document.createElement("div");
        card.className = "law-card";
        const title = document.createElement("h4");
        title.innerText = law.name;
        const desc = document.createElement("p");
        desc.innerText = law.description;
        const active = activeLaws.includes(law.key);
        const btn = document.createElement("button");
        btn.className = active ? "btn-main" : "btn-sec";
        btn.innerText = active ? "Abroga" : "Promulga";
        btn.addEventListener("click", () => toggleLaw(law.key));
        card.append(title, desc, btn);
        list.appendChild(card);
    });
    if (!library.length) {
        list.innerHTML = '<div class="law-card">Nessuna legge disponibile.</div>';
    }
}

function ownedStructures(list = [], owner = "count") {
    if (!Array.isArray(list)) return [];
    return list.filter(item => (item.owner || "count") === owner);
}

function summarizeIndustry(structuresRef = structures, settlementsRef = settlements, stateRef = null) {
    const landRef = stateRef ? stateRef.landOwnership : landOwnership;
    const popRef = stateRef ? stateRef.populationGroups : populationGroups;
    
    // Gestisce sia la struttura con .count che valori diretti
    const getPop = (group) => {
        if (!popRef[group]) return 0;
        return popRef[group].count !== undefined ? popRef[group].count : (popRef[group] || 0);
    };
    
    const summary = {
        housing: {
            poor: Math.max(1, Math.floor(((getPop('peasants') + getPop('outcasts')) / 80))),
            middle: Math.max(1, Math.floor(((getPop('burghers') + getPop('merchants')) / 120))),
            noble: Math.max(1, Math.floor((getPop('nobility') / 60)))
        },
        shops: Math.max(1, Math.floor(((getPop('burghers') + getPop('merchants')) / 90))),
        churches: Math.max(1, Math.floor(((getPop('clergy') + getPop('mystics')) / 30))),
        farms: Math.max(3, Math.floor(((landRef.count || 0) / 4))),
        ranches: Math.max(2, Math.floor(((landRef.count || 0) / 7))),
        mines: ownedStructures(structuresRef?.mines).length,
        sawmills: ownedStructures(structuresRef?.sawmills).length,
        quarries: ownedStructures(structuresRef?.quarries).length,
        monasteries: ownedStructures(structuresRef?.monasteries).length,
        settlements: (settlementsRef || []).length
    };
    return summary;
}

function updateIndustrySummary(targetState = null) {
    if (targetState) {
        targetState.industrySummary = summarizeIndustry(targetState.structures, targetState.settlements, targetState);
        if (targetState._cachedAssetFlows) delete targetState._cachedAssetFlows;
        return targetState.industrySummary;
    }
    industrySummary = summarizeIndustry();
    latestAssetFlows = null;
    return industrySummary;
}

function getIndustrySummary(targetState = null) {
    if (targetState) {
        if (!targetState.industrySummary) return updateIndustrySummary(targetState);
        return targetState.industrySummary;
    }
    if (!industrySummary) return updateIndustrySummary();
    return industrySummary;
}

function calculateAssetFlows(summary, stateRef = null) {
    const flows = { production:{}, consumption:{}, goldCost:0, detail:[] };
    if (!summary) return flows;
    ASSET_RULES.forEach(rule => {
        const count = Math.max(0, Math.round(rule.getCount(summary)));
        if (!count) return;
        const entry = { key:rule.key, label:rule.label, count, production:{}, consumption:{}, gold:0 };
        if (rule.produce) {
            Object.entries(rule.produce).forEach(([res, value]) => {
                const amount = Math.max(0, Math.round(value * count));
                if (!amount) return;
                entry.production[res] = amount;
                flows.production[res] = (flows.production[res] || 0) + amount;
            });
        }
        if (rule.consume) {
            Object.entries(rule.consume).forEach(([res, value]) => {
                const amount = Math.max(0, Math.round(value * count));
                if (!amount) return;
                entry.consumption[res] = amount;
                flows.consumption[res] = (flows.consumption[res] || 0) + amount;
            });
        }
        if (rule.gold) {
            entry.gold = Math.max(0, Math.round(rule.gold * count));
            flows.goldCost += entry.gold;
        }
        flows.detail.push(entry);
    });
    if (stateRef) {
        stateRef._cachedAssetFlows = flows;
    } else {
        latestAssetFlows = flows;
    }
    return flows;
}

function getCachedAssetFlows(stateRef = null) {
    if (stateRef && stateRef._cachedAssetFlows) return stateRef._cachedAssetFlows;
    return latestAssetFlows;
}

function formatFlowMap(map) {
    const entries = Object.entries(map || {}).filter(([, val]) => val && val !== 0);
    if (!entries.length) return "—";
    return entries.map(([key, val]) => `${resourceLabels[key] || key}:${val > 0 ? '+' : ''}${val}`).join(", ");
}

function summarizeStructureOutput(list = []) {
    const totals = {};
    list.forEach(item => {
        Object.entries(item.production || {}).forEach(([key, value]) => {
            const actual = Math.max(0, Math.floor(value * (item.condition || 100) / 100));
            totals[key] = (totals[key] || 0) + actual;
        });
    });
    return totals;
}

function updateAssetSummaryUI(summaryRef = null) {
    const container = document.getElementById("asset-summary");
    if (!container) return;
    
    // 1. Eseguiamo il calcolo per avere i dati aggiornati di staff ed efficienza
    calculateLaborAndEducation();

    container.innerHTML = "";
    
    // 2. Creiamo una lista UNIFICATA di tutti i luoghi di lavoro
    let allWorkplaces = [];

    // A. Aggiungi Edifici Costruiti (che hanno già un ID)
    const activeBuildings = buildings.filter(b => b.stage === 'complete');
    allWorkplaces = allWorkplaces.concat(activeBuildings);

    // B. Aggiungi Strutture Mappa (Assegnando ID se mancano e normalizzando il TIPO)
    // Nota: Mappiamo i tipi "generici" della mappa ai tipi specifici di buildingData
    const mapStructures = [
        { list: structures.mines, type: 'iron_mine' }, 
        { list: structures.sawmills, type: 'sawmill' },
        { list: structures.quarries, type: 'stone_quarry' },
        { list: structures.monasteries, type: 'monastery' } // Assicurati che 'monastery' esista in buildingData o usa 'church'
    ];

    mapStructures.forEach(group => {
        if(group.list) {
            group.list.forEach((s, index) => {
                // Se la struttura non ha ID, gliene diamo uno stabile basato sulle coordinate
                if (!s.id) s.id = `struct_${group.type}_${s.x}_${s.y}`;
                
                // Creiamo un oggetto riferimento che usa il tipo corretto per buildingData
                // IMPORTANTE: Modifichiamo l'oggetto originale per mantenere i dati sincronizzati
                s.realType = group.type; // Salviamo il tipo compatibile
                allWorkplaces.push(s);
            });
        }
    });

    if (allWorkplaces.length === 0) {
        container.innerHTML = '<div class="asset-card">Nessuna attività produttiva operativa.</div>';
        return;
    }

    // --- NOVITÀ: RAGGRUPPAMENTO ---
    const groups = {};

    allWorkplaces.forEach(b => {
        const typeKey = b.realType || b.type;
        const data = buildingData[typeKey];
        if (!data) return; // Skip se dati mancanti

        // Inizializza gruppo se non esiste
        if (!groups[typeKey]) {
            groups[typeKey] = {
                name: data.name,
                count: 0,
                totalStaff: 0,
                totalReq: 0,
                avgEff: 0,
                ids: [], // Teniamo traccia degli ID per azioni di gruppo
                staffType: data.staff ? data.staff.type : 'none',
                produceIcon: ""
            };

            // Determina icona produzione
            if(data.productionOutput) {
                const resKey = Object.keys(data.productionOutput)[0];
                groups[typeKey].produceIcon = `➡️ ${resourceLabels[resKey] || resKey}`;
            } else if (typeKey === 'iron_mine') groups[typeKey].produceIcon = "➡️ Ferro";
            else if (typeKey === 'sawmill') groups[typeKey].produceIcon = "➡️ Legno";
            else if (typeKey === 'stone_quarry') groups[typeKey].produceIcon = "➡️ Pietra";
        }

        // Aggregazione dati
        groups[typeKey].count++;
        groups[typeKey].totalStaff += (b.currentStaff || 0);
        // Se priorità è low, requiredStaff potrebbe essere 0 nella logica di calcolo, 
        // ma per la UI vogliamo mostrare quanto servirebbe.
        const baseReq = data.staff ? data.staff.amount : 0;
        groups[typeKey].totalReq += baseReq;
        groups[typeKey].avgEff += (b.currentEfficiency || 0);
        groups[typeKey].ids.push(b.id);
    });

    // 3. Generazione Card Raggruppate
    Object.keys(groups).sort().forEach(typeKey => {
        const g = groups[typeKey];
        
        // Se non serve staff, magari non lo mostriamo qui o lo mostriamo semplificato
        if (g.totalReq === 0 && g.staffType !== 'none') return;

        // Calcola media efficienza percentuale
        const avgEffPct = g.count > 0 ? Math.floor((g.avgEff / g.count) * 100) : 0;
        
        // Colore barra efficienza
        let effColor = avgEffPct < 50 ? '#f44336' : (avgEffPct < 100 ? '#ffeb3b' : '#6ada91');

        const card = document.createElement("div");
        card.className = "asset-card";
        // Stile leggermente diverso per far capire che è un gruppo
        card.style.borderLeft = "4px solid var(--accent)"; 
        
        card.innerHTML = `
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                <div style="font-weight:bold; color:var(--accent); font-size:1.05em;">
                    ${g.name} <span style="color:#fff; background:#333; padding:1px 6px; border-radius:4px; font-size:0.8em;">x${g.count}</span>
                </div>
                <div style="font-size:0.8em; color:#ccc;">${g.produceIcon}</div>
            </div>
            
            <div style="font-size:0.9em; margin-bottom:6px; display:flex; justify-content:space-between;">
                <span>👷 <strong>Staff Totale:</strong> ${g.totalStaff} / ${g.totalReq}</span>
                <span style="color:#aaa; font-size:0.85em;">(${factionLabel(g.staffType)})</span>
            </div>
            
            <div style="background:#222; height:8px; border-radius:4px; margin-bottom:8px; overflow:hidden; border:1px solid #444;">
                <div style="background:${effColor}; width:${avgEffPct}%; height:100%;"></div>
            </div>
            <div style="text-align:right; font-size:0.8em; color:${effColor}; margin-bottom:8px;">Efficienza Media: ${avgEffPct}%</div>

            <div style="display:flex; gap:5px; border-top:1px solid #333; padding-top:8px;">
                <button class="btn-sec" style="flex:1; font-size:0.75em; padding:6px;" onclick="setGroupPriority('${typeKey}', 'high')">🔥 Tutti Alta</button>
                <button class="btn-sec" style="flex:1; font-size:0.75em; padding:6px;" onclick="setGroupPriority('${typeKey}', 'normal')">⚖️ Tutti Norm</button>
                <button class="btn-sec" style="flex:1; font-size:0.75em; padding:6px;" onclick="setGroupPriority('${typeKey}', 'low')">⛔ Tutti Fermi</button>
            </div>
        `;
        container.appendChild(card);
    });
}

// Funzione helper per cambiare priorità
function setBuildingPriority(id, level) {
    let target = null;

    // 1. Cerca negli edifici costruiti
    target = buildings.find(b => b.id === id);

    // 2. Se non trovato, cerca nelle strutture della mappa
    if (!target) {
        const allStructs = [
            ...structures.mines, 
            ...structures.sawmills, 
            ...structures.quarries, 
            ...structures.monasteries
        ];
        // Nota: Qui assumiamo che 'updateAssetSummaryUI' abbia già assegnato gli ID agli oggetti in memoria
        target = allStructs.find(s => s.id === id);
    }

    if (target) {
        target.priority = level;
        
        // Feedback visivo immediato
        addMsg("system", `⚙️ Priorità aggiornata a <strong>${level.toUpperCase()}</strong> per la struttura.`);
        
        // Ricalcola immediatamente il lavoro per vedere l'effetto sull'efficienza
        calculateLaborAndEducation();
        
        // Aggiorna l'interfaccia
        updateUI(); 
    } else {
        console.error("Struttura non trovata per ID:", id);
    }
}

function setGroupPriority(typeKey, level) {
    let count = 0;

    // 1. Aggiorna Edifici Costruiti
    buildings.forEach(b => {
        if (b.type === typeKey && b.stage === 'complete') {
            b.priority = level;
            count++;
        }
    });

    // 2. Aggiorna Strutture Mappa
    // Helper per cercare nelle liste di strutture
    const updateStructList = (list, targetRealType) => {
        if (!list) return;
        list.forEach(s => {
            // Controlla se l'oggetto ha il realType assegnato o se stiamo mappando manualmente
            // (La funzione updateAssetSummaryUI assegna realType, ma qui potremmo operare sui dati grezzi)
            // Usiamo la logica inversa: se il tipo passato corrisponde alla lista
            if (targetRealType === typeKey) {
                s.priority = level;
                count++;
            }
        });
    };

    updateStructList(structures.mines, 'iron_mine');
    updateStructList(structures.sawmills, 'sawmill');
    updateStructList(structures.quarries, 'stone_quarry');
    updateStructList(structures.monasteries, 'monastery');

    // Feedback
    const priorityLabel = level === 'high' ? "ALTA" : (level === 'low' ? "FERMO" : "NORMALE");
    addMsg("system", `⚙️ Priorità impostata su <strong>${priorityLabel}</strong> per tutte le strutture di tipo: <em>${buildingName(typeKey) || typeKey}</em>.`);

    // Ricalcola e aggiorna UI
    calculateLaborAndEducation();
    updateUI();
}

function calculateLogisticNeeds(stateRef = null) {
    const needs = [];
    const popRef = stateRef ? stateRef.populationGroups : populationGroups;
    
    // Gestisce sia la struttura con .count che valori diretti
    const militia = popRef && popRef.militia ? 
        (popRef.militia.count !== undefined ? popRef.militia.count : popRef.militia) : 0;
    
    if (militia > 0) {
        needs.push({ resource:"iron", amount: Math.ceil(militia * 0.08), tag:"military" });
        needs.push({ resource:"wood", amount: Math.ceil(militia * 0.04), tag:"military" });
        needs.push({ resource:"textiles", amount: Math.ceil(militia * 0.02), tag:"military" });
    }

    const buildingList = stateRef ? (stateRef.buildings || []) : buildings;
    if (Array.isArray(buildingList)) {
        const activeSites = buildingList.filter(b => b.stage === "building").length;
        if (activeSites > 0) {
            needs.push({ resource:"wood", amount: activeSites * 2, tag:"construction" });
            needs.push({ resource:"stone", amount: activeSites * 2, tag:"construction" });
            needs.push({ resource:"iron", amount: activeSites, tag:"construction" });
        }
    }

    return needs;
}

function delayConstructionProjects(targetState = null, extraTurns = 1) {
    const list = targetState ? (targetState.buildings || []) : buildings;
    if (!Array.isArray(list) || !extraTurns) return;
    list.forEach(site => {
        if (site.stage === "building") site.turns_left += extraTurns;
    });
}

function applyLogisticConsequences(needs, deficits, stateRef = null) {
    const impact = { military:false, construction:false };
    if (!needs || !needs.length) return impact;
    const tags = new Set();
    needs.forEach(entry => {
        if (deficits[entry.resource]) tags.add(entry.tag);
    });

    const factionsRef = stateRef ? stateRef.factions : factions;
    const countyRef = stateRef ? stateRef.county : county;

    if (tags.has("military")) {
        impact.military = true;
        factionsRef.militia = clamp((factionsRef.militia || 50) - 4);
        factionsRef.nobility = clamp((factionsRef.nobility || 50) - 1);
        countyRef.health = clamp(countyRef.health - 1);
    }

    if (tags.has("construction")) {
        impact.construction = true;
        delayConstructionProjects(stateRef, 1);
    }

    return impact;
}

const DEFICIT_FACTION_MAP = {
    grain: ["peasants"],
    livestock: ["peasants"],
    wood: ["burghers", "peasants"],
    stone: ["burghers"],
    iron: ["militia", "burghers"],
    copper: ["militia", "burghers"],
    textiles: ["burghers"],
    luxuries: ["nobility", "merchants"],
    herbs: ["clergy", "mystics"],
    arcane: ["mystics", "clergy"],
    gold: ["merchants", "nobility"]
};

function buildFactionDeficitMessage(factionKey, resourceKey, amount) {
    const label = resourceLabels[resourceKey] || resourceKey;
    switch(factionKey) {
        case "peasants":
            return `I villaggi non vedono abbastanza ${label}. Senza scorte rischiamo rivolte nei campi.`;
        case "burghers":
            return `Le botteghe restano inattive: servono ${label} per lavorare e pagare le tasse.`;
        case "militia":
            return `Gli arsenali sono vuoti di ${label}; come possiamo difendere la contea?`;
        case "merchants":
            return `I mercati perdono credito senza ${label}. Dobbiamo riaprire i traffici.`;
        case "nobility":
            return `Le casate considerano offensivo il deficit di ${label}. Pretendono attenzione immediata.`;
        case "clergy":
            return `I riti richiedono ${label}; il popolo ha bisogno della nostra guida spirituale.`;
        case "mystics":
            return `Le nostre arti languono senza ${label}. Il regno perderà protezione arcana.`;
        default:
            return `${factionLabel(factionKey)} avverte la mancanza di ${label}.`;
    }
}

function triggerFactionInterjections(context = {}) {
    const messages = [];
    const deficits = context.economy?.deficits || {};
    Object.entries(deficits).forEach(([resourceKey, amount]) => {
        const factionTargets = DEFICIT_FACTION_MAP[resourceKey];
        if (!factionTargets) return;
        factionTargets.forEach(key => {
            const text = buildFactionDeficitMessage(key, resourceKey, amount);
            if (text) messages.push({ key, text, priority: 3 });
        });
    });

    if (context.economy?.logisticImpact?.military) {
        messages.push({
            key: "militia",
            text: "Senza ferrivecchi e razioni la guardia non può reggere un assedio.",
            priority: 4
        });
    }
    if (context.economy?.logisticImpact?.construction) {
        messages.push({
            key: "burghers",
            text: "I cantieri languono: spedite legname e pietra o le maestranze sciopereranno.",
            priority: 3
        });
    }

    if (context.maxAggression !== undefined && context.maxAggression >= 80) {
        messages.push({
            key: "militia",
            text: "Le frontiere ribollono di stendardi stranieri. Occorre prepararci ora, non quando sarà tardi.",
            priority: 2
        });
    }

    factionOrder.forEach(key => {
        const mood = factions[key] || 50;
        if (mood <= 28 && Math.random() < 0.5) {
            messages.push({ key, text: getFactionChatLine(key, mood), priority: 1 });
        } else if (mood >= 75 && Math.random() < 0.25 && !messages.length) {
            messages.push({ key, text: getFactionChatLine(key, mood), priority: 0 });
        }
    });

    if (!messages.length) return;

    messages.sort((a, b) => (b.priority || 0) - (a.priority || 0));
    const used = new Set();
    const selected = [];
    messages.forEach(msg => {
        if (selected.length >= 3) return;
        if (used.has(msg.key)) return;
        selected.push(msg);
        used.add(msg.key);
    });

    selected.forEach(msg => {
        addMsg("ai", `<strong>${factionLabel(msg.key)}</strong>: ${msg.text}`);
    });
}

// Mappa Emoji/Icone per Fazioni
const FACTION_ICONS = {
    nobility: "🦁", clergy: "✝️", peasants: "🌾", militia: "⚔️",
    burghers: "🔨", merchants: "⚖️", mystics: "🔮", outcasts: "🐀"
};

const COURT_RELATIONSHIPS = {
    nobility: { friends: ['clergy'], enemies: ['peasants', 'burghers'] },
    clergy: { friends: ['nobility', 'mystics'], enemies: ['merchants', 'outcasts'] },
    militia: { friends: ['nobility'], enemies: ['outcasts', 'peasants'] },
    peasants: { friends: ['outcasts'], enemies: ['nobility', 'militia'] },
    burghers: { friends: ['merchants'], enemies: ['nobility'] },
    merchants: { friends: ['burghers'], enemies: ['clergy'] },
    mystics: { friends: ['clergy'], enemies: ['burghers'] },
    outcasts: { friends: ['peasants'], enemies: ['militia'] }
};

function triggerCourtEvent(context) {
    const deficits = context.deficits || {};
    // ... (Logica selezione attori esistente rimane uguale) ...
    
    // Esempio di selezione (copia dal tuo codice o usa logica semplificata)
    let mainActor = 'peasants'; // Fallback
    let antagonist = 'nobility'; // Fallback
    let topic = "la fame";

    // ... (Tua logica di selezione attore/antagonista) ...

    // Prompt Migliorato per Realismo
    const actorName = getChatName(mainActor).split(" ")[0]; // Solo nome (es. Odric)
    const antagName = getChatName(antagonist).split(" ")[0]; // Solo nome (es. Lord Emeric)
    const actorTitle = factionLabel(mainActor);
    const antagTitle = factionLabel(antagonist);

    // Definisci la tensione della scena basata sui dati reali
    const tensionLevel = factions[mainActor] < 40 || factions[antagonist] < 40 ? "ALTA TENSIONE" : "DIBATTITO CIVILE";

    const prompt = `
    Sei il Regista della Sala del Trono.
    
    ATTORI:
    1. ${actorName} (${actorTitle}) - Lealtà verso il Conte: ${factions[mainActor]}/100.
    2. ${antagName} (${antagTitle}) - Lealtà verso il Conte: ${factions[antagonist]}/100.
    
    RELAZIONE TRA FAZIONI: ${COURT_RELATIONSHIPS[mainActor]?.enemies.includes(antagonist) ? 'NEMICI NATURALI' : 'NEUTRALI/ALLEATI'}.
    
    SITUAZIONE: ${tensionLevel}. Si discute di: "${topic}".
    
    COMPITO:
    Scrivi UNA breve scena (max 4 righe totali) di dialogo diretto.
    - Se sono NEMICI o la lealtà è bassa: Devono esserci frecciate, accuse o sarcasmo.
    - Se sono ALLEATI: Devono concordare o cercare una soluzione comune.
    - Il Conte è presente ma ascolta in silenzio.
    
    FORMATO (Usa ESATTAMENTE questo):
    SCENA: [Una frase descrittiva dell'atmosfera, es. "Odric si fa avanti stringendo il cappello tra le mani..."]
    ${actorName}: "[Battuta coerente con la sua classe sociale]"
    ${antagName}: "[Risposta coerente con la sua classe sociale]"
    
    Non aggiungere saluti formali inutili. Vai dritto al conflitto/problema.
    `;

    callGroq(prompt, "debate");
}







function togglePanel(id) {
    const panel = document.getElementById(id);
    if (!panel) return;
    panel.classList.toggle("collapsed");
}

function refreshLawTargetOptions() {
    const typeSelect = document.getElementById("law-custom-type");
    const targetSelect = document.getElementById("law-custom-target");
    if (!typeSelect || !targetSelect) return;
    const type = typeSelect.value;
    const options = [];
    if (type === "production") {
        RESOURCE_KEYS.forEach(key => options.push({ value: key, label: resourceLabels[key] || key }));
    } else if (type === "taxes") {
        TAX_CATEGORIES.forEach(cat => options.push({ value: cat.key, label: cat.label }));
    } else {
        factionOrder.forEach(key => options.push({ value: key, label: factionLabel(key) }));
    }
    targetSelect.innerHTML = options.map(opt => `<option value="${opt.value}">${opt.label}</option>`).join("");
}

function setupLawCreator() {
    const typeSelect = document.getElementById("law-custom-type");
    if (!typeSelect) return;
    typeSelect.addEventListener("change", refreshLawTargetOptions);
    refreshLawTargetOptions();
}

function createCustomLaw() {
    const nameInput = document.getElementById("law-custom-name");
    const descInput = document.getElementById("law-custom-desc");
    const typeSelect = document.getElementById("law-custom-type");
    const targetSelect = document.getElementById("law-custom-target");
    const valueInput = document.getElementById("law-custom-value");
    if (!nameInput || !descInput || !typeSelect || !targetSelect || !valueInput) return;

    const name = nameInput.value.trim();
    const desc = descInput.value.trim() || "Senza descrizione";
    const type = typeSelect.value;
    const target = targetSelect.value;
    const rawValue = parseFloat(valueInput.value);

    if (!name || !target || Number.isNaN(rawValue)) {
        addMsg("system", "⚠️ Compila nome, valore e scegli un bersaglio per la legge.");
        return;
    }

    const effects = {};
    if (type === "production") {
        const multiplier = 1 + rawValue / 100;
        if (!effects.production) effects.production = {};
        effects.production[target] = multiplier;
    } else if (type === "taxes") {
        if (!effects.taxes) effects.taxes = {};
        effects.taxes[target] = rawValue;
    } else if (type === "factions") {
        if (!effects.factions) effects.factions = {};
        effects.factions[target] = rawValue;
    }

    const key = slugify(`${name}_${Date.now()}`);
    customLaws.push({ key: `custom_${key}`, name, description: desc, effects, custom:true });
    renderLawList();
    nameInput.value = "";
    descInput.value = "";
    valueInput.value = "";
}

function getFactionProductionMultiplier(resourceKey, targetState = null) {
    const map = RESOURCE_FACTION_MAP[resourceKey];
    if (!map) return 1;
    const factionsRef = targetState ? targetState.factions : factions;
    const mood = (factionsRef[map.faction] || 50) - 50;
    return Math.max(0.5, 1 + (mood / 100) * map.scale);
}

function getProductionMultiplier(resourceKey, targetState = null) {
    const season = getSeason(targetState ? targetState.worldTime : worldTime);
    let mult = 1;
    if (season.production && season.production[resourceKey]) {
        mult *= season.production[resourceKey];
    }
    getActiveLawKeys(targetState).forEach(key => {
        const law = getLawDefinition(key);
        if (law && law.effects && law.effects.production && law.effects.production[resourceKey]) {
            mult *= law.effects.production[resourceKey];
        }
    });
    mult *= getFactionProductionMultiplier(resourceKey, targetState);
    return mult;
}

function renderTaxGrid(force = false) {
    const grid = document.getElementById("tax-grid");
    if (!grid) return;
    if (force) {
        delete grid.dataset.rendered;
    }
    if (grid.dataset.rendered === "1") {
        syncTaxGridValues();
        return;
    }
    grid.innerHTML = "";
    TAX_CATEGORIES.forEach(cat => {
        const card = document.createElement("div");
        card.className = "tax-card";
        const label = document.createElement("label");
        label.innerHTML = `<span>${cat.label}</span><span id="tax-rate-${cat.key}">${taxPolicy[cat.key]}%</span>`;
        const input = document.createElement("input");
        input.type = "range";
        input.id = `tax-slider-${cat.key}`;
        input.min = 0;
        input.max = 30;
        input.step = 1;
        input.value = taxPolicy[cat.key];
        input.addEventListener("input", (ev) => setTaxRate(cat.key, Number(ev.target.value)));
        card.append(label, input);
        grid.appendChild(card);
    });
    grid.dataset.rendered = "1";
    updateTaxSummary();
}

function syncTaxGridValues() {
    TAX_CATEGORIES.forEach(cat => {
        const slider = document.getElementById(`tax-slider-${cat.key}`);
        if (slider) slider.value = taxPolicy[cat.key];
        const label = document.getElementById(`tax-rate-${cat.key}`);
        if (label) label.innerText = `${taxPolicy[cat.key]}%`;
    });
    updateTaxSummary();
}

function setTaxRate(key, value) {
    taxPolicy[key] = Number(value);
    const label = document.getElementById(`tax-rate-${key}`);
    if (label) label.innerText = `${value}%`;
    updateTaxSummary();
}

function getLawTaxModifier(categoryKey, targetState = null) {
    let delta = 0;
    getActiveLawKeys(targetState).forEach(key => {
        const law = getLawDefinition(key);
        if (law && law.effects && law.effects.taxes && law.effects.taxes[categoryKey]) {
            delta += law.effects.taxes[categoryKey];
        }
    });
    return delta;
}

function ensureTaxPolicy(targetState) {
    if (targetState) {
        if (!targetState.taxPolicy) targetState.taxPolicy = createDefaultTaxPolicy();
        return targetState.taxPolicy;
    }
    return taxPolicy;
}

function collectTaxes(targetState = null, options = {}) {
    const statePop = targetState ? targetState.populationGroups : populationGroups;
    const stateCounty = targetState ? targetState.county : county;
    const stateFactions = targetState ? targetState.factions : factions;
    const policy = ensureTaxPolicy(targetState);
    let total = 0;
    TAX_CATEGORIES.forEach(cat => {
    const pop = statePop[cat.key]?.count || 0;  // ✅ Prende il numero di persone
    const baseWealth = pop * cat.wealthFactor;  // ✅ Ora funziona!
        const lawDelta = getLawTaxModifier(cat.key, targetState);
        const effectivePercent = Math.max(0, (policy[cat.key] || 0) + lawDelta);
        const income = Math.floor(baseWealth * (effectivePercent / 100));
        total += income;
        const tolerance = cat.tolerance;
        if (effectivePercent > tolerance) {
            const penalty = Math.round((effectivePercent - tolerance) / 2);
            stateFactions[cat.key] = clamp((stateFactions[cat.key] || 50) - penalty);
        } else if (effectivePercent < tolerance - 3) {
            stateFactions[cat.key] = clamp((stateFactions[cat.key] || 50) + 1);
        }
    });
    total = Math.max(0, total);
    stateCounty.gold += total;
    if (!targetState) {
        recordTaxHistory(total);
        if (!options.silent) addMsg("system", `💰 Entrate fiscali: ${total} oro.`);
        updateTaxSummary();
    }
    return total;
}

function recordTaxHistory(amount) {
    taxHistory.push(amount);
    if (taxHistory.length > 8) taxHistory.shift();
}

function updateTaxSummary() {
    const lastEl = document.getElementById("tax-last");
    const trendEl = document.getElementById("tax-trend");
    const last = taxHistory[taxHistory.length - 1] || 0;
    const prev = taxHistory[taxHistory.length - 2] || last;
    if (lastEl) lastEl.innerText = last;
    if (trendEl) {
        if (taxHistory.length < 2 || last === prev) trendEl.innerText = "stabile";
        else trendEl.innerText = last > prev ? `↑ +${last - prev}` : `↓ ${last - prev}`;
    }
}

function applySeasonalUpkeep(targetState = null, options = {}) {
    const timeRef = targetState ? targetState.worldTime : worldTime;
    const season = getSeason(timeRef);
    const stateCounty = targetState ? targetState.county : county;
    const popRef = targetState ? targetState.populationGroups : populationGroups;
    const militia = popRef.militia || 0;
    const upkeep = Math.floor(militia * 0.2 * season.warCost);
    if (!upkeep) return;
    stateCounty.gold = Math.max(0, stateCounty.gold - upkeep);
    if (!targetState && !options.silent) {
        addMsg("system", `🛡️ Costi stagionali delle truppe: -${upkeep} oro.`);
    }
}

function factionLabel(key) {
    return key.charAt(0).toUpperCase() + key.slice(1);
}

function getFactionEffectText(key, value) {
    const ref = FACTION_EFFECT_DESCRIPTIONS[key] || {};
    if (value >= 65) return ref.bonus || "Sono soddisfatti.";
    if (value <= 35) return ref.malus || "Sono inquieti.";
    return "Equilibrati.";
}

function getFactionChatLine(key, mood) {
    const ref = FACTION_EFFECT_DESCRIPTIONS[key] || {};
    if (mood >= 70) return ref.bonus || "Vi onoriamo, Conte.";
    if (mood <= 30) return ref.malus || "La nostra pazienza è agli sgoccioli.";
    return "Attendiamo che le promesse diventino fatti.";
}

function handleFactionChipClick(key) {
    ensureWorldSystems();
    const mood = factions[key] || 50;
    const line = getFactionChatLine(key, mood);
    addMsg("ai", `<strong>${factionLabel(key)}</strong>: ${line}`);
}

function renderFactionChips() {
    const container = document.getElementById("chat-faction-chips");
    if (!container) return;
    container.innerHTML = "";
    factionOrder.forEach(key => {
        const btn = document.createElement("button");
        btn.className = "faction-chip";
        const mood = factions[key] || 50;
        if (mood <= 35) btn.classList.add("low");
        else if (mood >= 65) btn.classList.add("high");
        btn.innerText = factionLabel(key);
        btn.title = `Lealtà: ${mood}`;
        btn.addEventListener("click", () => handleFactionChipClick(key));
        container.appendChild(btn);
    });
}

function updateFactionImpactUI(targetState = null) {
    const container = document.getElementById("faction-impact-list");
    if (!container) return;
    container.innerHTML = "";
    const factionsRef = targetState ? targetState.factions : factions;
    factionOrder.forEach(key => {
        const val = factionsRef[key] || 50;
        const card = document.createElement("div");
        card.className = "faction-effect-card";
        card.innerHTML = `<strong>${factionLabel(key)}</strong><div>Loyalty: ${val}</div><div>${getFactionEffectText(key, val)}</div>`;
        container.appendChild(card);
    });
}

/* ============================================================
   ============ MENU INIZIALE, SALVATAGGI E IMPOSTAZIONI ======
   ============================================================ */

function initStartScreen() {
    ensureWorldSystems();
    loadStoredApiKey();
    loadPersonalitySettings();
    renderSaveCollection("save-list", { closeOnLoad:true });
    updateSaveStatusFromStorage();
    activateScreen("screen-start");
}

function activateScreen(id) {
    document.querySelectorAll(".screen").forEach(s => s.classList.remove("active"));
    const target = document.getElementById(id);
    if (target) target.classList.add("active");
    if (id !== "screen-start") closeLoadModal();
}

function goToEditorScreen() {
    activateScreen("screen-editor");
    syncEditorDefaults();
}

function openLoginScreen() {
    syncApiKeyInputs(apiKey || safeStorageGet("conte_api_key") || "");
    activateScreen("screen-login");
}

function syncEditorDefaults() {
    const advSelect = document.getElementById("adv-pers");
    if (advSelect && personalitySettings && personalitySettings.advisorTone) {
        advSelect.value = personalitySettings.advisorTone;
    }
}

function saveApiKeyFromStart() {
    const startInput = document.getElementById("api-key-start");
    const key = startInput ? startInput.value.trim() : "";
    if (!key) {
        updateApiKeyStatus("Inserisci una chiave valida.", false);
        return;
    }
    setApiKey(key);
    updateApiKeyStatus("Chiave salvata in locale.");
}

function clearStoredApiKey() {
    apiKey = "";
    safeStorageRemove("conte_api_key");
    syncApiKeyInputs("");
    updateApiKeyStatus("Chiave rimossa.");
}

function setApiKey(key) {
    apiKey = key ? key.trim() : "";
    if (apiKey) safeStorageSet("conte_api_key", apiKey);
    syncApiKeyInputs(apiKey);
}

function ensureApiKey() {
    if (apiKey) return apiKey;
    const stored = safeStorageGet("conte_api_key");
    if (stored) {
        apiKey = stored;
        syncApiKeyInputs(apiKey);
        updateApiKeyStatus("Chiave caricata automaticamente.");
    }
    return apiKey;
}

function syncApiKeyInputs(value) {
    const loginInput = document.getElementById("api-key-input");
    const startInput = document.getElementById("api-key-start");
    if (loginInput) loginInput.value = value || "";
    if (startInput) startInput.value = value || "";
}

function updateApiKeyStatus(text, positive = true) {
    const status = document.getElementById("api-key-status");
    if (status) {
        status.innerText = text;
        status.style.color = positive ? "var(--text-soft)" : "#ff6b6b";
    }
}

function loadStoredApiKey() {
    const stored = safeStorageGet("conte_api_key");
    if (stored) {
        apiKey = stored;
        syncApiKeyInputs(apiKey);
        updateApiKeyStatus("Chiave ricordata.");
    }
}

function savePersonalitySettingsForm() {
    const toneInput = document.getElementById("personality-tone");
    const moodInput = document.getElementById("personality-mood");
    const notesInput = document.getElementById("personality-notes");
    personalitySettings = {
        advisorTone: (toneInput && toneInput.value) || DEFAULT_PERSONALITY.advisorTone,
        courtMood: (moodInput && moodInput.value) || DEFAULT_PERSONALITY.courtMood,
        notes: notesInput ? notesInput.value.trim() : ""
    };
    safeStorageSet("conte_personality_settings", JSON.stringify(personalitySettings));
}

function loadPersonalitySettings() {
    try {
        const raw = safeStorageGet("conte_personality_settings");
        if (raw) personalitySettings = JSON.parse(raw);
    } catch(e) {
        personalitySettings = { ...DEFAULT_PERSONALITY };
    }
    syncPersonalityForm(personalitySettings);
}

function syncPersonalityForm(settings) {
    const tone = document.getElementById("personality-tone");
    const mood = document.getElementById("personality-mood");
    const notes = document.getElementById("personality-notes");
    if (tone && settings && settings.advisorTone) tone.value = settings.advisorTone;
    if (mood && settings && settings.courtMood) mood.value = settings.courtMood;
    if (notes) notes.value = (settings && settings.notes) ? settings.notes : "";
}

function openLoadModal() {
    renderSaveCollection("modal-save-list", { showDelete:true });
    const modal = document.getElementById("load-modal");
    if (modal) modal.classList.add("active");
}

function closeLoadModal() {
    const modal = document.getElementById("load-modal");
    if (modal) modal.classList.remove("active");
}

function manualSaveFromModal() {
    const input = document.getElementById("save-slot-name");
    const name = input ? input.value.trim() : "";
    const slotKey = name ? slugify(name) : `manuale_${Date.now()}`;
    const label = name || "Salvataggio manuale";
    saveGame(slotKey, { label });
    if (input) input.value = "";
    renderSaveCollection("modal-save-list", { showDelete:true });
}

function quickSaveGame() {
    saveGame("quick", { label:"Salvataggio rapido", skipSlug:true });
}

function autoSaveGame() {
    saveGame("autosave", { label:"Autosave", silent:true, skipSlug:true });
}

function saveGame(slotKey = "manuale", options = {}) {
    const { label = slotKey, silent = false, skipSlug = false } = options;
    if (typeof localStorage === "undefined") return;

    let finalKey = slotKey || "slot";
    if (!skipSlug && !RESERVED_SAVE_SLOTS.includes(finalKey)) {
        finalKey = slugify(finalKey) || `slot_${Date.now()}`;
    }

    const payload = {
        meta: {
            slot: finalKey,
            label,
            timestamp: Date.now(),
            heroName,
            turn: county.turn
        },
        state: captureGameState()
    };

    safeStorageSet(`conte_save_${finalKey}`, JSON.stringify(payload));
    const statusText = `${label} – Turno ${county.turn}`;
    safeStorageSet("conte_last_save_label", statusText);
    updateSaveStatus(statusText);
    updateSaveCollections();

    if (!silent) {
        addMsg("system", `💾 Salvataggio completato (${label}).`);
    }
}

function loadGame(slotKey) {
    if (!slotKey) return;
    const raw = safeStorageGet(`conte_save_${slotKey}`);
    if (!raw) {
        addMsg("system", "❌ Salvataggio non trovato.");
        return;
    }

    try {
        const data = JSON.parse(raw);
        restoreGameState(data.state || data);
        updateUI();
        drawCountyMap();
        drawRegionMap();
        activateScreen("screen-game");
        refreshAllStats();
        triggerStartupNarrative(false);
        const loadedLabel = data.meta && data.meta.label ? data.meta.label : slotKey;
        addMsg("system", `📂 Caricata la partita ${loadedLabel} (Turno ${county.turn}).`);
        closeLoadModal();
        updateSaveCollections();
    } catch(e) {
        addMsg("system", "⚠️ Impossibile caricare il salvataggio.");
    }
}

function deleteSave(slotKey) {
    safeStorageRemove(`conte_save_${slotKey}`);
    updateSaveCollections();
}

function updateSaveCollections() {
    renderSaveCollection("save-list", { closeOnLoad:true });
    const loadModal = document.getElementById("load-modal");
    if (loadModal && loadModal.classList.contains("active")) {
        renderSaveCollection("modal-save-list", { showDelete:true });
    }
}

function renderSaveCollection(containerId, options = {}) {
    const container = document.getElementById(containerId);
    if (!container) return;
    const slots = getSaveSlots();

    if (!slots.length) {
        container.innerHTML = '<p class="save-empty">Nessun salvataggio disponibile.</p>';
        return;
    }

    container.innerHTML = "";
    slots.forEach(slot => {
        const row = document.createElement("div");
        row.className = "save-entry";

        const details = document.createElement("div");
        details.className = "save-entry-details";
        const title = document.createElement("strong");
        title.innerText = slot.meta.label || slot.slot;
        const subtitle = document.createElement("span");
        subtitle.innerText = `${slot.meta.heroName || "Conte"} — Turno ${slot.meta.turn || 1}`;
        const time = document.createElement("small");
        time.innerText = new Date(slot.meta.timestamp || Date.now()).toLocaleString("it-IT");
        details.append(title, subtitle, time);

        const actions = document.createElement("div");
        actions.className = "save-entry-actions";
        const loadBtn = document.createElement("button");
        loadBtn.className = "btn-sec";
        loadBtn.innerText = "Carica";
        loadBtn.addEventListener("click", () => loadGame(slot.slot));
        actions.appendChild(loadBtn);

        if (options.showDelete) {
            const delBtn = document.createElement("button");
            delBtn.className = "btn-sec";
            delBtn.innerText = "Elimina";
            delBtn.addEventListener("click", () => {
                if (confirm(`Eliminare ${slot.meta.label || slot.slot}?`)) {
                    deleteSave(slot.slot);
                    renderSaveCollection(containerId, options);
                }
            });
            actions.appendChild(delBtn);
        }

        row.append(details, actions);
        container.appendChild(row);
    });
}

function getSaveSlots() {
    if (typeof localStorage === "undefined") return [];
    const slots = [];
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (!key || !key.startsWith("conte_save_")) continue;
        try {
            const payload = JSON.parse(localStorage.getItem(key));
            slots.push({
                slot: key.replace("conte_save_", ""),
                meta: payload.meta || { timestamp: Date.now(), label: key }
            });
        } catch(e) {
            continue;
        }
    }
    return slots.sort((a,b) => (b.meta.timestamp || 0) - (a.meta.timestamp || 0));
}

function captureGameState() {
    ensureWorldSystems();
    const snapshot = JSON.parse(JSON.stringify({
        heroName,
        advisor,
        county,
        landOwnership,
        populationGroups,
        factions,
        neighboringCounties,
        structures,
        buildings,
        settlements,
        worldMap,
        privateChats,
        publicChatHistory,
        personalitySettings,
        worldTime,
        taxPolicy,
        taxHistory,
        activeLaws,
        lastResourceSnapshot,
        lastResourceDelta,
        industrySummary,
        customLaws,
        dynasty
    }));
    snapshot.county.resources = normalizeResourceBag(snapshot.county.resources);
    return snapshot;
}

function restoreGameState(state) {
    county = state.county ? JSON.parse(JSON.stringify(state.county)) : createDefaultCounty();
    const sourceResources = (state.county && state.county.resources) ? state.county.resources : {};
    county.resources = normalizeResourceBag(sourceResources);
    landOwnership = state.landOwnership ? JSON.parse(JSON.stringify(state.landOwnership)) : createDefaultLand();
    populationGroups = state.populationGroups ? JSON.parse(JSON.stringify(state.populationGroups)) : createDefaultPopulation();
    // Migra vecchi salvataggi alla nuova struttura
    populationGroups = migratePopulationGroups(populationGroups);
    factions = state.factions ? JSON.parse(JSON.stringify(state.factions)) : createDefaultFactions();
    neighboringCounties = state.neighboringCounties ? JSON.parse(JSON.stringify(state.neighboringCounties)) : createDefaultNeighbors();
    structures = state.structures ? JSON.parse(JSON.stringify(state.structures)) : createEmptyStructures();
    buildings = state.buildings ? JSON.parse(JSON.stringify(state.buildings)) : [];
    settlements = state.settlements ? JSON.parse(JSON.stringify(state.settlements)) : [];
    worldMap = state.worldMap ? JSON.parse(JSON.stringify(state.worldMap)) : worldMap;
    privateChats = state.privateChats ? JSON.parse(JSON.stringify(state.privateChats)) : createDefaultPrivateChats();
    personalitySettings = state.personalitySettings || personalitySettings;
    heroName = state.heroName || heroName;
    worldTime = state.worldTime ? JSON.parse(JSON.stringify(state.worldTime)) : createDefaultWorldTime();
    taxPolicy = state.taxPolicy ? JSON.parse(JSON.stringify(state.taxPolicy)) : createDefaultTaxPolicy();
    taxHistory = Array.isArray(state.taxHistory) ? [...state.taxHistory] : [];
    activeLaws = Array.isArray(state.activeLaws) ? [...state.activeLaws] : [];
    lastResourceSnapshot = state.lastResourceSnapshot ? JSON.parse(JSON.stringify(state.lastResourceSnapshot)) : captureResourceSnapshot();
    lastResourceDelta = state.lastResourceDelta ? JSON.parse(JSON.stringify(state.lastResourceDelta)) : createEmptyResourceDelta();
    industrySummary = state.industrySummary ? JSON.parse(JSON.stringify(state.industrySummary)) : null;
    customLaws = Array.isArray(state.customLaws) ? JSON.parse(JSON.stringify(state.customLaws)) : [];
    publicChatHistory = state.publicChatHistory || [];
    dynasty = state.dynasty ? JSON.parse(JSON.stringify(state.dynasty)) : dynasty;
    
    // Aggiorna UI dinastia al caricamento
    updateDynastyUI();
    
    ensureWorldSystems();
    recomputePopulation();
}

function normalizeResourceBag(source = {}) {
    const bag = {};
    RESOURCE_KEYS.forEach(key => bag[key] = Number(source[key] ?? 0));
    return bag;
}

function cloneResourceBag(source = {}) {
    return JSON.parse(JSON.stringify(normalizeResourceBag(source)));
}

function createEmptyResourceDelta() {
    const bag = {};
    RESOURCE_KEYS.forEach(key => bag[key] = 0);
    return bag;
}

function createEmptyResourceBag() {
    return createEmptyResourceDelta();
}

function migratePopulationGroups(groups) {
    const defaultGroups = createDefaultPopulation();
    
    // Se è già nella nuova struttura, restituisci come è
    if (groups.nobility && typeof groups.nobility === 'object' && 'count' in groups.nobility) {
        return groups;
    }
    
    // Altrimenti, migra dalla vecchia struttura
    const migrated = {};
    Object.keys(defaultGroups).forEach(key => {
        if (typeof groups[key] === 'number') {
            // Vecchio formato: nobility: 25
            migrated[key] = {
                count: groups[key],
                wealth: defaultGroups[key].wealth,
                resources: createEmptyResourceBag()
            };
        } else if (groups[key] && typeof groups[key] === 'object') {
            // Nuovo formato o parzialmente migrato
            migrated[key] = {
                count: groups[key].count || defaultGroups[key].count,
                wealth: groups[key].wealth || defaultGroups[key].wealth,
                resources: groups[key].resources || createEmptyResourceBag()
            };
        } else {
            // Usa default
            migrated[key] = defaultGroups[key];
        }
    });
    
    return migrated;
}

function captureResourceSnapshot(targetState = null) {
    if (targetState && targetState.county && targetState.county.resources) {
        return cloneResourceBag(targetState.county.resources);
    }
    if (county && county.resources) return cloneResourceBag(county.resources);
    return createEmptyResourceDelta();
}

function computeResourceDelta(startSnapshot, endSnapshot) {
    const delta = {};
    RESOURCE_KEYS.forEach(key => {
        const startVal = startSnapshot && startSnapshot[key] !== undefined ? startSnapshot[key] : 0;
        const endVal = endSnapshot && endSnapshot[key] !== undefined ? endSnapshot[key] : 0;
        delta[key] = endVal - startVal;
    });
    return delta;
}

function resetResourceTracking(targetState = null) {
    if (targetState) {
        targetState.lastResourceSnapshot = captureResourceSnapshot(targetState);
        targetState.lastResourceDelta = createEmptyResourceDelta();
        return;
    }
    lastResourceSnapshot = captureResourceSnapshot();
    lastResourceDelta = createEmptyResourceDelta();
}

function resetGameState() {
    county = createDefaultCounty();
    landOwnership = createDefaultLand();
    populationGroups = createDefaultPopulation();
    factions = createDefaultFactions();
    neighboringCounties = createDefaultNeighbors();
    structures = createEmptyStructures();
    buildings = [];
    settlements = [];
    worldMap.tiles = [];
    privateChats = createDefaultPrivateChats();
    publicChatHistory = []; // <--- AGGIUNTO
    lastNeedsReport = {}; // Reset memoria bisogni
    activePrivateChat = null;
    county.turn = 1;
    worldTime = createDefaultWorldTime();
    taxPolicy = createDefaultTaxPolicy();
    taxHistory = [];
    activeLaws = [];
    dynasty = {
        ruler: {
            name: "Conte", // Sarà sovrascritto da heroName
            age: 25,
            maxAge: 75 + Math.floor(Math.random() * 15), // Morte naturale tra 75 e 90
            health: 100,
            traits: ["Fondatore"],
            isDead: false
        },
        spouse: null, // Oggetto { name, age, origin, bonus }
        heirs: []     // Array di oggetti { name, age, gender, traits }
    };
    resetResourceTracking();
    ensureWorldSystems();
    clearInterfaceLogs();
}

function updateSaveStatus(text) {
    const el = document.getElementById("save-status");
    if (el) el.innerText = text || "Nessun salvataggio registrato.";
}

function updateSaveStatusFromStorage() {
    const stored = safeStorageGet("conte_last_save_label");
    if (stored) updateSaveStatus(stored);
}

function slugify(str) {
    return str.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/(^-|-$)/g, "");
}

function safeStorageGet(key) {
    try { return localStorage.getItem(key); } catch(e) { return null; }
}

function safeStorageSet(key, value) {
    try { localStorage.setItem(key, value); } catch(e) {}
}

function safeStorageRemove(key) {
    try { localStorage.removeItem(key); } catch(e) {}
}

/* ============================================================
   =================== GENERAZIONE MAPPA =======================
   ============================================================ */

let worldMap = {
    width: 20,
    height: 20,
    tiles: []
};

let settlements = [];

/* ---- FUNZIONE PRINCIPALE ---- */
function generateWorldMap() {
    worldMap.tiles = [];

    for (let y = 0; y < worldMap.height; y++) {
        for (let x = 0; x < worldMap.width; x++) {

            const terrain = randomTerrain();
            const fertility = baseFertility(terrain) + rand(-10,10);
            const resources = generateResources(terrain);
            const owner = assignOwner(x, y);

            worldMap.tiles.push({
                x, y,
                terrain,
                fertility: clamp(fertility),
                resources,
                owner
            });
        }
    }
}

function getTile(x, y) {
    if (x < 0 || y < 0 || x >= worldMap.width || y >= worldMap.height) return null;
    return worldMap.tiles[y * worldMap.width + x];
}

/* ---- TIPO DI TERRENO ---- */
function randomTerrain() {
    const r = Math.random();
    if (r < 0.30) return "plains";
    if (r < 0.50) return "forest";
    if (r < 0.70) return "hills";
    if (r < 0.82) return "mountain";
    if (r < 0.92) return "swamp";
    return "lake";
}

/* ---- FERTILITÀ BASE ---- */
function baseFertility(t) {
    switch(t){
        case "plains": return 70;
        case "forest": return 50;
        case "hills": return 40;
        case "mountain": return 20;
        case "swamp": return 25;
        case "lake": return 60;
    }
}

/* ---- GENERAZIONE RISORSE ---- */
function generateResources(terrain) {
    let r = {
        wood:0, stone:0, iron:0, copper:0, gold:0, herbs:0,
        gems:0, silver:0, mystic_crystals:0
    };

    if (terrain === "forest") r.wood = rand(50,100);
    if (terrain === "hills") { r.stone = rand(40,80); r.copper = rand(20,50); }
    if (terrain === "mountain") { r.iron = rand(40,100); }

    if (terrain === "swamp") r.herbs = rand(30,60);

    // RARI
    if (Math.random() < 0.03) r.gold = rand(10,30);
    if (Math.random() < 0.03) r.gems = rand(5,20);
    if (Math.random() < 0.03) r.silver = rand(10,30);
    if (Math.random() < 0.02) r.mystic_crystals = rand(5,15);

    return r;
}

/* ---- ASSEGNAZIONE TERRITORIO ---- */
function assignOwner(x, y) {
    if (x > 7 && x < 12 && y > 7 && y < 12) return "count";
    if (y < 4) return "auvrey";
    if (x > 13 && y > 13) return "falken";

    const r = Math.random();
    if (r < 0.33) return "nobility";
    if (r < 0.66) return "clergy";
    return "commons";
}

function generateSettlements() {
    settlements = worldMap.tiles
        .filter(t => t.owner === "count" && t.fertility > 50)
        .sort(() => 0.5 - Math.random())
        .slice(0, 10)
        .map(t => ({ x: t.x, y: t.y }));
}

function assignInitialStructures() {
    updateIndustrySummary();
}

/* ---- UTILS ---- */
function rand(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function clamp(v){ return Math.max(0, Math.min(100,v)); }

/* ============================================================
/* ============================================================
// Colori e stili medievali
const MAP_STYLES = {
    water: "#a3c6d4",
    waterDeep: "#8ab0c0",
    grass: "#d6e4aa",
    forest: "#8fb376",
    forestDark: "#6d9158",
    mountain: "#cfcfc4",
    mountainShadow: "#a0a0a0",
    swamp: "#8d9678",
    hills: "#e0d8a6",
    paper: "#f4ecd8",
    ink: "#3e2723"
};

function drawCountyMap() {
    const canvas = document.getElementById("county-map");
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    const tileSize = canvas.width / worldMap.width;

    // Sfondo base (Pergamena)
    ctx.fillStyle = MAP_STYLES.paper;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Disegna ogni casella (Tile)
    for (let y = 0; y < worldMap.height; y++) {
        for (let x = 0; x < worldMap.width; x++) {
            const tile = getTile(x, y);
            if (!tile) continue;
            drawTileVisuals(ctx, x * tileSize, y * tileSize, tileSize, tile);
        }
    }

    // Disegna bordi di proprietà terriera
    drawOwnershipBorders(ctx, tileSize);

    // Disegna griglia leggera (opzionale, per chiarezza)
    ctx.strokeStyle = "rgba(0,0,0,0.05)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let i = 0; i <= worldMap.width; i++) {
        ctx.moveTo(i * tileSize, 0); ctx.lineTo(i * tileSize, canvas.height);
        ctx.moveTo(0, i * tileSize); ctx.lineTo(canvas.width, i * tileSize);
    }
    ctx.stroke();

    // Disegna Insediamenti e Strutture
    drawSettlements(ctx, tileSize);
    drawStructureMarkers(ctx, tileSize);
    drawStructureLabels(ctx, tileSize);
    
    // Effetto vignettatura (ombra ai bordi)
    drawVignette(ctx, canvas.width, canvas.height);
}

function drawOwnershipBorders(ctx, size) {
    const ownershipColors = {
        count: "rgba(212, 175, 55, 0.8)",  // Oro
        nobility: "rgba(150, 50, 50, 0.8)", // Rosso scuro
        clergy: "rgba(100, 100, 200, 0.8)", // Blu
        commons: "rgba(100, 150, 100, 0.8)" // Verde
    };

    for (let y = 0; y < worldMap.height; y++) {
        for (let x = 0; x < worldMap.width; x++) {
            const tile = getTile(x, y);
            if (!tile || !tile.owner || tile.owner === 'wild') continue;

            const px = x * size;
            const py = y * size;

            // Controlla se i vicini hanno proprietari diversi
            const neighbors = [
                {dx: 0, dy: -1}, {dx: 1, dy: 0}, {dx: 0, dy: 1}, {dx: -1, dy: 0}
            ];

            neighbors.forEach(n => {
                const nx = x + n.dx;
                const ny = y + n.dy;
                const nTile = getTile(nx, ny);
                if (nTile && nTile.owner !== tile.owner) {
                    ctx.strokeStyle = ownershipColors[tile.owner] || "rgba(0,0,0,0.5)";
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    if (n.dx === 0 && n.dy === -1) { // Sopra
                        ctx.moveTo(px, py); ctx.lineTo(px + size, py);
                    } else if (n.dx === 1 && n.dy === 0) { // Destra
                        ctx.moveTo(px + size, py); ctx.lineTo(px + size, py + size);
                    } else if (n.dx === 0 && n.dy === 1) { // Sotto
                        ctx.moveTo(px, py + size); ctx.lineTo(px + size, py + size);
                    } else if (n.dx === -1 && n.dy === 0) { // Sinistra
                        ctx.moveTo(px, py); ctx.lineTo(px, py + size);
                    }
                    ctx.stroke();
                }
            });
        }
    }
}

function drawStructureLabels(ctx, size) {
    structures.mines.forEach(s => drawLabel(ctx, s, size, "Miniera", "#555"));
    structures.sawmills.forEach(s => drawLabel(ctx, s, size, "Segheria", "#4caf50"));
    structures.quarries.forEach(s => drawLabel(ctx, s, size, "Cava", "#795548"));
    structures.monasteries.forEach(s => drawLabel(ctx, s, size, "Monastero", "#9c27b0"));
    
    buildings.forEach(b => {
        if (b.stage === 'complete') {
            const label = buildingData[b.type]?.name || b.type;
            drawLabel(ctx, b, size, label, "#2196f3");
        }
    });
}

function drawLabel(ctx, s, size, label, color) {
    const x = s.x * size + size / 2;
    const y = s.y * size + size / 2 - 15; // Sopra l'icona

    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillRect(x - 20, y - 10, 40, 15);
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    ctx.strokeRect(x - 20, y - 10, 40, 15);

    ctx.fillStyle = "#fff";
    ctx.font = "8px Arial";
    ctx.textAlign = "center";
    ctx.fillText(label, x, y + 2);
}

// Commentata per duplicazione
// function drawRegionMap() {
//     const canvas = document.getElementById("region-map");
//     if (!canvas) return;
//     const ctx = canvas.getContext("2d");
//     const size = canvas.width / 8;

//     // Sfondo carta antica
//     ctx.fillStyle = "#e3d5b8"; 
//     ctx.fillRect(0, 0, canvas.width, canvas.height);

//     // Disegna territori
//     for (let y = 0; y < 8; y++) {
//         for (let x = 0; x < 8; x++) {
//             let owner = "wild";
//             // Logica semplice per proprietari (uguale a prima ma con colori nuovi)
//             if (y < 2) owner = "auvrey";
//             else if (x > 5 && y > 5) owner = "falken";
//             else if (rand(0,10) > 4) owner = "count";

//             const px = x * size;
//             const py = y * size;

//             // Disegna solo bordi colorati e leggero riempimento per effetto mappa politica
//             ctx.fillStyle = getRegionColor(owner, 0.3);
//             ctx.fillRect(px, py, size, size);
            
//             ctx.strokeStyle = getRegionColor(owner, 0.8);
//             ctx.lineWidth = 1;
//             ctx.strokeRect(px, py, size, size);
            
//             // Disegna un simbolo per il proprietario
//             if (Math.random() > 0.7 && owner !== 'wild') {
//                 ctx.font = "16px serif";
//                 ctx.textAlign = "center";
//                 ctx.fillStyle = "rgba(0,0,0,0.3)";
//                 const symbol = owner === 'count' ? '⚜️' : (owner === 'auvrey' ? '🦁' : '🦅');
//                 ctx.fillText(symbol, px + size/2, py + size/2 + 5);
//             }
//         }
//     }
    
//     drawNeighborPins(ctx);
//     drawVignette(ctx, canvas.width, canvas.height);
// }

function getRegionColor(owner, alpha) {
    const map = {
        count: `rgba(212, 175, 55, ${alpha})`,  // Oro
        auvrey: `rgba(180, 40, 40, ${alpha})`,  // Rosso scuro
        falken: `rgba(20, 60, 120, ${alpha})`,  // Blu scuro
        wild: `rgba(100, 100, 100, ${alpha})`   // Grigio neutro
    };
    return map[owner] || map.wild;
}

function drawNeighborPins(ctx) {
    const canvas = ctx.canvas;
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const radius = canvas.width * 0.35;

    neighboringCounties.forEach((c, idx) => {
        const angle = (idx / neighboringCounties.length) * Math.PI * 2;
        const x = centerX + Math.cos(angle) * radius;
        const y = centerY + Math.sin(angle) * radius;

        ctx.beginPath();
        ctx.fillStyle = getRegionColor(c.key, 1);
        ctx.arc(x, y, 12, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "#3e2723";
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.fillStyle = "#fff";
        ctx.font = "10px Georgia";
        ctx.textAlign = "center";
        ctx.fillText(c.name.split(" ")[0], x, y + 3);
    });
}

// Riusa drawNeighborPins esistente ma migliora lo stile dei pin se vuoi
// ... (Il resto delle funzioni ausiliarie come rand() rimane invariato)

/* ============================================================
   ===================== STRUTTURE DI BASE =====================
   ============================================================ */

function createEmptyStructures() {
    return {
        mines: [],
        sawmills: [],
        quarries: [],
        monasteries: []
    };
}

let structures = createEmptyStructures();
let latestAssetFlows = null;

/* ---- GENERAZIONE AUTOMATICA ---- */
function autogenerateStructures() {
    worldMap.tiles.forEach(t => {

        // Miniera
        if (t.terrain === "mountain" && Math.random() < 0.15) {
            structures.mines.push({
                x:t.x, y:t.y, owner:t.owner,
                type:"mine", condition:100,
                workers:rand(5,15),
                production:t.resources
            });
        }

        // Segheria
        if (t.terrain === "forest" && Math.random() < 0.10) {
            structures.sawmills.push({
                x:t.x, y:t.y, owner:t.owner,
                type:"sawmill", condition:100,
                workers:rand(5,12),
                production:{ wood: rand(20,50) }
            });
        }

        // Cava
        if (t.terrain === "hills" && Math.random() < 0.08) {
            structures.quarries.push({
                x:t.x, y:t.y, owner:t.owner,
                type:"quarry", condition:100,
                workers:rand(8,20),
                production:{ stone: rand(15,40) }
            });
        }

        // Monastero
        if ((t.terrain === "plains" || t.terrain === "forest") && Math.random() < 0.05) {
            structures.monasteries.push({
                x:t.x, y:t.y, owner:"clergy",
                type:"monastery", condition:100,
                workers:rand(6,14),
                production:{ herbs: rand(5,15) }
            });
        }
    });
    assignInitialStructures();
}

/* ============================================================
   =================== EDIFICI AVANZATI ========================
   ============================================================ */

let buildings = [];  // Lista edifici in costruzione

let laborEfficiency = {}; // Mappa globale efficienza per tipo edificio

const buildingData = {
    // --- SETTORE PRIMARIO (Estrazione) ---
    // Non hanno input, producono e basta in base alla fertilità/risorse naturali
    wheat_farm: {
        name: "Fattoria di Grano",
        desc: "Produce grano grezzo.",
        cost: { gold: 50, wood: 20 },
        time: 3,
        staff: { type: 'peasants', amount: 10 }, // Bassa qualifica
        recipe: { output: { grain: 20 } }
    },
    sheep_farm: {
        name: "Allevamento Ovini",
        desc: "Produce lana grezza.",
        cost: { gold: 60, wood: 30 },
        time: 3,
        staff: { type: 'peasants', amount: 8 },
        recipe: { output: { wool: 15, livestock: 2 } }
    },

    // --- SETTORE SECONDARIO (Trasformazione Base) ---
    mill: {
        name: "Mulino a Vento",
        desc: "Macina il grano in farina.",
        cost: { gold: 100, wood: 50, stone: 20 },
        time: 4,
        staff: { type: 'peasants', amount: 5 }, // Richiede pochi ma costanti
        recipe: { 
            input: { grain: 10 }, 
            output: { flour: 12 } // Resa leggermente superiore per valore
        }
    },
    weaver: {
        name: "Filanda",
        desc: "Tesse la lana grezza in tessuti.",
        cost: { gold: 150, wood: 60 },
        time: 5,
        staff: { type: 'burghers', amount: 8 }, // Richiede artigiani (Borghesi)
        minLiteracy: 15, // Richiede un minimo di istruzione per i telai
        recipe: { 
            input: { wool: 10 }, 
            output: { fabric: 8 } 
        }
    },

    // --- SETTORE TERZIARIO (Prodotti Finiti) ---
    bakery: {
        name: "Forno Comunale",
        desc: "Cuoce il pane per il popolo.",
        cost: { gold: 80, stone: 40 },
        time: 3,
        staff: { type: 'burghers', amount: 4 },
        recipe: { 
            input: { flour: 5, wood: 2 }, // Consuma anche legna per il forno!
            output: { bread: 20 } 
        }
    },
    tailor: {
        name: "Sartoria",
        desc: "Confeziona abiti finiti.",
        cost: { gold: 200, wood: 50, stone: 10 },
        time: 6,
        staff: { type: 'burghers', amount: 6 },
        minLiteracy: 30, // Alta qualifica
        recipe: { 
            input: { fabric: 5 }, 
            output: { clothes: 5 } 
        }
    },
    tool_smith: {
        name: "Fabbro Utensili",
        desc: "Crea attrezzi per migliorare il lavoro.",
        cost: { gold: 150, iron: 20, stone: 50 },
        time: 5,
        staff: { type: 'burghers', amount: 5 },
        recipe: { 
            input: { iron: 5, wood: 5 }, 
            output: { tools: 5 } 
        }
    },
    wheat_field: {
        name: "Campi di Grano Estesi",
        desc: "Bonifica terre per nuove coltivazioni intensive.",
        effect: "Grano (produzione auto), Cibo ++",
        cost: { gold: 50, wood: 10 },
        time: 3,
        upkeep: 2
    },
    dairy_farm: {
        name: "Fattoria e Caseificio",
        desc: "Allevamento bovino per carne e formaggi.",
        effect: "Bestiame (produzione auto), Cibo +",
        cost: { gold: 80, wood: 40 },
        time: 3,
        upkeep: 3
    },
    granary: {
        name: "Granaio Fortificato",
        desc: "Protegge i raccolti da parassiti e ladri.",
        effect: "Sicurezza +, Riserve Cibo protette",
        cost: { gold: 100, wood: 80, stone: 40 },
        time: 4,
        upkeep: 5
    },

    // --- ECONOMIA & INDUSTRIA ---
    market: {
        name: "Mercato Cittadino",
        desc: "Il cuore del commercio locale.",
        effect: "Felicità ++, Oro +, Mercanti ++",
        cost: { gold: 100, wood: 50 },
        time: 3,
        upkeep: 8
    },
    harbor: {
        name: "Porto Commerciale",
        desc: "Apre rotte marittime per l'export.",
        effect: "Oro ++, Mercanti +++, Nobiltà +",
        cost: { gold: 300, wood: 60, stone: 80 },
        time: 6,
        upkeep: 25
    },
    sawmill: {
        name: "Segheria Reale",
        desc: "Impianto idraulico per il taglio del legname.",
        effect: "Legno (produzione auto)",
        cost: { gold: 90, wood: 60, stone: 30 },
        time: 4,
        upkeep: 5,
        isStructure: true,
        staff: { type: 'peasants', amount: 15 },
        minLiteracy: 0
    },
    stone_quarry: {
        name: "Cava di Pietra",
        desc: "Estrazione intensiva di materiali da costruzione.",
        effect: "Pietra (produzione auto)",
        cost: { gold: 85, wood: 40, stone: 40 },
        time: 5,
        upkeep: 8,
        isStructure: true,
        staff: { type: 'peasants', amount: 20 },
        minLiteracy: 0
    },
    monastery: {
        name: "Monastero Antico",
        desc: "Centro spirituale e di apprendimento.",
        effect: "Fede ++, Istruzione +",
        cost: { gold: 120, stone: 60, wood: 40 },
        time: 6,
        upkeep: 12,
        isStructure: true,
        staff: { type: 'clergy', amount: 8 },
        minLiteracy: 0
    },
    iron_mine: {
        name: "Miniera di Ferro",
        desc: "Tunnel profondi per l'estrazione di metalli.",
        effect: "Ferro (produzione auto)",
        cost: { gold: 140, wood: 40, stone: 80, iron: 20 },
        time: 6,
        upkeep: 15,
        isStructure: true,
        staff: { type: 'peasants', amount: 30 },
        minLiteracy: 0
    },
    mint: {
        name: "Zecca Ducale",
        desc: "Conia moneta sovrana.",
        effect: "Oro (rendita fissa), Mercanti +",
        cost: { gold: 100, stone: 60, iron: 15 },
        time: 5,
        upkeep: 20
    },

    // --- MILITARE & SICUREZZA ---
    watchtower: {
        name: "Torre di Guardia",
        desc: "Avvista nemici e banditi da lontano.",
        effect: "Sicurezza ++, Aggressività Vicini --",
        cost: { gold: 120, stone: 70, wood: 20 },
        time: 4,
        upkeep: 10,
        staff: { type: 'militia', amount: 5 }
    },
    barracks: {
        name: "Caserma della Guardia",
        desc: "Alloggi permanenti per la milizia cittadina.",
        effect: "Sicurezza +++, Milizia ++",
        cost: { gold: 120, wood: 50, stone: 70, iron: 15 },
        time: 5,
        upkeep: 30
    },
    mercenary_camp: {
        name: "Accampamento Mercenario",
        desc: "Soldati di ventura a pagamento.",
        effect: "Milizia ++, Clero --, Oro - (mantenimento)",
        cost: { gold: 150, wood: 40, stone: 20 },
        time: 3,
        upkeep: 50
    },
    forge: {
        name: "Forgia Militare",
        desc: "Converte Ferro e Carbone (Legno) in Armi e Armature.",
        effect: "Produzione Armi, Milizia ++",
        cost: { gold: 200, wood: 80, stone: 120, iron: 40 },
        time: 5,
        upkeep: 15,
        productionInput: { iron: 5, wood: 5 }, // Costo conversione
        productionOutput: { weapons: 3, armor: 1 } // Output
    },
    stone_walls: {
        name: "Mura di Cinta",
        desc: "Una possente difesa contro gli eserciti invasori.",
        effect: "Sicurezza ++++, Nobiltà +, Prestigio",
        cost: { gold: 500, stone: 400, wood: 50 },
        time: 8,
        upkeep: 15
    },

    // --- FEDE & CULTURA ---
    chapel: {
        name: "Cappella Votiva",
        desc: "Un piccolo luogo di preghiera per il popolo.",
        effect: "Clero +, Felicità +",
        cost: { gold: 60, stone: 20, wood: 30 },
        time: 3,
        upkeep: 5
    },
    church: {
        name: "Chiesa Parrocchiale",
        desc: "Il centro della vita spirituale della comunità.",
        effect: "Clero ++, Felicità ++, Salute +",
        cost: { gold: 250, stone: 150, wood: 60, luxuries: 10 },
        time: 6,
        upkeep: 5
    },
    grand_cathedral: {
        name: "Grande Cattedrale",
        desc: "Un'opera monumentale che attira pellegrini.",
        effect: "Clero ++++, Prestigio Reale, Oro (offerte)",
        cost: { gold: 1200, stone: 800, wood: 200, iron: 50, luxuries: 50 },
        time: 12,
        upkeep: 60
    },
    monk_clinic: {
        name: "Clinica dei Monaci",
        desc: "Erbe e cure per i malati.",
        effect: "Salute +++, Clero ++",
        cost: { gold: 80, wood: 30, herbs: 10 },
        time: 3,
        upkeep: 5
    },

    // --- ISTRUZIONE & PRESTIGIO ---
    school: {
        name: "Scuola degli Scribi",
        desc: "Insegna a leggere e far di conto ai figli dei borghesi.",
        effect: "Artigiani ++, Mistici +, Efficienza tasse",
        cost: { gold: 180, wood: 100, stone: 20 },
        time: 5,
        upkeep: 10,
        staff: { type: 'clergy', amount: 5 },
        isEducational: true
    },
    library: {
        name: "Biblioteca del Conte",
        desc: "Raccoglie sapere antico e mappe rare.",
        effect: "Mistici +++, Consigli migliori",
        cost: { gold: 400, stone: 100, wood: 100, arcane: 10 },
        time: 7,
        upkeep: 20
    },
    theater: {
        name: "Teatro all'Aperto",
        desc: "Svago e cultura per tutte le classi sociali.",
        effect: "Felicità +++, Nobiltà +, Popolo +",
        cost: { gold: 250, wood: 150, stone: 50 },
        time: 5,
        upkeep: 15
    },

    // --- ABITAZIONI & ESPANSIONE ---
    cottage: {
        name: "Casupola",
        desc: "Alloggio base per contadini e lavoratori.",
        effect: "Capacità +50, Contadini +",
        housing: 50, // Nuova proprietà: posti letto
        cost: { gold: 20, wood: 25 },
        time: 2,
        upkeep: 2
    },
    tenement: {
        name: "Palazzina Urbana",
        desc: "Alloggi densi per la borghesia e artigiani.",
        effect: "Capacità +150, Rischio malattie leggero",
        housing: 150,
        cost: { gold: 80, wood: 60, stone: 30 },
        time: 4,
        upkeep: 5
    },
    noble_estate: {
        name: "Tenuta Nobile",
        desc: "Lussuose dimore per attirare l'aristocrazia.",
        effect: "Capacità +20 (Nobili), Nobiltà ++, Prestigio",
        housing: 20,
        cost: { gold: 300, stone: 100, luxuries: 20 },
        time: 6,
        upkeep: 0,
        staff: { type: 'peasants', amount: 10 }
    },
    
    // --- NUOVI EDIFICI ---
    cotton_plantation: {
        name: "Piantagione di Cotone",
        desc: "Coltivazione intensiva per la produzione tessile.",
        effect: "Cotone (produzione auto)",
        cost: { gold: 60, wood: 20 },
        time: 3,
        upkeep: 5,
        staff: { type: 'peasants', amount: 40 }, // Richiede 40 contadini
        minLiteracy: 0
    },
    textile_factory: {
        name: "Manifattura Tessile",
        desc: "Trasforma il cotone grezzo in tessuti pregiati.",
        effect: "Converte Cotone in Tessuti (Alto valore)",
        cost: { gold: 200, wood: 80, stone: 40, iron: 10 },
        time: 6,
        upkeep: 15,
        staff: { type: 'burghers', amount: 20 }, // Richiede artigiani (Borghesi)
        minLiteracy: 30, // Richiede istruzione minima
        productionInput: { cotton: 5 },
        productionOutput: { textiles: 8 }
    },
    school: {
        name: "Scuola Comunale",
        desc: "Aumenta l'alfabetizzazione della popolazione locale.",
        effect: "Istruzione ++, Mobilità Sociale",
        cost: { gold: 150, wood: 100, stone: 20 },
        time: 5,
        upkeep: 10,
        staff: { type: 'clergy', amount: 5 }, // Richiede Clero come insegnanti
        isEducational: true
    },
    local_shop: {
        name: "Bottega Generale",
        desc: "Distribuisce beni e aumenta la velocità del denaro.",
        effect: "Oro ++, Felicità +",
        cost: { gold: 80, wood: 40 },
        time: 3,
        upkeep: 5,
        staff: { type: 'burghers', amount: 5 },
        minLiteracy: 20
    },
    
    // ... (altri edifici come Scuole e Case rimangono invariati) ...
    sawmill: {
        name: "Segheria Reale",
        desc: "Impianto idraulico per il taglio del legname.",
        effect: "Legno (produzione auto)",
        cost: { gold: 90, wood: 60, stone: 30 },
        time: 4,
        upkeep: 5,
        staff: { type: 'peasants', amount: 15 }, // Richiede manodopera
        isStructure: true
    }
};

const STRUCTURE_UPKEEP = { structures: 0, military: 0 };

function calculateSeasonalBudget() {
    // Simulazione accurata del bilancio stagionale usando lo stato attuale
    // Questo calcolo riflette esattamente ciò che accadrà in progressSeason()
    
    // === ENTRATE ===
    const income = {
        taxes_nobility: 0,
        taxes_burghers: 0,
        taxes_peasants: 0,
        taxes_other: 0,
        trade_export: 0,
        production_mint: 0
    };
    
    // Calcolo Tasse (basato sulla ricchezza reale dei pop)
    TAX_CATEGORIES.forEach(cat => {
        const popGroup = populationGroups[cat.key];
        if (!popGroup) return;
        
        const pop = popGroup.count || 0;
        const wealth = popGroup.wealth || 0;
        const baseTaxable = Math.min(wealth, pop * cat.wealthFactor);
        const percent = taxPolicy[cat.key] || 0;
        const taxIncome = Math.floor(baseTaxable * (percent / 100));
        
        if (cat.key === 'nobility') income.taxes_nobility += taxIncome;
        else if (cat.key === 'burghers') income.taxes_burghers += taxIncome;
        else if (cat.key === 'peasants') income.taxes_peasants += taxIncome;
        else income.taxes_other += taxIncome;
    });
    
    // Commercio (approssimazione basata su vendite recenti)
    income.trade_export = Math.floor(seasonalTransactions.marketSales || 0);
    
    // Zecca
    const mints = buildings.filter(b => b.type === 'mint' && b.stage === 'complete').length;
    income.production_mint = mints * 50;
    
    const totalIncome = Object.values(income).reduce((a, b) => a + b, 0);
    
    // === SPESE ===
    const upkeep = calculateDetailedUpkeep();
    
    // Costo Leggi Attive
    let lawCostGold = 0;
    activeLaws.forEach(lawKey => {
        const law = getLawDefinition(lawKey);
        if (law && law.upkeepCost) lawCostGold += law.upkeepCost;
    });
    
    // Stipendi Milizia (pagati dalla contea)
    const militiaWages = Math.floor((populationGroups.militia?.count || 0) * 1.2);
    
    const expenses = {
        upkeep_military: upkeep.military + militiaWages,
        upkeep_civil: upkeep.civil,
        upkeep_court: upkeep.court,
        upkeep_infrastructure: upkeep.infrastructure,
        welfare_laws: lawCostGold,
        import_costs: Math.floor(seasonalTransactions.marketPurchases || 0)
    };
    
    const totalExpense = Object.values(expenses).reduce((a, b) => a + b, 0);
    const net = totalIncome - totalExpense;
    
    return {
        income,
        expenses,
        net: Number.isFinite(net) ? net : 0
    };
}

function buildingName(type){
    return buildingData[type].name;
}

function calculateLaborAndEducation() {
    // 1. Reset Occupazione
    Object.keys(populationGroups).forEach(k => populationGroups[k].employed = 0);
    
    // 2. Calcolo Forza Lavoro Totale Disponibile
    const availableLabor = {};
    Object.keys(populationGroups).forEach(k => {
        availableLabor[k] = Math.floor(populationGroups[k].count * (populationGroups[k].workforceRatio || 0.6));
    });

    // 3. Creazione lista posti di lavoro UNIFICATA (Stessa logica della UI)
    let activeWorkplaces = [];

    // A. Edifici
    buildings.filter(b => b.stage === 'complete').forEach(b => activeWorkplaces.push(b));

    // B. Strutture (Usiamo i tipi mappati per accedere a buildingData)
    // Assegniamo 'realType' al volo se manca, per coerenza con la UI
    structures.mines.forEach(s => { s.realType = 'iron_mine'; activeWorkplaces.push(s); });
    structures.sawmills.forEach(s => { s.realType = 'sawmill'; activeWorkplaces.push(s); });
    structures.quarries.forEach(s => { s.realType = 'stone_quarry'; activeWorkplaces.push(s); });
    structures.monasteries.forEach(s => { s.realType = 'monastery'; activeWorkplaces.push(s); });

    // --- ORDINAMENTO PER PRIORITÀ ---
    const priorityValue = { 'high': 2, 'normal': 1, 'low': 0 };
    
    activeWorkplaces.sort((a, b) => {
        const pA = priorityValue[a.priority || 'normal'];
        const pB = priorityValue[b.priority || 'normal'];
        return pB - pA; // Ordine decrescente (Alta prima)
    });

    // 4. Assegnazione
    activeWorkplaces.forEach(building => {
        // Usa realType se esiste (strutture), altrimenti type (edifici)
        const typeKey = building.realType || building.type;
        const data = buildingData[typeKey];
        
        // Se priorità è 'low', spegni
        if (building.priority === 'low') {
            building.currentEfficiency = 0;
            building.currentStaff = 0;
            building.requiredStaff = data && data.staff ? data.staff.amount : 0;
            return;
        }

        // Se non ci sono dati o staff richiesto, efficienza 100% (o gestita altrove)
        if (!data || !data.staff) {
            building.currentEfficiency = 1.0;
            return;
        }

        const workerType = data.staff.type;
        const required = data.staff.amount;
        const minLit = data.minLiteracy || 0;

        // Preleviamo lavoratori
        let hired = 0;
        if (availableLabor[workerType] >= required) {
            hired = required;
            availableLabor[workerType] -= required;
        } else {
            hired = availableLabor[workerType]; 
            availableLabor[workerType] = 0;
        }

        // Salvataggio dati sull'istanza
        building.currentStaff = hired;
        building.requiredStaff = required;

        populationGroups[workerType].employed += hired;

        // Calcolo Efficienza
        let efficiency = required > 0 ? hired / required : 0;

        // Malus Istruzione
        const currentLiteracy = populationGroups[workerType].literacy || 0;
        if (currentLiteracy < minLit) {
            const literacyPenalty = (minLit - currentLiteracy) * 0.015;
            efficiency = Math.max(0.1, efficiency - literacyPenalty);
        }

        building.currentEfficiency = efficiency;
    });
    
    // 4. Gestione Istruzione (Scolarizzazione)
    const schools = buildings.filter(b => b.type === 'school' && b.stage === 'complete');
    // Efficienza scuole dipende se hanno insegnanti (Clero)
    let educationPower = 0;
    schools.forEach(s => educationPower += (s.currentEfficiency || 0) * 2); // Ogni scuola dà +2 punti crescita max

    // Crescita graduale alfabetizzazione
    Object.keys(populationGroups).forEach(k => {
        const group = populationGroups[k];
        // Target naturale basato sulla classe + bonus scuole
        let targetLiteracy = 0;
        if(k === 'nobility') targetLiteracy = 90;
        else if(k === 'clergy') targetLiteracy = 95;
        else if(k === 'burghers') targetLiteracy = 50 + (educationPower * 5);
        else if(k === 'peasants') targetLiteracy = 5 + (educationPower * 3);
        
        // Avvicinamento lento al target
        if (group.literacy < targetLiteracy) {
            group.literacy += 0.5; // Crescita lenta
        }
    });

    // 5. Mobilità Sociale basata su Salari/Lavoro
    // Se ci sono posti di lavoro qualificati (Burghers) liberi e Contadini istruiti -> Promozione
    // Eseguiamo solo se c'è richiesta non soddisfatta
    const burgherDemand = activeWorkplaces
        .filter(b => buildingData[(b.realType || b.type)]?.staff?.type === 'burghers')
        .reduce((acc, b) => acc + buildingData[(b.realType || b.type)].staff.amount, 0);
    
    const burghersAvailable = Math.floor(populationGroups.burghers.count * 0.8);
    
    if (burgherDemand > burghersAvailable && populationGroups.peasants.literacy > 20) {
        // Promozione sociale
        const promoted = Math.min(10, Math.floor(populationGroups.peasants.count * 0.01));
        populationGroups.peasants.count -= promoted;
        populationGroups.burghers.count += promoted;
        if(promoted > 0) logTurnEvent(`${promoted} contadini istruiti sono diventati artigiani per coprire la domanda di lavoro.`);
    }
}

function processProductionChains(targetState = null) {
    const stateRef = targetState ? targetState.county : county;
    const resourceBag = stateRef.resources;
    const report = { produced: {}, consumed: {}, shortages: [] };

    // Ordine di esecuzione: Prima le materie prime, poi i trasformati
    // (Per permettere al mulino di usare il grano raccolto nello stesso turno)
    const productionOrder = [
        ['wheat_farm', 'sheep_farm', 'iron_mine', 'sawmill'], // Tier 1
        ['mill', 'weaver', 'forge'], // Tier 2
        ['bakery', 'tailor', 'tool_smith', 'textile_factory'] // Tier 3
    ];

    // Appiattisci l'array per il loop, ma mantieni la logica concettuale
    const buildingsList = buildings.filter(b => b.stage === 'complete');

    // Eseguiamo in 3 passaggi per simulare la catena nello stesso turno
    productionOrder.forEach(tierGroup => {
        
        buildingsList.filter(b => tierGroup.includes(b.type)).forEach(building => {
            const data = buildingData[building.type];
            if (!data || !data.recipe) return;

            // 1. Recupera Efficienza (calcolata dalla funzione Labor/Education precedente)
            // Se non c'è staff, efficienza è 0. Se c'è sciopero, è 0.
            let efficiency = building.currentEfficiency || 0;
            
            if (efficiency <= 0) return; // Fabbrica ferma

            // 2. Calcola Input necessari (Scalati per efficienza)
            // Nota: Anche se lavorano al 50%, consumano il 50% delle risorse
            let maxProductionRatio = efficiency; 

            // Verifica disponibilità risorse Input
            if (data.recipe.input) {
                for (const [resKey, amount] of Object.entries(data.recipe.input)) {
                    const needed = amount * efficiency;
                    const available = resourceBag[resKey] || 0;
                    
                    if (available < needed) {
                        // Collo di bottiglia! Riduciamo la produzione in base alle risorse disponibili
                        const ratio = available / amount; // Quanto possiamo produrre realmente?
                        maxProductionRatio = Math.min(maxProductionRatio, ratio);
                        
                        if (!report.shortages.includes(resKey)) report.shortages.push(resKey);
                    }
                }
            }

            // Se non abbiamo risorse nemmeno per produrre un po', salta
            if (maxProductionRatio <= 0.01) return;

            // 3. Consuma Input
            if (data.recipe.input) {
                for (const [resKey, amount] of Object.entries(data.recipe.input)) {
                    const realCost = amount * maxProductionRatio;
                    resourceBag[resKey] -= realCost;
                    
                    report.consumed[resKey] = (report.consumed[resKey] || 0) + realCost;
                }
            }

            // 4. Genera Output
            if (data.recipe.output) {
                for (const [resKey, amount] of Object.entries(data.recipe.output)) {
                    const realOutput = amount * maxProductionRatio;
                    resourceBag[resKey] = (resourceBag[resKey] || 0) + realOutput;
                    
                    report.produced[resKey] = (report.produced[resKey] || 0) + realOutput;
                }
            }
        });
    });

    return report;
}

</script>
<script>

/* ============================================================
   ====================== PRODUZIONE PER TURNO =================
   ============================================================ */

function applyProduction(targetState = null, options = {}) {
    const { silent = false, skipUI = false } = options;
    const stateStruct = targetState ? targetState.structures : structures;
    const stateCounty = targetState ? targetState.county : county;
    stateCounty.resources = normalizeResourceBag(stateCounty.resources);
    const notifyStructures = !targetState && !silent;

    const total = {
        wood:0, stone:0, iron:0, copper:0, gold:0, herbs:0,
        grain:0, livestock:0, textiles:0, luxuries:0, arcane:0
    };

    const mines = ownedStructures(stateStruct && stateStruct.mines ? stateStruct.mines : []);
    mines.forEach(m => {
        for (let k in m.production) {
            const amount = Math.floor(m.production[k] * (m.condition / 100));
            if (k === "gems" || k === "silver") {
                total.luxuries += amount;
            } else if (k === "mystic_crystals") {
                total.arcane += amount;
            } else {
                total[k] = (total[k] || 0) + amount;
            }
        }
        degradeStructure(m, { notify: notifyStructures });
    });

    const sawmills = ownedStructures(stateStruct && stateStruct.sawmills ? stateStruct.sawmills : []);
    sawmills.forEach(s => {
        const amount = Math.floor(s.production.wood * (s.condition / 100));
        total.wood += amount;
        degradeStructure(s, { notify: notifyStructures });
    });

    const quarries = ownedStructures(stateStruct && stateStruct.quarries ? stateStruct.quarries : []);
    quarries.forEach(q => {
        const amount = Math.floor(q.production.stone * (q.condition / 100));
        total.stone += amount;
        degradeStructure(q, { notify: notifyStructures });
    });

    const monasteries = ownedStructures(stateStruct && stateStruct.monasteries ? stateStruct.monasteries : []);
    monasteries.forEach(m => {
        const amount = Math.floor(m.production.herbs * (m.condition / 100));
        total.herbs += amount;
        degradeStructure(m, { notify: notifyStructures });
    });

    Object.keys(total).forEach(k => {
        stateCounty.resources[k] = (stateCounty.resources[k] || 0) + total[k];
    });

    if (!targetState && !silent) {
        addMsg("system", `⛏️ Produzione del turno: ${formatResourceReport(total)}`);
        if (!skipUI) updateResourceUI();
    }

    return total;
}

// AGGIUNTA IN applyProduction o funzione dedicata
function processWarProduction() {
    // Trova fucine attive
    const forges = buildings.filter(b => b.type === 'forge' && b.stage === 'complete');
    
    forges.forEach(forge => {
        // Controlla input (Ferro + Legno)
        if (county.resources.iron >= 5 && county.resources.wood >= 5) {
            county.resources.iron -= 5;
            county.resources.wood -= 5;
            
            // Output
            county.resources.weapons = (county.resources.weapons || 0) + 3;
            county.resources.armor = (county.resources.armor || 0) + 1;
        } else {
            // Se mancano risorse, la forgia non lavora
            // (Opzionale: messaggio di avviso)
        }
    });
}

/* ===================== SISTEMA MILITARE AVANZATO ===================== */

// 1. MOBILITAZIONE (Chiamata alle Armi)
function toggleMobilization() {
    const peasantGroup = populationGroups.peasants;
    
    if (!warState.mobilized) {
        // ATTIVA LEVA
        if (peasantGroup.count < 100) {
            addMsg("system", "❌ Non ci sono abbastanza uomini validi per formare un esercito.");
            return;
        }

        // Prendi il 30% della forza lavoro contadina
        const levyAmount = Math.floor(peasantGroup.count * 0.30);
        
        warState.leviesCount = levyAmount;
        peasantGroup.count -= levyAmount; // Rimuovi dall'economia!
        warState.mobilized = true;
        
        // Calo felicità immediato
        county.happy -= 10;
        factions.peasants -= 15;
        
        addMsg("system", `⚔️ <strong>LEVA GENERALE:</strong> ${levyAmount} contadini hanno lasciato i campi per prendere le armi. La produzione agricola crollerà.`);
    } else {
        // SCIOGLI ESERCITO (Ritorno ai campi)
        const survivors = warState.leviesCount;
        peasantGroup.count += survivors;
        
        warState.leviesCount = 0;
        warState.mobilized = false;
        
        county.happy += 5;
        factions.peasants += 5;
        
        addMsg("system", `🕊️ <strong>SMOBILITAZIONE:</strong> ${survivors} uomini tornano alle loro famiglie.`);
    }
    
    updateUI();
}

// 2. CALCOLO POTENZA MILITARE
/* ===================== LOGICA MILITARE AGGIORNATA ===================== */

function getArmyEfficiency() {
    const soldiers = populationGroups.militia.count; // Solo professionisti per ora
    const levies = warState.mobilized ? warState.leviesCount : 0;
    const totalTroops = soldiers + levies;

    if (totalTroops <= 0) return 100;

    // Calcolo Armi necessarie
    // I soldati (militia) consumano 1 arma a testa per essere al 100%
    // Le leve (contadini) possono combattere con forconi (efficienza ridotta ma non zero)
    const weaponsStock = county.resources.weapons || 0;
    
    // Calcoliamo quanti soldati sono armati correttamente
    const armedTroops = Math.min(totalTroops, weaponsStock);
    
    // Efficienza base: percentuale di truppe armate
    let efficiency = (armedTroops / totalTroops) * 100;
    
    // Se ci sono leve non armate, hanno un'efficienza minima del 20% (forconi e bastoni)
    // Se sono soldati professionisti senza armi, efficienza 10% (pugni?)
    if (efficiency < 100) {
        const unarmed = totalTroops - weaponsStock;
        // Bonus minimo per non rendere l'esercito inutile se manca 1 spada
        efficiency += (unarmed / totalTroops) * 15; 
    }

    return Math.min(100, Math.floor(efficiency));
}

function calculateMilitaryPower() {
    const soldiers = populationGroups.militia.count;
    const levies = warState.mobilized ? warState.leviesCount : 0;
    
    // Potenza Base
    let rawPower = (soldiers * 5) + (levies * 1.5); // Soldati valgono molto più delle leve

    // Fattore Efficienza Armamenti
    const efficiencyPct = getArmyEfficiency();
    
    // Applicazione Efficienza
    let finalPower = Math.floor(rawPower * (efficiencyPct / 100));

    // Bonus Armature (Aggiunge resistenza extra, non attacco)
    const armorStock = county.resources.armor || 0;
    const totalTroops = soldiers + levies;
    if (armorStock > 0 && totalTroops > 0) {
        const armorCoverage = Math.min(1, armorStock / totalTroops);
        finalPower *= (1 + (armorCoverage * 0.3)); // Max +30% bonus se tutti corazzati
    }

    // Bonus Difensivi (Mura)
    finalPower += (county.security * 2);

    return Math.floor(finalPower);
}

// 3. SIMULAZIONE BATTAGLIA
function resolveBattle(enemyKey) {
    const enemy = neighboringCounties.find(c => c.key === enemyKey);
    if (!enemy) return;
    
    const myPower = calculateMilitaryPower();
    // Il nemico ha potenza base + bonus aggressione
    const enemyPower = (enemy.power * 10) + (enemy.aggression * 2);
    
    addMsg("system", `⚔️ <strong>BATTAGLIA CAMPALE contro ${enemy.name}</strong>`);
    addMsg("system", `Noi: ${myPower} forza (Uomini: ${populationGroups.militia.count + warState.leviesCount}) vs Loro: ${enemyPower} forza.`);

    // Logica Casualità
    const luck = 0.8 + (Math.random() * 0.4); // Fattore 0.8x a 1.2x
    const finalMyPower = myPower * luck;
    
    // Calcolo Perdite (Morti)
    // Più è cruenta la battaglia, più morti ci sono. 
    // I contadini (Leva) muoiono molto più facilmente della Milizia.
    const baseCasualtiesPct = 0.1 + (Math.random() * 0.2); // 10-30% di perdite
    
    let deadMilitia = Math.floor(populationGroups.militia.count * baseCasualtiesPct * 0.5); // Milizia muore meno
    let deadLevies = 0;
    
    if (warState.mobilized) {
        deadLevies = Math.floor(warState.leviesCount * baseCasualtiesPct * 1.5); // Contadini muoiono molto
        warState.leviesCount -= deadLevies;
        // Nota: Questi non tornano in populationGroups.peasants! SONO MORTI PER SEMPRE.
    }
    populationGroups.militia.count -= deadMilitia;
    
    // Consumo Armi
    const brokenWeapons = Math.floor((deadMilitia + deadLevies) * 0.8);
    county.resources.weapons = Math.max(0, (county.resources.weapons||0) - brokenWeapons);

    // ESITO
    if (finalMyPower >= enemyPower) {
        // VITTORIA
        const loot = Math.floor(enemy.wealth * 2);
        county.gold += loot;
        enemy.power = Math.max(0, enemy.power - 20);
        enemy.aggression = Math.max(0, enemy.aggression - 30); // Si calmano
        county.happy += 10;
        addMsg("system", `🏆 <strong>VITTORIA!</strong> Il nemico è in rotta. Abbiamo saccheggiato ${loot} oro.`);
    } else {
        // SCONFITTA - Penalità ridotte
        const goldLost = Math.floor(county.gold * 0.2);
        county.gold -= goldLost;
        county.happy -= 15; // Era -20
        county.security -= 8; // Era -10
        county.health -= 4; // Era -5 - Feriti e malattie
        addMsg("system", `🔥 <strong>SCONFITTA!</strong> Il nemico ha razziato le nostre terre (-${goldLost} oro).`);
    }
    
    addMsg("system", `☠️ <strong>Caduti:</strong> ${deadMilitia} soldati e ${deadLevies} contadini.`);
    
    if (deadLevies > 50) {
        addMsg("system", "📉 La perdita di così tanti contadini avrà conseguenze disastrose sui prossimi raccolti.");
    }
    
    updateUI();
}

function degradeStructure(s, options = {}) {
    const notify = options.notify !== false;
    s.condition -= rand(0, 2);
    if (notify && s.condition < 35 && Math.random() < 0.12) {
        addMsg("ai", `⚠️ La struttura (${s.type}) in ${s.x},${s.y} è in pessime condizioni.`);
    }
}

function updateResourceUI() {
    const bag = county.resources || {};
    RESOURCE_KEYS.forEach(key => {
        const valEl = document.getElementById(`res-${key}`);
        if (valEl) valEl.innerText = bag[key] || 0;
        const deltaEl = document.getElementById(`res-${key}-delta`);
        if (!deltaEl) return;
        const deltaValue = lastResourceDelta ? (lastResourceDelta[key] || 0) : 0;
        deltaEl.innerText = formatDeltaValue(deltaValue);
        deltaEl.classList.remove("positive", "negative");
        if (deltaValue > 0) deltaEl.classList.add("positive");
        else if (deltaValue < 0) deltaEl.classList.add("negative");
    });
}

function formatDeltaValue(value) {
    if (!value) return "—";
    return value > 0 ? `+${value}` : `${value}`;
}

function calculateHousingCapacity() {
    // FIX: Aumentata capacità base da 100 a 150 per abitante per evitare senzatetto al turno 1
    let capacity = (settlements.length || 0) * 150; 

    // Capacità aggiunta dagli edifici costruiti
    buildings.forEach(b => {
        if (b.stage === 'complete') {
            const data = buildingData[b.type];
            if (data && data.housing) {
                capacity += data.housing;
            }
            // Bonus extra specifici
            if (b.type === 'barracks') capacity += 50; 
            if (b.type === 'grand_cathedral') capacity += 50; // Aumentato rifugio
        }
    });
    return capacity;
}

function processVillageEconomy(targetState = null, options = {}) {
    const { silent = false, skipUI = false } = options;
    const stateRef = targetState || null;
    const summary = updateIndustrySummary(stateRef);
    const flows = calculateAssetFlows(summary, stateRef);
    const production = calculateVillageProduction(stateRef);
    const consumption = calculateVillageConsumption(stateRef);
    const logisticNeeds = calculateLogisticNeeds(stateRef);
    logisticNeeds.forEach(need => {
        consumption[need.resource] = (consumption[need.resource] || 0) + need.amount;
    });
    const deficits = {};
    const stateCounty = stateRef ? stateRef.county : county;
    stateCounty.resources = normalizeResourceBag(stateCounty.resources);
    const resourceBag = stateCounty.resources;

    if (flows.goldCost) {
        const need = flows.goldCost;
        const available = stateCounty.gold || 0;
        if (available >= need) {
            stateCounty.gold = available - need;
        } else {
            const paidRatio = available / need;
            stateCounty.gold = 0;
            Object.keys(production).forEach(key => {
                production[key] = Math.floor(production[key] * paidRatio);
            });
            Object.keys(consumption).forEach(key => {
                consumption[key] = Math.floor((consumption[key] || 0) * paidRatio);
            });
            deficits.gold = Math.ceil(need - available);
        }
    }

    Object.keys(production).forEach(key => {
        resourceBag[key] = (resourceBag[key] || 0) + production[key];
    });

    Object.keys(consumption).forEach(key => {
        const available = resourceBag[key] || 0;
        const finalAmount = available - consumption[key];
        if (finalAmount < 0) {
            deficits[key] = Math.abs(finalAmount);
            resourceBag[key] = 0;
        } else {
            resourceBag[key] = finalAmount;
        }
    });

    applyEconomicEffects(production, consumption, deficits, stateRef);
    const logisticImpact = applyLogisticConsequences(logisticNeeds, deficits, stateRef);

    if (!targetState && !silent) {
        const upkeepNote = flows.goldCost ? ` | Manutenzione: ${flows.goldCost} oro` : "";
        addMsg("system", `⚖️ Economia locale — Prodotti: ${formatResourceReport(production)} | Consumi: ${formatResourceReport(consumption)}${upkeepNote}`);
        if (Object.keys(deficits).length) {
            addMsg("system", `⚠️ Carenze critiche: ${formatResourceReport(deficits)}`);
        }
        if (logisticImpact.military) {
            addMsg("system", "⚔️ Le forniture militari sono insufficienti: la disciplina cala e la salute pubblica ne risente.");
        }
        if (logisticImpact.construction) {
            addMsg("system", "🏗️ I cantieri rallentano per mancanza di materiali: alcuni lavori slittano.");
        }
        if (!skipUI) updateUI();
    }

    return { production, consumption, deficits, logisticImpact, logisticNeeds };
}

function processPopNeedsSystem(targetState = null, options = {}) {
    const { silent = false } = options;
    const statePop = targetState ? targetState.populationGroups : populationGroups;
    const stateCounty = targetState ? targetState.county : county;
    const stateFactions = targetState ? targetState.factions : factions;
    const marketPrices = getMarketPrices(); 
    
    // Resetta il report per questo turno
    if (!targetState) lastNeedsReport = {};

    let reportLog = [];
    let totalSatisfaction = 0;
    let groupsProcessed = 0;

    for (const [groupKey, data] of Object.entries(statePop)) {
        if (data.count <= 0) continue;
        const needs = POP_NEEDS[groupKey];
        if (!needs) continue;

        let primaryMet = 0;
        let secondaryMet = 0;
        
        // Tracking per il report IA
        let povertyStrikes = 0; // Quante volte non hanno avuto soldi
        let shortageStrikes = 0; // Quante volte mancava merce

        const attemptPurchase = (needList, isPrimary) => {
            let count = 0; 
            let met = 0;
            for (const [resKey, amountPerCapita] of Object.entries(needList)) {
                count++;
                const totalDemand = Math.ceil(amountPerCapita * data.count);
                const stock = stateCounty.resources[resKey] || 0;
                const unitPrice = marketPrices[resKey] || 1;
                const maxAffordable = Math.floor(data.wealth / unitPrice);
                
                const actualBuy = Math.min(totalDemand, stock, maxAffordable);
                
                // Transazione
                if (actualBuy > 0) {
                    stateCounty.resources[resKey] -= actualBuy;
                    data.wealth -= actualBuy * unitPrice;
                    stateCounty.gold += Math.floor(actualBuy * unitPrice * 0.3);
                }

                // Analisi cause fallimento per l'IA
                if (actualBuy < totalDemand) {
                    if (maxAffordable < totalDemand) povertyStrikes++; // Hanno fallito per soldi
                    else if (stock < totalDemand) shortageStrikes++;   // Hanno fallito per stock
                }

                met += (totalDemand > 0 ? actualBuy / totalDemand : 1);
            }
            return { count, met };
        };

        const pRes = attemptPurchase(needs.primary || {}, true);
        const sRes = attemptPurchase(needs.secondary || {}, false);

        const pScore = pRes.count > 0 ? (pRes.met / pRes.count) : 1;
        const sScore = sRes.count > 0 ? (sRes.met / sRes.count) : 1;

        // --- SALVATAGGIO DATI PER L'IA ---
        if (!targetState) {
            let status = "Soddisfatto";
            let reason = "Nessuna";
            
            if (pScore < 0.5) {
                status = "DISPERATO";
                // Determiniamo la causa principale
                if (povertyStrikes > shortageStrikes) reason = "POVERTÀ ESTREMA (Prezzi troppo alti)";
                else reason = "CARESTIA (Magazzini vuoti)";
            } else if (pScore < 0.9) {
                status = "In difficoltà";
                if (povertyStrikes > 0) reason = "Potere d'acquisto basso";
                else reason = "Scarsità merci";
            }

            lastNeedsReport[groupKey] = {
                wealth: Math.floor(data.wealth),
                primary: Math.floor(pScore * 100),
                secondary: Math.floor(sScore * 100),
                status: status,
                mainIssue: reason
            };
        }
        // ---------------------------------

        // Conseguenze migliorate - più generose
        if (pScore < 0.8) {
            const severity = (1 - pScore);
            stateCounty.health = Math.max(0, stateCounty.health - (severity * 3)); // Era 5
            stateFactions[groupKey] = Math.max(0, stateFactions[groupKey] - (severity * 15)); // Era 20
        } else {
            stateFactions[groupKey] = Math.min(100, stateFactions[groupKey] + 2); // Era 1
        }

        // Bisogni secondari - più equilibrati
        if (sScore < 0.5) { // Soglia abbassata da 0.6
            stateCounty.happy = Math.max(0, stateCounty.happy - 1); // Era -2
            stateFactions[groupKey] = Math.max(0, stateFactions[groupKey] - 1); // Era -2
        } else if (sScore > 0.8) { // Soglia abbassata da 0.9
            stateCounty.happy = Math.min(100, stateCounty.happy + 2); // Era +1
            stateFactions[groupKey] = Math.min(100, stateFactions[groupKey] + 3); // Era +2
        }
        
        // NUOVO: Bonus extra se ENTRAMBI i bisogni sono soddisfatti
        if (pScore > 0.9 && sScore > 0.9) {
            stateCounty.happy = Math.min(100, stateCounty.happy + 2);
            stateFactions[groupKey] = Math.min(100, stateFactions[groupKey] + 2);
        }

        totalSatisfaction += (pScore * 0.7 + sScore * 0.3);
        groupsProcessed++;
    }

    return totalSatisfaction / (groupsProcessed || 1);
}

function calculateVillageProduction(stateRef = null) {
    // Eseguiamo prima il calcolo occupazione
    if(!stateRef) calculateLaborAndEducation(); 

    const summary = getIndustrySummary(stateRef);
    const flows = getCachedAssetFlows(stateRef) || calculateAssetFlows(summary, stateRef);
    const production = { ...flows.production };

    // Applica efficienza lavoro agli edifici manifatturieri (Fabbriche, ecc.)
    const buildingsRef = stateRef ? stateRef.buildings : buildings;
    buildingsRef.forEach(b => {
        if (b.stage !== 'complete') return;
        const data = buildingData[b.type];
        
        // Se è un edificio produttivo custom (es. Fabbrica Tessile)
        if (data.productionOutput && b.currentEfficiency > 0) {
            // Controlla input (es. Cotone)
            let hasInput = true;
            if (data.productionInput) {
                for(let res in data.productionInput) {
                    if ((county.resources[res] || 0) < data.productionInput[res]) hasInput = false;
                }
            }

            if (hasInput) {
                // Consuma input
                if (data.productionInput) {
                    for(let res in data.productionInput) {
                        county.resources[res] -= data.productionInput[res] * b.currentEfficiency; // Consumo scalato? O fisso? Facciamo scalato
                    }
                }
                // Genera output scalato per efficienza
                for(let res in data.productionOutput) {
                    production[res] = (production[res] || 0) + (data.productionOutput[res] * b.currentEfficiency);
                }
            }
        }
        
        // Piantagioni Cotone (senza input)
        if (b.type === 'cotton_plantation') {
             production.cotton = (production.cotton || 0) + (15 * b.currentEfficiency);
        }
    });

    // Applica moltiplicatori standard
    Object.keys(production).forEach(key => {
        const mult = getProductionMultiplier(key, stateRef);
        production[key] = Math.max(0, Math.floor(production[key] * mult));
    });
    return production;
}

function calculateVillageConsumption(stateRef = null) {
    const popRef = stateRef ? stateRef.populationGroups : populationGroups;
    const flows = getCachedAssetFlows(stateRef) || calculateAssetFlows(getIndustrySummary(stateRef), stateRef);
    const consumption = { ...flows.consumption };
    
    // Gestisce sia la struttura con .count che valori diretti
    const getPop = (group) => {
        if (!popRef[group]) return 0;
        return popRef[group].count !== undefined ? popRef[group].count : (popRef[group] || 0);
    };
    
    const grainExtra = Math.floor(((getPop('militia') + getPop('peasants')) * 0.05));
    const livestockExtra = Math.floor((getPop('nobility') * 0.02));
    const textilesExtra = Math.floor((getPop('burghers') * 0.02));
    const herbsExtra = Math.floor((getPop('mystics') * 0.05));
    if (grainExtra) consumption.grain = (consumption.grain || 0) + grainExtra;
    if (livestockExtra) consumption.livestock = (consumption.livestock || 0) + livestockExtra;
    if (textilesExtra) consumption.textiles = (consumption.textiles || 0) + textilesExtra;
    if (herbsExtra) consumption.herbs = (consumption.herbs || 0) + herbsExtra;
    return consumption;
}

function applyEconomicEffects(production, consumption, deficits, stateRef = null) {
    const countyRef = stateRef ? stateRef.county : county;
    const factionsRef = stateRef ? stateRef.factions : factions;

    // --- NUOVA LOGICA ABITATIVA ---
    const totalPop = countyRef.pop;
    const capacity = calculateHousingCapacity();
    const homeless = Math.max(0, totalPop - capacity);
    const vacancy = Math.max(0, capacity - totalPop);

    // Effetti dei Senzatetto (Deficit Abitativo) - RIDOTTI
    if (homeless > 0) {
        // Più gente senza casa = Più infelicità e malattie (ma meno severo)
        const severity = Math.ceil(homeless / 100); // Era /50 - Ogni 100 senzatetto, 1 punto malus
        
        countyRef.happy = clamp(countyRef.happy - Math.ceil(severity * 0.5)); // Era -severity
        countyRef.health = clamp(countyRef.health - Math.ceil(severity / 3)); // Era /2
        
        // Le fazioni popolari si arrabbiano (meno)
        factionsRef.peasants -= 1; // Era -2
        factionsRef.outcasts += 1; // Era +2
        
        // Messaggio di allarme (meno frequente)
        if (!stateRef && Math.random() < 0.1) { // Era 0.2
            addMsg("ai", `🏚️ <b>Emergenza Abitativa:</b> ${homeless} sudditi dormono all'aperto! La plebe mormora.`);
        }
    } 
    // Effetti dello Spazio Libero (Incentivo alla crescita) - MIGLIORATI
    else if (vacancy > 50) {
        // Se ci sono case libere e cibo, la gente arriva
        if (countyRef.food > 30 && countyRef.happy > 40) { // Era > 50
            // Immigrazione bonus e felicità aumentata
            countyRef.happy = Math.min(100, countyRef.happy + 1);
            factionsRef.peasants = Math.min(100, factionsRef.peasants + 1);
            // Immigrazione bonus
            const immigration = Math.floor(vacancy * 0.05); // Riempi il 5% dei posti liberi
            adjustPopulation("peasants", immigration, stateRef);
            if (!stateRef && Math.random() < 0.1) {
                addMsg("system", `🏘️ Le case vuote attirano ${immigration} nuovi coloni.`);
            }
        }
    }
    // --- FINE NUOVA LOGICA ---

    const prodGrain = production.grain || 0;
    const consGrain = consumption.grain || 0;
    const prodLivestock = production.livestock || 0;
    const consLivestock = consumption.livestock || 0;
    const prodTextiles = production.textiles || 0;
    const consTextiles = consumption.textiles || 0;
    const prodLuxuries = production.luxuries || 0;
    const consLuxuries = consumption.luxuries || 0;
    const prodArcane = production.arcane || 0;
    const consArcane = consumption.arcane || 0;
    const foodShortage = deficits.grain || deficits.livestock;
    const textileShortage = deficits.textiles;
    const luxuryShortage = deficits.luxuries;
    const arcaneShortage = deficits.arcane || deficits.herbs;
    const goldShortage = deficits.gold;

    if (foodShortage) {
        countyRef.food = clamp(countyRef.food - 6);
        countyRef.happy = clamp(countyRef.happy - 4);
        factionsRef.peasants -= 4;
        factionsRef.militia -= 2;
        const loss = Math.max(1, Math.floor(((deficits.grain || 0) + (deficits.livestock || 0)) / 120));
        adjustPopulation("peasants", -loss, stateRef);
    } else if (prodGrain > consGrain) {
        countyRef.food = clamp(countyRef.food + 3);
        factionsRef.peasants += 1;
    }

    if (textileShortage) {
        factionsRef.burghers -= 3;
        countyRef.happy = clamp(countyRef.happy - 2);
    } else if (prodTextiles > consTextiles) {
        factionsRef.burghers += 1;
    }

    if (luxuryShortage) {
        factionsRef.nobility -= 3;
        factionsRef.merchants -= 2;
        countyRef.happy = clamp(countyRef.happy - 3);
    } else if (prodLuxuries > consLuxuries) {
        factionsRef.nobility += 1;
        factionsRef.merchants += 1;
        const delta = Math.max(0, Math.floor((prodLuxuries - consLuxuries) / 200));
        if (delta) adjustPopulation("merchants", delta, stateRef);
    }

    if (arcaneShortage) {
        factionsRef.mystics -= 3;
        factionsRef.clergy -= 1;
        countyRef.health = clamp(countyRef.health - 4);
    } else if (prodArcane > consArcane) {
        factionsRef.mystics += 1;
        countyRef.health = clamp(countyRef.health + 2);
    }

    if (goldShortage) {
        countyRef.happy = clamp(countyRef.happy - 2);
        factionsRef.merchants -= 3;
        factionsRef.burghers -= 2;
    }

    factionOrder.forEach(f => factionsRef[f] = clamp(factionsRef[f]));
}

function formatResourceReport(obj) {
    const entries = Object.entries(obj)
        .filter(([, value]) => value && value !== 0)
        .map(([key, value]) => `${resourceLabels[key] || key}:${value}`);
    return entries.length ? entries.join(", ") : "nessuno";
}

function diffResources(start, end) {
    const result = {};
    RESOURCE_KEYS.forEach(key => {
        const endVal = (end && end[key] !== undefined) ? end[key] : 0;
        const startVal = (start && start[key] !== undefined) ? start[key] : 0;
        result[key] = endVal - startVal;
    });
    return result;
}

function diffFactions(start, end) {
    const result = {};
    const keys = new Set([...(Object.keys(start || {})), ...(Object.keys(end || {}))]);
    keys.forEach(key => {
        const endVal = (end && end[key] !== undefined) ? end[key] : 0;
        const startVal = (start && start[key] !== undefined) ? start[key] : 0;
        result[key] = endVal - startVal;
    });
    return result;
}

function formatResourceDelta(delta) {
    const entries = Object.entries(delta)
        .filter(([, val]) => val !== 0)
        .map(([key, val]) => `${resourceLabels[key] || key}:${val > 0 ? "+" + val : val}`);
    return entries.length ? entries.join(", ") : "nessuna variazione";
}

function formatFactionDelta(delta) {
    const entries = Object.entries(delta)
        .filter(([, val]) => val !== 0)
        .map(([key, val]) => `${key}:${val > 0 ? "+" + val : val}`);
    return entries.length ? entries.join(", ") : "stabili";
}

function simulateEconomyTurns(turns = 5) {
    const simState = captureGameState();
    ensureWorldSystems(simState);
    const startResources = cloneResourceBag(simState.county.resources);
    const startFactions = JSON.parse(JSON.stringify(simState.factions));

    for (let i = 0; i < turns; i++) {
        advanceSeason(simState, { silent:true });
        applyProduction(simState, { silent:true });
        processVillageEconomy(simState, { silent:true });
        collectTaxes(simState, { silent:true });
        applySeasonalUpkeep(simState, { silent:true });
    }

    const resourceDelta = diffResources(startResources, simState.county.resources);
    const factionDelta = diffFactions(startFactions, simState.factions);

    addMsg("system", `📊 Simulazione ${turns} turni — Risorse: ${formatResourceDelta(resourceDelta)} | Fazioni: ${formatFactionDelta(factionDelta)}`);
}


/* ============================================================
   ======================= COSTRUZIONI =========================
   ============================================================ */

// Chiamata da parte dell’IA (parte 6 la utilizzerà)
function startBuilding(data) {
    const type = data.type;
    const name = buildingData[type].name;

    // COSTI
    const cost = data.cost;
    if (!hasResources(cost)) {
        addMsg("ai", `❌ Mancano le risorse per costruire ${name}.`);
        return;
    }

    payResources(cost);

    buildings.push({
        id: crypto.randomUUID(),
        type: type,
        x: data.x,
        y: data.y,
        owner: "count",
        turns_left: data.turns,
        condition: 100,
        stage: "building",
        resources_needed: cost
    });

    addMsg("ai", `🏗️ Avviata la costruzione di <b>${name}</b> in (${data.x}, ${data.y}). Sarà completata in ${data.turns} turni.`);
}

function hasResources(cost) {
    for (let k in cost) {
        // Controllo Valuta
        if (k === 'gold' || k === 'oro') {
            if ((county.gold || 0) < cost[k]) return false;
        } 
        // Controllo Materiali
        else {
            if ((county.resources[k] || 0) < cost[k]) return false;
        }
    }
    return true;
}

function payResources(cost) {
    for (let k in cost) {
        // 1. GESTIONE DELL'ORO (assumendo sia la chiave 'gold' o 'oro' e sia in county.gold)
        if (k === 'gold' || k === 'oro') {
            if (county.gold !== undefined) {
                county.gold -= cost[k]; // Sottrae dal Tesoro separato
            }
        } 
        // 2. GESTIONE DELLE ALTRE RISORSE (legno, pietra, etc.)
        else if (county.resources[k] !== undefined) {
            county.resources[k] -= cost[k]; // Sottrae dal contenitore generico
        }
    }
}


function registerNewStructure(collectionKey, production, sourceBuilding, typeLabel = null) {
    if (!structures[collectionKey]) structures[collectionKey] = [];
    const entry = {
        x: sourceBuilding.x,
        y: sourceBuilding.y,
        owner: sourceBuilding.owner || "count",
        type: typeLabel || collectionKey,
        condition: 100,
        workers: rand(6, 14),
        production: production
    };
    structures[collectionKey].push(entry);
    updateIndustrySummary();
}

function processBuildings() {
    buildings.forEach(b => {
        if (b.stage === "building") {

            b.turns_left--;

            if (b.turns_left <= 0) {
                b.stage = "complete";
                addMsg("ai", `🏰 L'edificio <b>${buildingName(b.type)}</b> è stato completato!`);
                applyBuildingEffects(b);
            } else {
                maybeConstructionEvent(b);
            }
        }
    });
}


/* ============================================================
   ================== EVENTI DURANTE COSTRUZIONI ===============
   ============================================================ */

function maybeConstructionEvent(b) {
    if (Math.random() < 0.15) {
        const txt = constructionEventText(b.type);
        addMsg("ai", txt);
        b.turns_left += rand(1, 2); // ritardo lavori
    }
}

function constructionEventText(type) {
    switch(type) {
        case "forge": return "⛓️ Un apprendista si è ferito: la Forgia subirà un ritardo.";
        case "harbor": return "🌊 Una tempesta ha danneggiato i lavori del Porto.";
        case "watchtower": return "🏚️ Una sezione della Torre di Guardia è crollata.";
        case "mercenary_camp": return "⚔️ I mercenari hanno iniziato una rissa, lavori sospesi.";
        case "market": return "💰 Dispute tra mercanti hanno rallentato la costruzione del Mercato.";
        case "monk_clinic": return "🙏 I monaci attendono nuove erbe: lavori rallentati.";
        case "sawmill": return "🌲 Le inondazioni hanno bloccato il cantiere della segheria.";
        case "stone_quarry": return "🪨 Cedimenti nel terreno rallentano lo scavo della cava.";
        case "iron_mine": return "⛏️ Falda instabile: servono puntelli aggiuntivi.";
        case "mint": return "💰 Difetti negli stampi delle monete hanno fermato la zecca.";
        case "barracks": return "⚔️ Reclute indisciplinate rallentano l'addestramento.";
    }
}


/* ============================================================
   ================== EFFETTI EDIFICI COMPLETATI ===============
   ============================================================ */

function applyBuildingEffects(b) {
    // --- Helper per registrare strutture produttive ---
    const addStructure = (listKey, production, label) => {
        registerNewStructure(listKey, production, b, label);
        addMsg("system", `⚙️ Produzione avviata: una nuova ${b.name} è operativa.`);
    };

    logTurnEvent(`Completata la costruzione di: ${b.name}`);

    switch(b.type) {
        // --- AGRICOLTURA & SOPRAVVIVENZA ---
        case "village_well":
            county.health = clamp(county.health + 8);
            factions.peasants += 5;
            break;
        case "wheat_field":
            // Aggiungiamo una "farm" generica alla lista delle strutture
            // Nota: usiamo 'farms' se hai una lista generica, o creiamo un hook
            // Se non hai una lista 'farms' in 'structures', modifichiamo direttamente le risorse base
            // Per semplicità qui aumentiamo la produzione base del territorio se non c'è una struttura specifica
            county.food = clamp(county.food + 10); 
            factions.peasants += 5;
            addMsg("system", "🌾 I nuovi campi aumentano la sicurezza alimentare.");
            break;
        case "dairy_farm":
            county.food = clamp(county.food + 5);
            factions.peasants += 3;
            // Simuliamo produzione aggiuntiva
            if(!county.resources.livestock) county.resources.livestock = 0;
            break;
        case "granary":
            county.security = clamp(county.security + 2);
            // Logica custom: protegge dalla carestia invernale (gestito narrativamente o in eventi futuri)
            factions.peasants += 4;
            break;

        // --- ECONOMIA ---
        case "market":
            county.happy = clamp(county.happy + 8);
            factions.merchants += 8;
            county.gold += 15; // Bonus immediato commercio
            break;
        case "harbor":
            factions.merchants += 10;
            factions.nobility += 2;
            county.gold += 50;
            break;
        case "mint":
            county.gold += 100; // Riserva immediata
            factions.merchants += 5;
            factions.nobility += 2;
            break;
        
        // --- PRODUZIONE RISORSE (STRUTTURE REALI) ---
        case "sawmill":
            addStructure("sawmills", { wood: rand(30, 60) }, "Segheria");
            break;
        case "stone_quarry":
            addStructure("quarries", { stone: rand(25, 50) }, "Cava");
            break;
        case "iron_mine":
            addStructure("mines", { iron: rand(30, 60), copper: rand(10, 20) }, "Miniera");
            break;

        // --- MILITARE ---
        case "watchtower":
            factions.militia += 5;
            county.security = clamp(county.security + 5);
            neighboringCounties.forEach(c => c.aggression = Math.max(0, c.aggression - 8));
            break;
        case "barracks":
            factions.militia += 8;
            adjustPopulation("militia", 10); // Più reclute
            county.security = clamp(county.security + 10);
            break;
        case "mercenary_camp":
            factions.militia += 5;
            factions.clergy -= 5;
            county.security = clamp(county.security + 15); // Molto sicuri ma costosi
            break;
        case "forge":
            factions.burghers += 6;
            factions.militia += 4;
            break;
        case "stone_walls":
            county.security = 100; // Massima sicurezza
            factions.nobility += 10;
            factions.burghers += 5;
            neighboringCounties.forEach(c => c.aggression = Math.max(0, c.aggression - 20));
            addMsg("system", "🛡️ Le mura sono completate! La contea è ora una fortezza.");
            break;

        // --- FEDE ---
        case "chapel":
            factions.clergy += 5;
            county.happy = clamp(county.happy + 3);
            break;
        case "church":
            factions.clergy += 10;
            county.happy = clamp(county.happy + 6);
            county.health = clamp(county.health + 2);
            addStructure("monasteries", { herbs: rand(2,5) }, "Chiesa"); // Produce piccola quantità fede/erbe
            break;
        case "grand_cathedral":
            factions.clergy = 100; // Estasi religiosa
            factions.nobility += 15;
            county.happy = clamp(county.happy + 15);
            addMsg("system", "🔔 Le campane della Cattedrale suonano per la prima volta. Un giorno storico!");
            break;
        case "monk_clinic":
            county.health = clamp(county.health + 15);
            factions.clergy += 8;
            break;

        // --- ISTRUZIONE & SOCIALE ---
        case "school":
            factions.burghers += 10;
            factions.mystics += 5;
            // Simuliamo efficienza: riduce sprechi
            county.gold += 20; 
            break;
        case "library":
            factions.mystics += 15;
            factions.clergy -= 2; // Rivalità sul sapere
            addMsg("system", "📚 La biblioteca attira saggi da ogni dove.");
            break;
        case "theater":
            county.happy = clamp(county.happy + 12);
            factions.nobility += 5;
            factions.peasants += 5;
            break;

        // --- ABITAZIONI ---
        case "cottage":
            adjustPopulation("peasants", 50);
            factions.peasants += 5;
            break;
        case "tenement":
            adjustPopulation("burghers", 150);
            factions.burghers += 10;
            county.health = clamp(county.health - 5);
            break;
        case "noble_estate":
            adjustPopulation("nobility", 20);
            factions.nobility += 10;
            county.happy = clamp(county.happy + 10);
            break;
            
        default:
            addMsg("system", `Costruzione di ${b.type} completata.`);
    }

    // Aggiornamento finale UI e Fazioni
    factionOrder.forEach(f => factions[f] = clamp(factions[f]));
    updateUI();
}


/* ============================================================
   ========== STRUTTURE EVENTI RANDOM (MINIERE, ECC.) ==========
   ============================================================ */

function triggerStructureEvents(options = {}) {
    const { skipUI = false } = options;

    // Crollo miniere
    structures.mines.forEach(m => {
        if (Math.random() < 0.02) {
            m.condition -= 30;
            addMsg("ai", `💥 Crollo nella miniera (${m.x},${m.y}): feriti e produzione ridotta.`);
            county.pop -= rand(1,4);
        }
    });

    // Incendio Segherie
    structures.sawmills.forEach(s => {
        if (Math.random() < 0.015) {
            s.condition -= 40;
            addMsg("ai", `🔥 Incendio nella segheria (${s.x},${s.y}): perdita di legno.`);
            county.resources.wood = Math.max(0, county.resources.wood - rand(20,60));
        }
    });

    // Frane Cave
    structures.quarries.forEach(q => {
        if (Math.random() < 0.01) {
            q.condition -= 20;
            addMsg("ai", `🪨 Frana nella cava (${q.x},${q.y}): lavori sospesi.`);
        }
    });

    // Miracoli Monasteri
    structures.monasteries.forEach(m => {
        if (Math.random() < 0.02) {
            addMsg("ai", `✨ I monaci di (${m.x},${m.y}) hanno guarito dei malati.`);
            county.health = clamp(county.health + 5);
        }
    });

    if (!skipUI) updateUI();
}


/* ============================================================
   =================== EFFETTI SULLE FAZIONI ===================
   ============================================================ */

function structureFactionEffect() {

    structures.mines.forEach(() => {
        factions.nobility += 1;
        factions.militia += 1;
        factions.peasants -= 1;
    });

    structures.sawmills.forEach(() => {
        factions.merchants += 1;
        factions.commons += 1;
        factions.mystics -= 1;
    });

    structures.quarries.forEach(() => {
        factions.burghers += 1;
        factions.nobility -= 1;
    });

    structures.monasteries.forEach(() => {
        factions.clergy += 1;
        factions.merchants -= 1;
    });

    factionOrder.forEach(f => factions[f] = clamp(factions[f]));
}


/* ============================================================
   ==================== CHAT PRIVATA ===========================
   ============================================================ */

function openPrivateChat(key) {
    activePrivateChat = key;
    document.getElementById("private-chat-box").style.display = "block";
    document.getElementById("private-chat-title").innerText =
        "Colloquio con " + getChatName(key);

    loadPrivateChat();
    
    // Se aperto dal modal matrimonio, chiudi il modal e vai alla tab private
    if (document.getElementById("modal-marriage").classList.contains("active")) {
        closeMarriageModal();
        const privateBtn = document.querySelector('.nav-btn[onclick*="tab-private"]');
        switchTab('tab-private', privateBtn);
    }
}

function closePrivateChat() {
    const key = activePrivateChat;
    const factionName = getChatName(key);

    // Nascondi UI
    activePrivateChat = null;
    document.getElementById("private-chat-box").style.display = "none";

    addMsg("system", `Il colloquio con ${factionName} è terminato. Il Conte riflette sulle richieste...`);

    // PROMPT SPECIFICO PER GENERARE AZIONI DI GIOCO
    // Chiediamo all'IA di tradurre la chiacchierata in meccaniche di gioco (Costruzioni, Leggi, ecc.)
    const promptAction = `
    Ho appena finito un colloquio privato con ${factionName} (${factionLabel(key)}).
    
    Basandoti sulla logica del gioco (dove posso costruire edifici come Mercati, Mura, Chiese o promulgare Leggi):
    1. Riassumi in una frase cosa voleva la fazione.
    2. Proponi 3 azioni di gioco concrete che posso fare ora per accontentarli o punirli.
    
    USA IL FORMATO AZIONI STANDARD:
    - **[Nome Azione]**: [Descrizione effetto]
    `;

    callGroq(promptAction, "action");
}

function getChatName(key) {
    const map = {
        nobility:"Lord Emeric (Nobiltà)",
        clergy:"Vescovo Aldebrando (Clero)",
        militia:"Capitano Ronan (Milizia)",
        peasants:"Odric (Contadini)",
        burghers:"Maestro Bernard (Artigiani)",
        merchants:"Ser Lothar (Mercanti)",
        mystics:"Madre Elowen (Mistici)",
        outcasts:"Rasko (Emarginati)",
        auvrey:"Messo di Auvrey",
        falken:"Ambasciatrice di Falken"
    };
    return map[key] || key;
}

function loadPrivateChat() {
    const log = document.getElementById("private-chat-log");
    log.innerHTML = "";
    privateChats[activePrivateChat].forEach(m => addPrivateMsg(m.from, m.text));
}

function addPrivateMsg(type, text) {
    const log = document.getElementById("private-chat-log");
    const div = document.createElement("div");
    div.className = `msg msg-${type}`;
    const time = timestamp();
    div.innerHTML = `<div class="msg-text">${text}</div><div class="msg-meta">${time}</div>`;
    log.appendChild(div);
    log.scrollTop = log.scrollHeight;
}

function sendPrivate() {
    const input = document.getElementById("private-input");
    const text = input.value.trim();
    if (!text) return;
    input.value = "";

    privateChats[activePrivateChat].push({ from:"user", text:text });
    addPrivateMsg("user", text);

    // Call IA (parte 6 gestisce privateDialog)
    callGroqPrivate(activePrivateChat, text);
}


/* ============================================================
   ==================== AGGIORNAMENTO UI =======================
   ============================================================ */

function clearInterfaceLogs() {
    const chatLog = document.getElementById("chat-log");
    if (chatLog) chatLog.innerHTML = "";

    const eventFeed = document.getElementById("event-feed");
    if (eventFeed) eventFeed.innerHTML = '<p class="event-empty">Nessun evento registrato.</p>';

    const adviceFeed = document.getElementById("advice-feed");
    if (adviceFeed) adviceFeed.innerHTML = '<p class="advice-empty">Nessun consiglio registrato.</p>';

    const actionList = document.getElementById("action-list");
    if (actionList) actionList.innerHTML = '<p class="action-empty">Nessuna proposta al momento.</p>';

    const actionPrompt = document.getElementById("action-prompt");
    if (actionPrompt) actionPrompt.innerText = "In attesa di nuovi suggerimenti dalla corte.";
}

/* ===================== SISTEMA FINANZIARIO FAZIONI ===================== */

// 1. CHIEDERE UN PRESTITO (Il Conte riceve Oro, la Fazione perde Ricchezza, Lealtà cala leggermente per il debito morale)
function requestLoan(factionKey) {
    const faction = populationGroups[factionKey];
    const amount = 100; // Prestito standard

    if (faction.wealth < amount) {
        addMsg("system", `❌ I ${factionLabel(factionKey)} non hanno abbastanza oro per prestarti ${amount} monete.`);
        return;
    }

    faction.wealth -= amount;
    county.gold += amount;
    // Il debito abbassa la lealtà perché il Conte perde autorità dipendendo da loro
    factions[factionKey] = Math.max(0, factions[factionKey] - 5); 

    addMsg("system", `💰 Hai ottenuto un prestito di ${amount} oro dai ${factionLabel(factionKey)}. (Lealtà -5)`);
    updateUI();
}

// 2. DONAZIONE (Il Conte perde Oro, la Fazione guadagna Ricchezza, Lealtà sale)
function donateToFaction(factionKey) {
    const amount = 50; // Donazione standard

    if (county.gold < amount) {
        addMsg("system", "❌ Non hai abbastanza oro per fare questa donazione.");
        return;
    }

    county.gold -= amount;
    populationGroups[factionKey].wealth += amount;
    factions[factionKey] = Math.min(100, factions[factionKey] + 8); // Bonus lealtà

    addMsg("system", `🎁 Hai donato ${amount} oro ai ${factionLabel(factionKey)}. La loro lealtà aumenta (+8).`);
    updateUI();
}

// 3. CONFISCA / TASSA STRAORDINARIA (Il Conte prende Oro, la Fazione perde Ricchezza, Lealtà crolla)
function seizeAssets(factionKey) {
    const faction = populationGroups[factionKey];
    const amount = Math.floor(faction.wealth * 0.5); // Prendi il 50% della loro ricchezza

    if (amount < 10) {
        addMsg("system", `I ${factionLabel(factionKey)} non hanno nulla da confiscare.`);
        return;
    }

    faction.wealth -= amount;
    county.gold += amount;
    factions[factionKey] = Math.max(0, factions[factionKey] - 25); // Malus gravissimo
    county.happy = Math.max(0, county.happy - 5); // Malcontento generale

    addMsg("system", `⚖️ Hai confiscato ${amount} oro ai ${factionLabel(factionKey)}. Sono furiosi! (Lealtà -25)`);
    updateUI();
}

function renderPopulationDetails() {
    const grid = document.querySelector('.social-classes-grid'); // O crea un nuovo contenitore
    if(!grid) return;
    
    // Esempio di HTML arricchito per ogni card
    let html = "";
    Object.entries(populationGroups).forEach(([key, data]) => {
        const workforce = Math.floor(data.count * (data.workforceRatio || 0.6));
        const employed = data.employed || 0;
        const unemployed = Math.max(0, workforce - employed);
        const unempPct = workforce > 0 ? Math.round((unemployed / workforce) * 100) : 0;
        
        // Colore stato occupazione
        let jobColor = "#6ada91";
        if (unempPct > 20) jobColor = "#ff9800"; // Disoccupazione media
        if (unempPct > 50) jobColor = "#f44336"; // Disoccupazione alta
        if (employed >= workforce) jobColor = "#2196f3"; // Piena occupazione (Labor shortage)

        html += `
        <div class="social-class-card">
            <div class="social-class-header">
                <span class="social-class-icon">${FACTION_ICONS[key] || '👤'}</span>
                <span class="social-class-name">${factionLabel(key)}</span>
            </div>
            <div class="social-class-stats">
                <div class="social-class-count" style="font-size:1.2em">${data.count}</div>
                <div class="social-class-wealth" style="color:#ffd700">${fmtMoney(data.wealth)} 💰</div>
                
                <div style="margin-top:6px; border-top:1px solid #333; padding-top:4px; font-size:0.75em;">
                    <div style="display:flex; justify-content:space-between;">
                        <span>📚 Istr:</span>
                        <span>${Math.floor(data.literacy)}%</span>
                    </div>
                    <div style="display:flex; justify-content:space-between; color:${jobColor}">
                        <span>⚒️ Occ:</span>
                        <span>${Math.floor((employed/workforce)*100)}%</span>
                    </div>
                    <div style="font-size:0.9em; text-align:right; opacity:0.7">
                        (${unemployed} in cerca)
                    </div>
                </div>
            </div>
        </div>
        `;
    });
    
    grid.innerHTML = html;
}

function updateUI() {
    ensureWorldSystems();
    const summary = updateIndustrySummary();
    document.getElementById("visual-desc").innerText = `"${county.desc}"`;

    // Dentro updateUI()...
    
    const capacity = calculateHousingCapacity();
    const popColor = county.pop > capacity ? "#ff7c7c" : "#fff"; // Rosso se sovraffollato
    
    // Aggiorna il testo della popolazione indicando anche la capacità
    document.getElementById("val-pop").innerHTML = `
        <span style="color:${popColor}">${county.pop}</span> 
        <span style="font-size:0.6em; color:#888;">/ ${capacity} cap.</span>
    `;
    // Visual indicators for changes (pop, gold, food, health)
    (function(){
        const THRESH = 1; // minimum absolute change to show indicator
        const localFmtMoney = (v) => { const n = Number(v) || 0; return n.toFixed(2); };

        function setDelta(id, delta, textFormatter) {
            const el = document.getElementById(id);
            if (!el) return;
            if (Math.abs(delta) < THRESH) { el.innerHTML = ''; el.classList.remove('active','up','down'); return; }
            const up = delta > 0;
            const txt = textFormatter ? textFormatter(delta) : (up ? '+' : '-') + Math.abs(delta);
            const svgUp = '<svg viewBox="0 0 16 16" aria-hidden="true" focusable="false"><path fill="currentColor" d="M8 3l5 6H3z"></path></svg>';
            const svgDown = '<svg viewBox="0 0 16 16" aria-hidden="true" focusable="false"><path fill="currentColor" d="M8 13l-5-6h10z"></path></svg>';
            el.innerHTML = (up ? svgUp : svgDown) + '<span style="margin-left:4px">' + (up ? '+' : '-') + txt + '</span>';
            el.classList.add('active', up ? 'up' : 'down');
            el.classList.remove(up ? 'down' : 'up');
            setTimeout(() => { el.classList.remove('active'); }, 3000);
        }

        // Population (integer)
        setDelta('pop-delta', county.pop - (typeof lastPop === 'number' ? lastPop : county.pop), d => String(Math.abs(d)));
        // Gold (currency)
        setDelta('gold-delta', county.gold - (typeof lastGold === 'number' ? lastGold : county.gold), d => localFmtMoney(Math.abs(d)) );
        // Food (percent points)
        setDelta('food-delta', county.food - (typeof lastFood === 'number' ? lastFood : county.food), d => Math.abs(Math.round(d)) + '%');
        // Health (percent points)
        setDelta('health-delta', county.health - (typeof lastHealth === 'number' ? lastHealth : county.health), d => Math.abs(Math.round(d)) + '%');
    })();

    // Aggiorna gli ultimi valori per il prossimo ciclo
    lastPop = county.pop;
    lastGold = county.gold;
    lastFood = county.food;
    lastHealth = county.health;
    
    // ... resto della funzione

    document.getElementById("val-gold").innerText = fmtMoney(county.gold);

    updateBar("food", county.food);
    updateBar("health", county.health);
    updateBar("happy", county.happy);
    updateBar("stability", calculateStability());

    document.getElementById("land-count").innerText = landOwnership.count;
    document.getElementById("land-nobility").innerText = landOwnership.nobility;
    document.getElementById("land-clergy").innerText = landOwnership.clergy;
    document.getElementById("land-commons").innerText = landOwnership.commons;

    // Aggiorna classi sociali con ricchezza dettagliata
    renderPopulationDetails();

    updateResourceUI();
    updateDiplomacyUI();
    updateFactionImpactUI();
    renderFactionChips();
    updateAssetSummaryUI(summary);
    renderTaxGrid();
    renderLawList();
    updateTaxSummary();
    updateSeasonUI();

    // Update HUD stats
    const season = getSeason();
    document.getElementById('hud-season').textContent = `${season.label} ${worldTime.year}`;
    document.getElementById('hud-gold').textContent = county.gold;
    document.getElementById('hud-pop').textContent = `${county.pop} / ${capacity}`;
    document.getElementById('hud-happy').textContent = county.happy;
    document.getElementById('hud-security').textContent = county.security;

    const turnTag = document.getElementById("chat-turn");
    if (turnTag) turnTag.innerText = `Turno ${county.turn}`;

    updateConstructionUI();
    renderResourceStats();
    renderMarket();
    renderNeedsPanel();
}

function updateDiplomacyUI() {
    // Aggiorna Statistiche Militari
    document.getElementById("mil-soldiers").innerText = populationGroups.militia.count;
    document.getElementById("mil-levies").innerText = warState.leviesCount;
    document.getElementById("mil-power").innerText = calculateMilitaryPower();
    document.getElementById("mil-weapons").innerText = county.resources.weapons || 0;
    
    // Aggiorna Efficienza con colore
    const eff = getArmyEfficiency();
    let effColor = eff > 80 ? "#6ada91" : eff > 40 ? "#ff9800" : "#f44336";
    const effEl = document.getElementById("mil-efficiency");
    effEl.innerText = eff + "%";
    effEl.style.color = effColor;
    
    // Aggiorna testo pulsante
    const mobBtn = document.getElementById("btn-mobilize");
    if (warState.mobilized) {
        mobBtn.innerText = "🏳️ Sciogli la Leva (Torna ai campi)";
        mobBtn.style.background = "#444";
    } else {
        mobBtn.innerText = "🔔 Chiama la Leva (Mobilita Contadini)";
        mobBtn.style.background = "linear-gradient(120deg, #8b0000, #4a0000)";
    }

    // Genera Card Diplomatiche
    const container = document.getElementById("diplomacy-list");
    container.innerHTML = "";

    neighboringCounties.forEach(c => {
        // Calcola stato relazione
        let statusColor = "#aaa";
        let statusText = "Neutrale";
        if (c.relations > 70) { statusColor = "#6ada91"; statusText = "Alleato"; }
        if (c.relations < 30) { statusColor = "#ff7c7c"; statusText = "Ostile"; }
        if (warState.active && warState.enemy === c.key) { statusColor = "#f44336"; statusText = "IN GUERRA"; }

        const div = document.createElement("div");
        div.className = "diplomacy-card";
        if (warState.active && warState.enemy === c.key) div.style.borderColor = "#f44336";

        div.innerHTML = `
            <div style="display:flex; justify-content:space-between;">
                <h3 style="margin:0; color:var(--accent)">${c.name}</h3>
                <span style="color:${statusColor}; font-weight:bold;">${statusText}</span>
            </div>
            <p style="font-size:0.85em; color:#ccc;">${c.description}</p>
            
            <div class="grid-stats" style="grid-template-columns:1fr 1fr 1fr 1fr; gap:5px; margin-bottom:10px;">
                <div class="stat-card" style="padding:5px;">
                    <div class="stat-val" style="font-size:1em;">${c.relations}</div>
                    <div class="stat-sub">Relazione</div>
                </div>
                <div class="stat-card" style="padding:5px;">
                    <div class="stat-val" style="font-size:1em;">${c.power}</div>
                    <div class="stat-sub">Forza</div>
                </div>
                <div class="stat-card" style="padding:5px;">
                    <div class="stat-val" style="font-size:1em;">${c.aggression}</div>
                    <div class="stat-sub">Aggr.</div>
                </div>
                <div class="stat-card" style="padding:5px;">
                    <div class="stat-val" style="font-size:1em;">${c.wealth}</div>
                    <div class="stat-sub">Ricchezza</div>
                </div>
            </div>

            <div class="diplomacy-actions">
                ${renderDiplomacyButtons(c)}
            </div>
        `;
        container.appendChild(div);
    });
}

function renderDiplomacyButtons(neighbor) {
    if (warState.active && warState.enemy === neighbor.key) {
        return `
            <button class="btn-main" style="background:#f44336; color:white; width:100%;" onclick="resolveBattle('${neighbor.key}')">⚔️ ORDINA ATTACCO</button>
            <button class="btn-sec" onclick="sueForPeace('${neighbor.key}')">🏳️ Chiedi Tregua</button>
        `;
    } else {
        return `
            <button class="btn-sec" onclick="sendDiplomaticGift('${neighbor.key}')">🎁 Invia Dono (50 oro)</button>
            <button class="btn-sec" onclick="requestTradeMeeting('${neighbor.key}')">📜 Accordo Commerciale</button>
            <button class="btn-sec" style="border-color:#f44336; color:#f44336;" onclick="declareWar('${neighbor.key}')">⚔️ DICHIARA GUERRA</button>
        `;
    }
}

// Logica Diplomatica (Funzioni di supporto)
function declareWar(key) {
    const target = neighboringCounties.find(c => c.key === key);
    if (!confirm(`Sei sicuro di voler dichiarare guerra alla ${target.name}?`)) return;
    
    warState.active = true;
    warState.enemy = key;
    target.relations = 0; // Crollo relazioni
    target.aggression = 100;
    
    addMsg("system", `📣 <strong>GUERRA!</strong> Hai dichiarato guerra alla ${target.name}. Prepara le truppe!`);
    updateUI();
}

function sueForPeace(key) {
    const target = neighboringCounties.find(c => c.key === key);
    
    // Costo della pace: Oro o Territorio
    const cost = 300;
    if (county.gold < cost) {
        addMsg("system", `Il nemico rifiuta la pace. Chiedono ${cost} oro come riparazioni.`);
        return;
    }
    
    county.gold -= cost;
    warState.active = false;
    warState.enemy = null;
    target.relations = 20; // Tregua fredda
    
    addMsg("system", `🏳️ <strong>PACE FIRMATA.</strong> Abbiamo pagato ${cost} oro di riparazioni.`);
    updateUI();
}

function sendDiplomaticGift(key) {
    const target = neighboringCounties.find(c => c.key === key);
    if (county.gold < 50) return;
    
    county.gold -= 50;
    target.relations = Math.min(100, target.relations + 15);
    addMsg("system", `🎁 Dono inviato alla ${target.name}. Le relazioni migliorano.`);
    updateUI();
}

function requestTradeMeeting(neighborKey) {
    const neighbor = neighboringCounties.find(c => c.key === neighborKey);
    if (!neighbor) return;

    // Costo diplomatico: oro e possibile calo relazioni se rifiuto
    const cost = 20;
    if (county.gold < cost) {
        addMsg("system", "Non hai abbastanza oro per organizzare un incontro diplomatico.");
        return;
    }

    county.gold -= cost;
    addMsg("system", `Hai inviato un emissario alla ${neighbor.name} per discutere accordi commerciali. Costo: ${cost} oro.`);

    // Simula risposta basata su relazioni
    const successChance = Math.min(90, neighbor.relations + 20); // Base 20% + relazioni
    const success = rand(1, 100) <= successChance;

    setTimeout(() => {
        if (success) {
            neighbor.tradeAgreement = true;
            neighbor.relations = Math.min(100, neighbor.relations + rand(5, 15));
            addMsg("system", `🎉 Successo! La ${neighbor.name} accetta l'accordo commerciale. I prezzi nel mercato sono ora ridotti e puoi accedere alle loro merci speciali.`);
        } else {
            neighbor.relations = Math.max(0, neighbor.relations - rand(5, 10));
            addMsg("system", `❌ La ${neighbor.name} rifiuta l'incontro. Le relazioni si deteriorano leggermente.`);
        }
        updateUI();
        renderMarket();
    }, 2000); // Ritardo per simulare il tempo dell'incontro
}

// Sistema di domanda/offerta basato sulle categorie sociali
function calculateMarketDemand() {
    const demand = createEmptyResourceBag();
    const supply = createEmptyResourceBag();
    
    // Nobiltà: domanda lusso, offerta poco
    demand.luxuries += populationGroups.nobility.count * 2;
    demand.arcane += populationGroups.nobility.count * 1;
    
    // Clero: domanda cibo e beni sacri, offerta spirituale
    demand.grain += populationGroups.clergy.count * 3;
    demand.textiles += populationGroups.clergy.count * 1;
    
    // Militia: domanda armi e cibo, offerta protezione
    demand.iron += populationGroups.militia.count * 2;
    demand.grain += populationGroups.militia.count * 4;
    
    // Peasants: offerta cibo e materie prime, domanda beni essenziali
    supply.grain += populationGroups.peasants.count * 1;
    supply.wood += populationGroups.peasants.count * 0.5;
    supply.stone += populationGroups.peasants.count * 0.3;
    demand.textiles += populationGroups.peasants.count * 0.5;
    
    // Burghers: domanda lusso moderato, offerta artigianato
    demand.luxuries += populationGroups.burghers.count * 1;
    supply.textiles += populationGroups.burghers.count * 2;
    supply.iron += populationGroups.burghers.count * 1;
    
    // Merchants: domanda tutto, offerta commercio
    Object.keys(demand).forEach(key => {
        demand[key] += populationGroups.merchants.count * 0.5;
    });
    
    // Mystics: domanda arcane, offerta mistica
    demand.arcane += populationGroups.mystics.count * 3;
    
    // Outcasts: offerta lavoro, domanda sopravvivenza
    supply.wood += populationGroups.outcasts.count * 0.5;
    demand.grain += populationGroups.outcasts.count * 2;
    
    return { demand, supply };
}

// Mobilità sociale
function processSocialMobility() {
    // Borghesi che diventano ricchi -> nobili
    if (populationGroups.burghers.wealth > 200 && populationGroups.burghers.count > 10) {
        const promotions = Math.min(2, Math.floor(populationGroups.burghers.count / 20));
        populationGroups.burghers.count -= promotions;
        populationGroups.nobility.count += promotions;
        populationGroups.nobility.wealth += promotions * 100;
        addMsg("system", `📈 ${promotions} borghesi sono diventati nobili grazie alla loro ricchezza!`);
    }
    
    // Nobili che cadono in disgrazia -> borghesi o outcasts
    if (populationGroups.nobility.wealth < 100 && populationGroups.nobility.count > 5) {
        const demotions = Math.min(1, Math.floor(populationGroups.nobility.count / 10));
        populationGroups.nobility.count -= demotions;
        populationGroups.burghers.count += demotions;
        populationGroups.burghers.wealth += demotions * 50;
        addMsg("system", `📉 ${demotions} nobili sono caduti in disgrazia e sono diventati borghesi.`);
    }
}

/* ===================== FIX DEMOGRAFIA SICURA ===================== */

// Helper per modificare la popolazione senza andare sotto zero o rompere i dati
function safeAdjustPop(groupKey, amount) {
    if (!populationGroups[groupKey]) return 0;
    
    const current = populationGroups[groupKey].count;
    
    // Se stiamo sottraendo (morte/emigrazione)
    if (amount < 0) {
        // Non uccidere mai gli ultimi 10 sopravvissuti (Safeguard anti-estinzione)
        const safeMinimum = 10; 
        const maxLoss = Math.max(0, current - safeMinimum);
        // Applica la perdita ma non oltre il massimo possibile
        const actualLoss = Math.min(Math.abs(amount), maxLoss);
        populationGroups[groupKey].count -= actualLoss;
        return -actualLoss; // Ritorna la variazione reale
    } 
    // Se stiamo aggiungendo (nascita)
    else {
        populationGroups[groupKey].count += amount;
        return amount;
    }
}

// Eventi demografici
function processDemographicEvents() {
    const events = [];
    let totalDeaths = 0;
    let totalBirths = 0;

    // 1. NASCITE (Basate su felicità e cibo)
    // Solo se c'è cibo a sufficienza
    if (county.food > county.pop * 0.8) { 
        const fertilePop = (populationGroups.peasants.count || 0) + (populationGroups.burghers.count || 0);
        // Tasso di natalità moderato (1% - 3%)
        const birthRate = Math.max(0.01, Math.min(0.03, county.happy / 100 * 0.03)); 
        const births = Math.floor(fertilePop * birthRate);
        
        if (births > 0) {
            safeAdjustPop("peasants", births);
            totalBirths += births;
            events.push(`👶 ${births} nuove nascite.`);
        }
    }

    // 2. MORTI (Fame, Malattie, Vecchiaia)
    // Fame: Se il cibo è sotto il 40% del fabbisogno
    if (county.food < county.pop * 0.4) {
        const severity = 1 - (county.food / (county.pop * 0.4)); // 0.0 a 1.0
        // Max 10% di morti per fame per turno (per evitare estinzione istantanea)
        const deathRate = severity * 0.10; 
        
        const peasantDeaths = Math.floor(populationGroups.peasants.count * deathRate);
        const outcastDeaths = Math.floor(populationGroups.outcasts.count * deathRate);
        
        const d1 = safeAdjustPop("peasants", -peasantDeaths);
        const d2 = safeAdjustPop("outcasts", -outcastDeaths);
        
        if ((d1 + d2) < 0) {
            events.push(`💀 Carestia: ${Math.abs(d1+d2)} morti di fame.`);
            logTurnEvent(`Care stia nel regno: ${Math.abs(d1+d2)} morti di fame.`);
        }
        totalDeaths += Math.abs(d1+d2);
    }

    // Malattie (Randomico + Salute)
    if (Math.random() < 0.15 && county.health < 50) {
        const plagueSeverity = (50 - county.health) / 200; // Max 25%
        const deaths = Math.floor(county.pop * plagueSeverity);
        
        // Distribuisci le morti (colpisce più i poveri)
        const d1 = safeAdjustPop("peasants", -Math.floor(deaths * 0.6));
        const d2 = safeAdjustPop("outcasts", -Math.floor(deaths * 0.2));
        const d3 = safeAdjustPop("burghers", -Math.floor(deaths * 0.1));
        const d4 = safeAdjustPop("militia", -Math.floor(deaths * 0.1));

        const actualDeaths = Math.abs(d1+d2+d3+d4);
        if (actualDeaths > 0) {
            events.push(`🦠 Epidemia: ${actualDeaths} vittime.`);
            logTurnEvent(`Epidemia nel regno: ${actualDeaths} vittime.`);
        }
        totalDeaths += actualDeaths;
    }

    // Vecchiaia naturale (Tasso fisso basso 0.5%)
    const naturalRate = 0.005;
    Object.keys(populationGroups).forEach(key => {
        const deaths = Math.floor(populationGroups[key].count * naturalRate);
        safeAdjustPop(key, -deaths);
    });

    // Aggiorna il totale "county.pop" sommando i gruppi reali
    // Questo impedisce al sistema di "perdere il conto"
    recomputePopulation();

    // Mostra eventi solo se significativi
    events.forEach(e => addMsg("system", e));
}

// Sistema di delinquenza basato sulla soddisfazione
function processCrimeAndStability() {
    const events = [];
    
    // Calcola livello di delinquenza basato su felicità, cibo e salute
    const happinessFactor = (100 - county.happy) / 100; // Più felice = meno crimine
    const foodFactor = Math.max(0, (county.pop * 0.5 - county.food) / (county.pop * 0.5)); // Più fame = più crimine
    const healthFactor = (100 - county.health) / 100; // Più malattie = più crimine
    
    const crimeLevel = (happinessFactor + foodFactor + healthFactor) / 3; // Media dei fattori
    const crimeRate = Math.min(0.15, crimeLevel * 0.1); // Max 15% di crimine
    
    if (crimeRate > 0.05) { // Solo se crimine significativo
        // Effetti del crimine
        const crimeIncidents = Math.floor(county.pop * crimeRate);
        const goldLost = Math.floor(crimeIncidents * 2); // Ogni crimine costa ~2 oro
        const stabilityLoss = Math.floor(crimeLevel * 10); // Perdita stabilità
        
        county.gold = Math.max(0, county.gold - goldLost);
        county.happy = Math.max(0, county.happy - stabilityLoss);
        
        events.push(`🚔 ${crimeIncidents} incidenti criminali! Perdita di ${goldLost}💰 e stabilità ridotta.`);
    }
    
    // Mostra eventi criminali
    events.forEach(event => addMsg("system", event));
}

// Sistema di emigrazione
function processEmigration() {
    // Calcolo rischio emigrazione
    const happinessFactor = (100 - county.happy) / 100;
    const foodFactor = Math.max(0, (county.pop * 0.5 - county.food) / (county.pop * 0.5));
    
    // Rischio medio
    const risk = (happinessFactor + foodFactor) / 2;
    
    // Emigrano solo se il rischio è alto (>40%)
    if (risk > 0.4) {
        const rate = Math.min(0.05, risk * 0.1); // Max 5% della pop
        const totalEmigrants = Math.floor(county.pop * rate);
        
        if (totalEmigrants > 0) {
            const e1 = safeAdjustPop("peasants", -Math.floor(totalEmigrants * 0.6));
            const e2 = safeAdjustPop("burghers", -Math.floor(totalEmigrants * 0.3));
            const e3 = safeAdjustPop("outcasts", -Math.floor(totalEmigrants * 0.1));
            
            const actualEmigrants = Math.abs(e1+e2+e3);
            
            if (actualEmigrants > 0) {
                addMsg("system", `🏃 ${actualEmigrants} abitanti hanno abbandonato la contea.`);
                recomputePopulation(); // Ricalcola subito
            }
        }
    }
}

// Calcola livello di stabilità sociale
function calculateStability() {
    // La stabilità è inversamente proporzionale alla delinquenza
    const happinessFactor = county.happy / 100; // Più felice = più stabile
    const foodFactor = Math.min(1, county.food / (county.pop * 0.5)); // Più cibo = più stabile
    const healthFactor = county.health / 100; // Più salute = più stabile
    const housingFactor = Math.min(1, calculateHousingCapacity() / county.pop); // Più spazio = più stabile
    
    const stability = (happinessFactor + foodFactor + healthFactor + housingFactor) / 4;
    return Math.floor(stability * 100);
}

// Aggiorna ricchezze delle categorie
function updateCategoryWealth() {
    // === ECONOMIA MEDIEVALE REALISTICA ===
    // Gerarchia di ricchezza: Nobiltà > Mercanti/Clero > Borghesi > Milizia > Contadini > Emarginati > Mistici
    
    // CONTADINI (Peasants): I più poveri, vivono di sussistenza
    // Guadagnano pochissimo perché la maggior parte del raccolto va ai signori
    const peasantIncome = Math.floor(
        (populationGroups.peasants.count * 0.08) + // Minimo di sussistenza: 0.08 oro a testa
        ((county.resources.grain || 0) * 0.005) + // Solo 0.5% del grano (il resto va ai nobili)
        ((county.resources.livestock || 0) * 0.01) // 1% del bestiame
    );
    populationGroups.peasants.wealth += peasantIncome;
    
    // ARTIGIANI (Burghers): Classe media urbana, vendono i loro manufatti
    // Guadagnano dalla vendita di beni artigianali
    const burghersBaseIncome = populationGroups.burghers.count * 1.5; // Reddito fisso discreto
    const textilesProfit = (county.resources.textiles || 0) * 0.25; // 25% profitto sui tessuti
    const ironProfit = (county.resources.iron || 0) * 0.3; // 30% profitto sul ferro lavorato
    const copperProfit = (county.resources.copper || 0) * 0.35; // 35% profitto sul rame
    const burghersIncome = Math.floor(burghersBaseIncome + textilesProfit + ironProfit + copperProfit);
    populationGroups.burghers.wealth += burghersIncome;
    
    // MERCANTI (Merchants): Ricchi commercianti, controllano il commercio
    // Guadagnano da OGNI transazione commerciale + beni di lusso
    const merchantsBaseIncome = populationGroups.merchants.count * 3; // Reddito base alto
    const tradingFees = (seasonalTransactions.marketSales + seasonalTransactions.marketPurchases) * 0.12; // 12% su tutte le transazioni
    const luxuriesMonopoly = (county.resources.luxuries || 0) * 0.4; // 40% sui beni di lusso (alto margine!)
    const specialTradeBonus = seasonalTransactions.specialPurchases * 0.2; // 20% sul commercio speciale
    const merchantsIncome = Math.floor(merchantsBaseIncome + tradingFees + luxuriesMonopoly + specialTradeBonus);
    populationGroups.merchants.wealth += merchantsIncome;
    
    // MILIZIA (Militia): Soldati pagati dalla contea
    // Stipendio fisso modesto
    const militiaWage = 1.2; // 1.2 oro per soldato (ridotto, erano poveri!)
    const militiaIncome = Math.floor(populationGroups.militia.count * militiaWage);
    populationGroups.militia.wealth += militiaIncome;
    
    // NOBILTÀ (Nobility): I più ricchi, vivono di rendite fondiarie
    // Guadagnano dalle terre e dai privilegi feudali
    const nobilityLandRent = landOwnership.nobility * 8; // 8 oro per unità di terra (alto!)
    const feudalDues = Math.floor(county.gold * 0.015); // 1.5% dell'oro statale
    const grainTithes = (county.resources.grain || 0) * 0.03; // 3% del grano (decime feudali)
    const nobilityIncome = Math.floor(nobilityLandRent + feudalDues + grainTithes + (populationGroups.nobility.count * 15));
    populationGroups.nobility.wealth += nobilityIncome;
    
    // CLERO (Clergy): Ricchi grazie a decime e proprietà ecclesiastiche
    // Guadagnano da terre della chiesa e offerte
    const clergyLandRent = landOwnership.clergy * 6; // 6 oro per unità di terra ecclesiastica
    const tithesIncome = Math.floor(county.gold * 0.012); // 1.2% decime
    const offerings = Math.floor(county.pop * 0.015); // Offerte dai fedeli
    const clergyIncome = Math.floor(clergyLandRent + tithesIncome + offerings + (populationGroups.clergy.count * 8));
    populationGroups.clergy.wealth += clergyIncome;
    
    // MISTICI (Mystics): Ai margini della società, vivono di carità e servizi
    // Guadagnano poco da pozioni e rituali
    const herbsSales = (county.resources.herbs || 0) * 0.08; // 8% vendita erbe
    const arcaneSales = (county.resources.arcane || 0) * 0.15; // 15% servizi arcani
    const mysticsIncome = Math.floor(herbsSales + arcaneSales + (populationGroups.mystics.count * 1));
    populationGroups.mystics.wealth += mysticsIncome;
    
    // EMARGINATI (Outcasts): I più poveri, vivono di espedienti
    // Quasi nessun reddito legale
    const outcastsIncome = Math.floor(populationGroups.outcasts.count * 0.15); // Pochissimo
    // Bonus dal crimine se la sicurezza è bassa
    if (county.security < 50) {
        const crimeBonus = Math.floor((50 - county.security) * populationGroups.outcasts.count * 0.02);
        populationGroups.outcasts.wealth += crimeBonus;
    }
    populationGroups.outcasts.wealth += outcastsIncome;
    
    // Previeni ricchezze negative
    Object.keys(populationGroups).forEach(key => {
        populationGroups[key].wealth = Math.max(0, populationGroups[key].wealth);
    });
}

function updateCategoryWealthBasedOnJobs() {
    // Salari base per tipo di lavoro
    const WAGES = {
        peasants: 0.5,   // Basso salario agricolo
        burghers: 2.5,   // Salario artigiano
        clergy: 2.0,     // Salario insegnante/prete
        nobility: 5.0,   // Rendita amministrativa
        // ...
    };

    Object.entries(populationGroups).forEach(([key, data]) => {
        const wage = WAGES[key] || 1;
        const incomeFromJobs = (data.employed || 0) * wage;
        
        // Aggiungi al wealth esistente
        data.wealth += incomeFromJobs;
        
        // Sussistenza disoccupati (costa ricchezza o crea povertà)
        const workforce = Math.floor(data.count * (data.workforceRatio || 0.6));
        const unemployed = Math.max(0, workforce - (data.employed || 0));
        
        if (unemployed > 0) {
            data.wealth -= unemployed * 0.2; // Costo della vita senza salario
        }
        
        data.wealth = Math.max(0, data.wealth); // Mai sotto zero
    });
}

function ensureNeighborResources(countyRef) {
    if (!countyRef.resources) {
        countyRef.resources = {
            grain: rand(80, 160),
            wood: rand(60, 120),
            stone: rand(50, 110),
            iron: rand(30, 80),
            gold: rand(40, 120),
            textiles: rand(20, 60)
        };
    }
    return countyRef.resources;
}

function simulateNeighborEconomy(countyRef, options = {}) {
    const { silent = false } = options;
    ensureNeighborResources(countyRef);
    const production = {
        grain: Math.max(20, Math.floor(countyRef.land * 1.2 + rand(5, 20))),
        wood: Math.max(10, Math.floor(countyRef.land * 0.8 + rand(4, 12))),
        stone: Math.max(6, Math.floor(countyRef.land * 0.5 + rand(2, 8))),
        iron: Math.max(4, Math.floor(countyRef.power * 0.4 + rand(1, 6))),
        textiles: Math.max(3, Math.floor(countyRef.wealth * 0.25 + rand(1, 4)))
    };
    const consumption = {
        grain: Math.max(25, Math.floor(countyRef.power * 0.6 + rand(5, 15))),
        wood: Math.max(12, Math.floor(countyRef.land * 0.6 + rand(3, 10))),
        stone: Math.max(8, Math.floor(countyRef.land * 0.4 + rand(1, 6))),
        iron: Math.max(6, Math.floor(countyRef.power * 0.25 + rand(0, 4))),
        gold: Math.max(10, Math.floor(countyRef.wealth * 0.3 + rand(2, 8))),
        textiles: Math.max(4, Math.floor(countyRef.wealth * 0.2 + rand(1, 4)))
    };

    Object.entries(production).forEach(([key, value]) => {
        countyRef.resources[key] = (countyRef.resources[key] || 0) + value;
    });

    const deficits = [];
    Object.entries(consumption).forEach(([key, value]) => {
        const current = countyRef.resources[key] || 0;
        const final = current - value;
        if (final < 0) {
            deficits.push(key);
            countyRef.resources[key] = 0;
        } else {
            countyRef.resources[key] = final;
        }
    });

    if (deficits.length) {
        countyRef.wealth = clamp((countyRef.wealth || 50) - deficits.length * 2);
        countyRef.relations = Math.max(0, countyRef.relations - deficits.length * 2);
        countyRef.aggression = Math.min(100, countyRef.aggression + deficits.length * 3);
        if (!silent) {
            addMsg("system", `🌫️ ${countyRef.name} è in crisi (${deficits.join(", ")}). Le relazioni peggiorano.`);
        }
    } else {
        countyRef.wealth = clamp((countyRef.wealth || 50) + 1);
        countyRef.relations = Math.min(100, countyRef.relations + 1);
        countyRef.aggression = Math.max(0, countyRef.aggression - 1);
        if (!silent && Math.random() < 0.15) {
            addMsg("system", `${countyRef.name} registra un avanzo commerciale e potrebbe cercare accordi.`);
        }
    }

    if (countyRef.aggression > 80 && !silent) {
        addMsg("system", `⚠️ ${countyRef.name} accumula truppe al confine: l'economia li spinge alla guerra.`);
    }

    countyRef.lastEconomy = { production, consumption, deficits };
}

function processNeighborEconomies(options = {}) {
    const { silent = false } = options;
    neighboringCounties.forEach(neigh => simulateNeighborEconomy(neigh, { silent }));
}

// Arrotonda a 2 cifre decimali (es. 45.67%)
function fmtPct(value) {
    if (value === undefined || value === null) return "0.00%";
    // Se il valore è 0-1 (es. 0.5), lo moltiplichiamo per 100
    // Se è già 0-100, lo usiamo direttamente.
    // Nel tuo codice usi spesso valori 0-100, quindi assumiamo quello.
    return parseFloat(value).toFixed(2) + "%";
}

// Versione per numeri 0-1 (es. needs calculation returns 0.85)
function fmtPctFrac(value) {
    return (value * 100).toFixed(2) + "%";
}

function updateBar(id,val){
    const bar = document.getElementById(`bar-${id}`);
    const txt = document.getElementById(`txt-${id}`);
    bar.style.width = val + "%";
    txt.innerText = parseFloat(val).toFixed(2) + "%";
}

function renderNeedsPanel() {
    const container = document.getElementById("needs-list-container");
    if (!container) return;

    // Se non ci sono dati (inizio gioco)
    if (!lastNeedsReport || Object.keys(lastNeedsReport).length === 0) {
        container.innerHTML = '<div class="save-empty">I dati sui consumi appariranno qui dopo il prossimo cambio di stagione.</div>';
        return;
    }

    let html = "";
    
    // Ordine standard fazioni
    const order = ["nobility", "clergy", "militia", "burghers", "merchants", "peasants", "mystics", "outcasts"];

    order.forEach(key => {
        const data = lastNeedsReport[key];
        if (!data) return;

        // Recuperiamo il nome leggibile
        const label = factionLabel(key);
        
        // Colore ricchezza
        const wealthColor = data.wealth < 20 ? "#ff7c7c" : "#ffd700";

        // Avvisi critici
        let warningHtml = "";
        if (data.mainIssue && data.mainIssue !== "Nessuna") {
            warningHtml = `<div class="need-warning">⚠️ ${data.mainIssue} (${data.status})</div>`;
        }

        html += `
            <div class="need-entry">
                <div class="need-entry-header">
                    <span>${label}</span>
                    <span style="color:${wealthColor}">💰 ${data.wealth} oro</span>
                </div>
                
                <div class="need-bars-container">
                    <div class="need-bar-row">
                        <span style="width:60px">Primari</span>
                        <div class="need-track">
                            <div class="need-fill fill-prim" style="width: ${data.primary}%"></div>
                        </div>
                        <span style="width:45px; text-align:right;">${fmtPct(data.primary)}</span>
                    </div>
                    
                    <div class="need-bar-row">
                        <span style="width:60px">Secondari</span>
                        <div class="need-track">
                            <div class="need-fill fill-sec" style="width: ${data.secondary}%"></div>
                        </div>
                        <span style="width:45px; text-align:right;">${fmtPct(data.secondary)}</span>
                    </div>
                </div>
                ${warningHtml}
            </div>
        `;
    });

    container.innerHTML = html;
}

async function generateSeasonStory() {
    // 1. Setup UI Modale (Feedback visivo immediato)
    const modal = document.getElementById("modal-chronicle");
    const body = document.getElementById("chronicle-body");
    const titleDate = document.getElementById("chronicle-date");
    
    if (modal) modal.classList.add("active");
    if (titleDate) titleDate.innerText = `Anno ${worldTime.year}, ${getSeason().label}`;
    if (body) body.innerHTML = `
        <div class="loading-story">
            <span class="scribe-icon">✍️</span>
            <p>Il Mastrocronista sta osservando il regno per scrivere le cronache...</p>
        </div>`;

    if (!ensureApiKey()) {
        body.innerHTML = "<p>Chiave API mancante. Impossibile scrivere la storia.</p>";
        return;
    }

    // 2. CALCOLO DEL "TONO" REALE (Logica rigida anti-allucinazione)
    let realmStatus = "NEUTRO";
    let prosperityDesc = "";
    
    // Dati attuali
    const foodStock = county.food; 
    const happiness = county.happy;
    const gold = county.gold;
    
    // Verifica se c'è una vera crisi alimentare nei dati dei bisogni
    // (Se lastNeedsReport è vuoto o non ha "DISPERATO", non c'è carestia vera)
    const isStarving = (lastNeedsReport && Object.values(lastNeedsReport).some(r => r.status === "DISPERATO"));

    // LOGICA DI PRIORITÀ: I fatti numerici vincono sulla fantasia dell'IA
    if (isStarving || foodStock < 20) {
        realmStatus = "CRISI NERA";
        prosperityDesc = "C'è una carestia reale. Il popolo soffre la fame e la disperazione cresce.";
    } else if (foodStock > 80 && happiness > 60 && gold > 300) {
        realmStatus = "ETÀ DELL'ORO";
        prosperityDesc = "I granai traboccano, i commerci fioriscono e il popolo è felice. Regna la pace.";
    } else if (foodStock > 40 && happiness > 45) {
        realmStatus = "STABILE";
        prosperityDesc = "La vita scorre tranquilla. Non ci sono disastri, né carestie, né pestilenze in corso.";
    } else {
        realmStatus = "DIFFICILE";
        prosperityDesc = "Tempi duri. Si tira la cinghia, ma il regno resiste senza catastrofi.";
    }

    // 3. Costruzione Prompt
    const eventsList = currentTurnEvents.length > 0 ? currentTurnEvents.join("\n- ") : "Nessun evento maggiore, la stagione è passata in tranquillità.";
    
    const systemPrompt = `
    SEI IL MASTROCRONISTA DEL REGNO.
    Scrivi un breve resoconto narrativo (max 80-100 parole) per l'ultima stagione.

    === STATO REALE OBBLIGATORIO: ${realmStatus} ===
    DATI DI FATTO: ${prosperityDesc}
    
    EVENTI ACCADUTI REALMENTE:
    - ${eventsList}

    REGOLE FERREE (Se le violi il gioco si rompe):
    1. **COERENZA**: Se lo stato è "STABILE" o "ETÀ DELL'ORO", è **VIETATO** inventare carestie, pestilenze, morti o disastri.
    2. **DESCRIZIONE**: 
       - Se è "ETÀ DELL'ORO": Descrivi banchetti, mercati pieni, canti nei campi.
       - Se è "STABILE": Descrivi la serena routine quotidiana.
    3. **STILE**: Usa un tono da cronaca medievale. Non iniziare sempre con "Il sole sorge".
    4. Se non ci sono eventi specifici, celebra la buona amministrazione del Conte (o lamentati delle tasse se lo stato è DIFFICILE).
    `;

    try {
        const resp = await fetch("https://api.groq.com/openai/v1/chat/completions", {
            method: "POST",
            headers: {
                "Content-Type":"application/json",
                "Authorization":"Bearer " + apiKey
            },
            body: JSON.stringify({
                model: "llama-3.1-8b-instant",
                temperature: 0.6, // Temperatura bassa per ridurre le allucinazioni
                messages: [{ role: "system", content: systemPrompt }]
            })
        });

        const data = await resp.json();
        const story = data.choices[0].message.content;

        // 4. VISUALIZZAZIONE E SALVATAGGIO (Il Fix per non perdere la storia)
        
        // A) Mostra nel Modale (Formattato)
        const formattedStory = story.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        body.innerHTML = `<p>${formattedStory}</p>`;

        // B) Salva nella Chat Principale (Così rimane nello storico scorribile quando chiudi il modale)
        const chatLog = document.getElementById("chat-log");
        const narrativeDiv = document.createElement("div");
        narrativeDiv.className = "msg-scene"; // Usa lo stile esistente per la narrativa
        // Aggiungiamo un bordo dorato specifico per le cronache stagionali
        narrativeDiv.style.borderLeft = "4px solid #d4af37"; 
        narrativeDiv.innerHTML = `<strong>📜 Cronache di ${getSeason().label} ${worldTime.year}</strong><br><br>${formattedStory}`;
        chatLog.appendChild(narrativeDiv);
        chatLog.scrollTop = chatLog.scrollHeight;

        // C) Salva nella memoria dell'IA (Così si ricorda cosa è successo nel prossimo turno)
        publicChatHistory.push({ role: "assistant", content: `[CRONACA ${worldTime.year}]: ${story}` });

    } catch (e) {
        body.innerHTML = `<p>Il cronista non riesce a scrivere (Errore: ${e.message})</p>`;
        console.error(e);
    }
}

function refreshAllStats() {
    // Calcola sommari senza modificare i dati (dry run)
    updateIndustrySummary(); 
    calculateResourceStats(); 
    calculateHousingCapacity();
    // Forza l'aggiornamento UI
    updateUI(); 
}

async function triggerStartupNarrative(isNewGame) {
    const chatLog = document.getElementById("chat-log");
    
    // Messaggio di caricamento
    const loadingDiv = document.createElement("div");
    loadingDiv.className = "msg-system";
    loadingDiv.innerHTML = "<em>Il cronista sta rileggendo le pergamene...</em>";
    loadingDiv.id = "startup-loader";
    chatLog.appendChild(loadingDiv);

    // Costruiamo il contesto per l'IA
    const ctx = generateDeepContext(); // Usa la funzione esistente che include guerra e risorse
    
    let prompt = "";
    if (isNewGame) {
        prompt = `
        SEI IL NARRATORE. È l'inizio di una nuova partita (Anno ${worldTime.year}).
        Il giocatore è il nuovo Conte ${heroName}.
        Descrivi brevemente l'atmosfera della contea basandoti su questi dati iniziali:
        ${ctx}
        Saluta il Conte e spiegagli la situazione in 2 frasi evocative.
        `;
    } else {
        prompt = `
        SEI IL NARRATORE. Il giocatore ha appena caricato la partita (Anno ${worldTime.year}).
        Riassumi DOVE ERAVAMO RIMASTI basandoti su questi dati attuali:
        ${ctx}
        
        FOCUS CRUCIALE:
        - Se warState.active è true, RICORDA CHE SIAMO IN GUERRA contro ${warState.enemy}.
        - Se c'è carestia, ricordalo.
        - Concludi con "Bentornato, mio Signore. I vostri ordini?"
        `;
    }

    try {
        // Chiamata diretta all'API (simile a callGroq ma one-shot)
        const resp = await fetch("https://api.groq.com/openai/v1/chat/completions", {
            method: "POST",
            headers: { "Content-Type":"application/json", "Authorization":"Bearer " + apiKey },
            body: JSON.stringify({
                model: "llama-3.1-8b-instant",
                temperature: 0.7,
                messages: [{ role: "system", content: prompt }]
            })
        });
        
        const data = await resp.json();
        const text = data.choices[0].message.content;

        // Rimuovi loader e aggiungi messaggio
        const loader = document.getElementById("startup-loader");
        if(loader) loader.remove();
        
        addMsg("ai", text); // Usa la tua funzione standard per aggiungere messaggi

        // Aggiungi alla memoria dell'IA per mantenere il contesto
        publicChatHistory.push({ role: "assistant", content: text });

    } catch (e) {
        console.error(e);
        if(document.getElementById("startup-loader")) document.getElementById("startup-loader").remove();
        addMsg("system", "Bentornato, Conte. (Impossibile recuperare la cronaca narrativa).");
    }
}

function closeChronicleModal() {
    document.getElementById("modal-chronicle").classList.remove("active");
}

/* ============================================================
   ==================== INVIO MESSAGGI PUBBLICI =================
   ============================================================ */

/* ============================================================
   ========== EVENTI POSITIVI CASUALI (BILANCIAMENTO) ==========
   ============================================================ */

function triggerPositiveEvents() {
    // Probabilità base di eventi positivi: 30% per turno
    if (Math.random() > 0.3) return;
    
    const events = [
        // Eventi di felicità generale
        {
            condition: () => county.happy < 80,
            trigger: () => {
                county.happy = Math.min(100, county.happy + 5);
                const events = [
                    "🎭 Una compagnia di giullari visita la contea. Il popolo ride di cuore!",
                    "🎪 Una fiera ambulante porta gioia e mercanzia esotica.",
                    "☀️ Il bel tempo porta una stagione di raccolti abbondanti e sorrisi.",
                    "🎵 Un trovatore compone una ballata in onore della contea. Tutti cantano!",
                    "🏺 Viene scoperta un'antica fonte di acqua pura. Benedizione!",
                    "🌸 I giardini del castello fioriscono magnificamente. Un buon presagio!"
                ];
                addMsg("system", events[Math.floor(Math.random() * events.length)]);
            }
        },
        // Eventi di crescita economica
        {
            condition: () => county.gold < 500,
            trigger: () => {
                const bonus = Math.floor(50 + Math.random() * 100);
                county.gold += bonus;
                county.happy = Math.min(100, county.happy + 3);
                const events = [
                    `💰 Un mercante generoso dona ${bonus} oro per le opere pie!`,
                    `⛏️ I minatori trovano una vena ricca! +${bonus} oro dalle miniere.`,
                    `📦 Un carico di merci preziose arriva inaspettato. +${bonus} oro.`,
                    `🎁 Un nobile in visita lascia doni generosi: ${bonus} oro!`
                ];
                addMsg("system", events[Math.floor(Math.random() * events.length)]);
            }
        },
        // Eventi di salute
        {
            condition: () => county.health < 80,
            trigger: () => {
                county.health = Math.min(100, county.health + 7);
                county.happy = Math.min(100, county.happy + 2);
                const events = [
                    "🌿 Un guaritore errante distribuisce rimedi efficaci. La salute migliora!",
                    "⛪ I monaci pregano per la salute del popolo. Le malattie regrediscono!",
                    "🍃 Le erbe di stagione hanno proprietà curative straordinarie.",
                    "💊 Un alchimista scopre una nuova cura per le febbri comuni!"
                ];
                addMsg("system", events[Math.floor(Math.random() * events.length)]);
            }
        },
        // Eventi che migliorano le fazioni
        {
            condition: () => true,
            trigger: () => {
                const factionKeys = Object.keys(factions);
                const randomFaction = factionKeys[Math.floor(Math.random() * factionKeys.length)];
                factions[randomFaction] = Math.min(100, factions[randomFaction] + 5);
                county.happy = Math.min(100, county.happy + 2);
                
                const eventsMap = {
                    nobility: "👑 Un torneo cavalleresco rinforza l'orgoglio nobiliare!",
                    clergy: "✝️ Una reliquia sacra viene donata alla chiesa. Il clero gioisce!",
                    militia: "⚔️ Le truppe vincono un'esercitazione. Il morale sale!",
                    peasants: "🌾 Un raccolto eccezionale riempie i granai dei contadini!",
                    burghers: "🔨 Gli artigiani completano un'opera magistrale. Grande orgoglio!",
                    merchants: "🛒 I mercanti concludono affari vantaggiosi. Prosperità!",
                    mystics: "🔮 I saggi prevedono un futuro luminoso per la contea!",
                    outcasts: "🎭 Gli emarginati ottengono un atto di giustizia. Gratitudine!"
                };
                
                addMsg("system", eventsMap[randomFaction] || `I ${factionLabel(randomFaction)} sono più contenti. (+5 Lealtà)`);
            }
        },
        // Eventi di risorse bonus
        {
            condition: () => true,
            trigger: () => {
                const resources = ['grain', 'wood', 'stone', 'iron'];
                const res = resources[Math.floor(Math.random() * resources.length)];
                const amount = Math.floor(20 + Math.random() * 40);
                county.resources[res] = (county.resources[res] || 0) + amount;
                
                const eventsMap = {
                    grain: `🌾 Un raccolto spontaneo dona ${amount} unità di grano!`,
                    wood: `🌲 Alberi caduti forniscono ${amount} legno stagionato!`,
                    stone: `🪨 Scoperta una cava abbandonata con ${amount} pietre!`,
                    iron: `⛏️ Un vecchio deposito rivela ${amount} unità di ferro!`
                };
                
                addMsg("system", eventsMap[res]);
            }
        }
    ];
    
    // Filtra eventi che soddisfano le condizioni
    const validEvents = events.filter(e => e.condition());
    
    // Attiva un evento casuale tra quelli validi
    if (validEvents.length > 0) {
        const event = validEvents[Math.floor(Math.random() * validEvents.length)];
        event.trigger();
        updateUI();
    }
}

/* ============================================================
   ==================== PROGRESSIONE STAGIONE =================
   ============================================================ */

function progressSeason(options = {}) {
    const { silent = false } = options;
    currentTurnEvents = [];
    ensureWorldSystems();
    county.turn++;
    
    const turnTag = document.getElementById("chat-turn");
    if (turnTag) turnTag.innerText = `Anno ${worldTime.year} - ${getSeason().label}`;

    // Snapshot Iniziale
    const startSnapshot = captureResourceSnapshot();
    const startGold = county.gold;
    const startHappy = county.happy;
    const budget = calculateSeasonalBudget();

    // Reset transazioni stagionali
    seasonalTransactions = {
        marketPurchases: 0,
        marketSales: 0,
        specialPurchases: 0,
        taxes: 0,
        maintenance: 0
    };

    // --- ELABORAZIONE TURNO ---
    advanceSeason(null, { silent: true }); // Stagione avanza silenziosamente
    
    processLifeEvents(); 
    
    // 1. Calcola dinamiche lavorative (PRIMA della produzione)
    calculateLaborAndEducation(); 
    
    // 1.5 Aggiorna ricchezza (Salari) - Modifica updateCategoryWealth per usare i salari
    updateCategoryWealthBasedOnJobs(); 
    
    // 1.5. Produzione Bellica (Prima della produzione normale)
    processWarProduction();
    
    // 2. CICLO DI PRODUZIONE (Sostituisce applyProduction)
    const productionReport = processProductionChains();

    // 3. Gestione Carenze (Feedback all'IA)
    if (productionReport.shortages.length > 0) {
        logTurnEvent(`⚠️ Produzione rallentata per mancanza di materie prime: ${productionReport.shortages.join(', ')}.`);
    }

    // 4. Consumo (Bisogni e Povertà)
    processPopNeedsSystem(null, { silent: silent });
    
    // 1. CALCOLO ENTRATE (Tasse Dettagliate)
    detailedBudget.income = { taxes_nobility:0, taxes_burghers:0, taxes_peasants:0, taxes_other:0, trade_export:0, production_mint:0 };
    
    // Tasse (Versione Dettagliata)
    const taxPolicyRef = ensureTaxPolicy(null);
    TAX_CATEGORIES.forEach(cat => {
        const pop = populationGroups[cat.key].count;
        const wealth = populationGroups[cat.key].wealth; // Ricchezza del gruppo
        // Calcolo basato sulla ricchezza reale del gruppo, non solo sulla popolazione
        // Se il gruppo è povero, le tasse rendono 0
        const baseTaxable = Math.min(wealth, pop * cat.wealthFactor); 
        
        const percent = taxPolicyRef[cat.key];
        const income = Math.floor(baseTaxable * (percent / 100));
        
        // Sottrai oro al gruppo
        populationGroups[cat.key].wealth = Math.max(0, populationGroups[cat.key].wealth - income);
        
        // Registra entrata
        if(cat.key === 'nobility') detailedBudget.income.taxes_nobility += income;
        else if(cat.key === 'burghers') detailedBudget.income.taxes_burghers += income;
        else if(cat.key === 'peasants') detailedBudget.income.taxes_peasants += income;
        else detailedBudget.income.taxes_other += income;
    });

    // Entrate da Commercio (Vendite Mercato)
    detailedBudget.income.trade_export = seasonalTransactions.marketSales;
    
    // Entrate da Zecca (Se esiste edificio 'mint')
    const mints = buildings.filter(b => b.type === 'mint' && b.stage === 'complete').length;
    detailedBudget.income.production_mint = mints * 50;

    const totalIncome = Object.values(detailedBudget.income).reduce((a,b)=>a+b,0);
    county.gold += totalIncome;

    // 2. CALCOLO USCITE (Spese Dettagliate)
    const upkeep = calculateDetailedUpkeep();
    
    // Stipendi Milizia (pagati dal tesoro della contea)
    const militiaWages = Math.floor((populationGroups.militia?.count || 0) * 1.2);
    
    // Costo Leggi Attive
    let lawCostGold = 0;
    activeLaws.forEach(lawKey => {
        const law = getLawDefinition(lawKey);
        if (law && law.upkeepCost) lawCostGold += law.upkeepCost;
        // Gestione consumo risorse fisiche (es. Grano per legge Pane)
        if (law && law.consumeResource) {
            for (let res in law.consumeResource) {
                county.resources[res] = Math.max(0, (county.resources[res] || 0) - law.consumeResource[res]);
            }
        }
    });

    detailedBudget.expenses = {
        upkeep_military: upkeep.military + militiaWages, // Include stipendi soldati
        upkeep_civil: upkeep.civil,
        upkeep_court: upkeep.court,
        upkeep_infrastructure: upkeep.infrastructure,
        welfare_laws: lawCostGold,
        import_costs: seasonalTransactions.marketPurchases
    };

    const totalExpense = Object.values(detailedBudget.expenses).reduce((a,b)=>a+b,0);
    
    // Applicazione Spese
    county.gold -= totalExpense;
    detailedBudget.net = totalIncome - totalExpense;

    // Bancarotta? - PENALITÀ RIDOTTE
    if (county.gold < 0) {
        addMsg("system", "💸 <strong>BANCAROTTA!</strong> Il tesoro è vuoto. Le truppe disertano e le strutture crollano.");
        county.gold = 0;
        county.security = Math.max(0, county.security - 5); // Era -10
        county.happy = Math.max(0, county.happy - 5); // Era -10
    }
    
    // Eventi vari
    processBuildings();
    triggerStructureEvents({ skipUI: true });
    structureFactionEffect();
    processNeighborEconomies({ silent: true });
    
    // NUOVO: Eventi Positivi Casuali per bilanciare
    if (!silent) triggerPositiveEvents();

    // Crescita Demografica - CONDIZIONI MIGLIORATE
    let popGrowth = 0;
    if (county.food > 40 && county.health > 30 && county.happy > 25) { // Soglie abbassate
        popGrowth = Math.floor(county.pop * 0.015); // 1.5% crescita annuale
    } else if (county.food < 15 || county.health < 15 || county.happy < 15) { // Soglie abbassate
        popGrowth = -Math.floor(county.pop * 0.008); // 0.8% decrescita (era 1%)
    }
    county.pop = Math.max(100, county.pop + popGrowth); // Minimo 100 pop
    if (popGrowth > 0) {
        addMsg("system", `👶 La popolazione cresce di ${popGrowth} anime grazie alla prosperità.`);
        county.happy = Math.min(100, county.happy + 1); // NUOVO: Bonus felicità per crescita
    } else if (popGrowth < 0) {
        addMsg("system", `💀 La popolazione diminuisce di ${Math.abs(popGrowth)} anime a causa delle difficoltà.`);
    }

    // Effetti di Guerra
    if (warState.mobilized) {
        // Penalità economica per la leva: meno braccia nei campi
        // Riduciamo la produzione di grano simulata
        county.resources.grain = Math.floor(county.resources.grain * 0.6); 
        addMsg("system", "📉 I raccolti soffrono a causa della mancanza di contadini (Leva attiva).");
    }

    if (warState.active) {
        // Costo della guerra
        const warCost = (populationGroups.militia.count * 2) + (warState.leviesCount * 1);
        county.gold -= warCost;
        detailedBudget.expenses.upkeep_military += warCost;
        addMsg("system", `⚔️ Spese di guerra: -${warCost} oro per rifornimenti.`);
        
        // Eventuale controattacco nemico automatico
        const enemy = neighboringCounties.find(c => c.key === warState.enemy);
        if (Math.random() < 0.3) { // 30% probabilità di raid nemico
            addMsg("system", `🔥 Incursione nemica! Truppe di ${enemy.name} bruciano i confini.`);
            county.pop -= rand(10, 30);
            county.gold -= rand(20, 50);
        }
    }

    // Snapshot Finale & Delta
    const endSnapshot = captureResourceSnapshot();
    lastResourceDelta = computeResourceDelta(startSnapshot, endSnapshot);
    lastResourceSnapshot = cloneResourceBag(endSnapshot);
    // (Queste variabili servivano per il vecchio report, le lasciamo per sicurezza interna ma non le usiamo per stampare)
    const goldDelta = county.gold - startGold;
    const happyDelta = county.happy - startHappy;

    checkInternalStability();
    updateUI();
    autoSaveGame();

    // --- NUOVA GESTIONE OUTPUT ---
    if (!silent) {
        // Abbiamo rimosso tutti i vecchi addMsg("system", reportHTML)
        // Abbiamo rimosso triggerCourtEvent e generateWorldNarration che scrivevano in chat
        
        // L'unica cosa che deve succedere è l'apertura del popup narrativo
        setTimeout(() => {
            generateSeasonStory();
            // Dopo la narrazione, controlla se un vicino vuole parlare
            setTimeout(() => checkDiplomaticIntrusion(), 2000);
        }, 1000);
    }
}

// =======================================
// CREA IL BLOCCO AZIONI IN CHAT
// =======================================
function appendActionsBlock(actions) {
    const chatLog = document.getElementById("chat-log");
    
    // Crea il contenitore
    const box = document.createElement("div");
    box.className = "msg-actions";
    
    // Titolo
    const header = document.createElement("div");
    header.className = "action-header";
    header.textContent = "AZIONI POSSIBILI";
    box.appendChild(header);

    // Crea i pulsanti
    actions.forEach(a => {
        const btn = document.createElement("button");
        btn.className = "action-card"; // Assicurati che questa classe abbia lo stile nel CSS
        
        // Aggiungiamo un cursore puntatore per far capire che è cliccabile
        btn.style.cursor = "pointer"; 
        btn.innerHTML = a.label; // Usa innerHTML per permettere le emoji

        // --- IL FIX FONDAMENTALE ---
        // Assegniamo la funzione direttamente, non come stringa HTML
        btn.onclick = function() {
            console.log("Azione cliccata:", a.code); // Debug nella console
            executeAction(a.code);
            // Opzionale: Rimuovi i pulsanti dopo il click per evitare click doppi
            box.remove(); 
        };

        box.appendChild(btn);
    });

    chatLog.appendChild(box);
    // Scroll automatico verso il basso
    chatLog.scrollTop = chatLog.scrollHeight;
}

// =======================================
// ESEGUI L'AZIONE SCELTA
// =======================================
function executeAction(action) {
    console.log("Azione selezionata:", action);
    let userMessage = "";

    if (action.startsWith("diplo_")) {
        handleDiplomaticAction(action);
        return;
    }

    // --- NUOVI COMANDI FINANZIARI ---
    if (action.startsWith("donate_")) {
        const faction = action.split("_")[1];
        donateToFaction(faction);
        userMessage = `Ho inviato una donazione ai ${factionLabel(faction)}.`;
    } 
    else if (action.startsWith("loan_")) {
        const faction = action.split("_")[1];
        requestLoan(faction);
        userMessage = `Ho chiesto un prestito ai ${factionLabel(faction)}.`;
    } 
    else if (action.startsWith("seize_")) {
        const faction = action.split("_")[1];
        seizeAssets(faction);
        userMessage = `Ho ordinato la confisca dei beni dei ${factionLabel(faction)}.`;
    }
    
    // ... (i tuoi casi esistenti build_ ecc.) ...
    else if (action.startsWith("build_")) {
        const type = action.substring(6); // Rimuove "build_" per ottenere il tipo completo
        if (buildingData[type]) {
            orderBuilding(type);
            const b = buildingData[type];
            userMessage = `Ho ordinato la costruzione di ${b.name}.`;
        } else {
            console.error(`Edificio sconosciuto: ${type}`);
            userMessage = `Errore: Edificio ${type} non trovato.`;
        }
    } else if (action === "emergency_tax_merchants") {
        county.gold += 50;
        factions.burghers = Math.max(0, factions.burghers - 10);
        addMsg("system", "💰 Tassa straordinaria imposta ai mercanti: +50 oro, ma la loro lealtà cala.");
        updateUI();
        userMessage = "Ho imposto una tassa straordinaria ai mercanti per riempire le casse.";
    } else if (action === "emergency_tax_church") {
        county.gold += 30;
        factions.clergy = Math.max(0, factions.clergy - 15);
        addMsg("system", "⛪ Beni requisiti alla Chiesa: +30 oro, ma i religiosi sono infuriati.");
        updateUI();
        userMessage = "Ho requisito beni alla Chiesa per finanziare il regno.";
    } else if (action === "open_law_modal") {
        document.getElementById("modal-law-creator").classList.add("active");
        userMessage = "Voglio creare una nuova legge per il regno.";
    } else if (action === "recruit_militia") {
        county.militia = (county.militia || 0) + 10;
        county.gold -= 20;
        addMsg("system", "🎖️ Reclutati 10 uomini per la milizia: -20 oro.");
        updateUI();
        userMessage = "Ho reclutato nuovi uomini per la milizia.";
    } 
    // Aggiungi dentro executeAction(action)
    else if (action.startsWith("revolt_crush_")) {
        const faction = action.split("_")[2];
        const rebels = populationGroups[faction].count;
        const militaryPower = calculateMilitaryPower(); // Funzione creata nel passo precedente
        
        // Per vincere, la potenza militare deve superare la "potenza" della folla
        // La folla è numerosa ma debole (diviso 10)
        const rebelPower = rebels / 5; 
        
        if (militaryPower > rebelPower) {
            const deadRebels = Math.floor(rebels * 0.3);
            populationGroups[faction].count -= deadRebels;
            factions[faction] = 10; // Sottomessi ma odiano
            county.happy -= 20;
            rebellionState[faction] = 0; // Reset rabbia (paura)
            
            addMsg("system", `🩸 <strong>MASSACRO:</strong> La milizia ha disperso la folla. ${deadRebels} morti. Il tuo trono è salvo, ma macchiato di sangue.`);
            updateUI();
        } else {
            triggerGameOver("overrun", faction);
        }
    }

    else if (action.startsWith("revolt_speak_")) {
        // Tentativo diplomatico
        const chance = (county.happy / 200) + 0.2; // Max ~70% se molto felici
        if (Math.random() < chance) {
            addMsg("system", "🗣️ Le tue parole hanno toccato il cuore della folla. Si disperdono pacificamente.");
            rebellionState[action.split("_")[2]] = 3;
        } else {
            triggerGameOver("mob_kill");
        }
    }

    else if (action === "gameover_abdicate") {
        triggerGameOver("abdication");
    }
    else if (action === "coup_mercenaries") {
        if (county.gold >= 300) {
            county.gold -= 300;
            addMsg("system", "💰 I mercenari hanno difeso il castello! Il traditore è stato catturato e giustiziato.");
            rebellionState.militia = 0; // Reset rabbia
            factions.militia = 20; // Umiliati
        } else {
            triggerGameOver("coup");
        }
    }
    else if (action === "coup_duel") {
        const chance = (county.health / 200) + 0.3; // Base 30% + salute
        if (Math.random() < chance) {
            addMsg("system", "⚔️ Hai sconfitto il traditore in duello! La milizia si sottomette.");
            rebellionState.militia = 0;
            factions.militia = 15;
        } else {
            triggerGameOver("coup");
        }
    }
    // Aggiungi dentro executeAction(action)
    else if (action === "edict_prioritize_food") {
        // Imposta priorità ALTA a tutte le fattorie e mulini
        buildings.forEach(b => {
            if (['wheat_farm', 'sheep_farm', 'mill', 'bakery', 'granary'].includes(b.type)) {
                b.priority = 'high';
            } else {
                b.priority = 'normal'; // Normalizza gli altri per liberare risorse
            }
        });
        addMsg("system", "📜 <strong>Editto del Pane:</strong> Tutte le strutture alimentari hanno priorità assoluta sulla manodopera.");
        updateUI();
        userMessage = "Ho ordinato che tutti i lavoratori disponibili si concentrino sulla produzione di cibo!";
    }
    
    else if (action === "edict_prioritize_industry") {
        buildings.forEach(b => {
            if (['iron_mine', 'sawmill', 'forge', 'textile_factory', 'tool_smith'].includes(b.type)) {
                b.priority = 'high';
            } else {
                b.priority = 'normal';
            }
        });
        addMsg("system", "📜 <strong>Editto Industriale:</strong> Priorità alle miniere e manifatture.");
        updateUI();
        userMessage = "Voglio che l'industria lavori a pieno regime, spostate i contadini nelle miniere!";
    }

    else {
        userMessage = action; // Fallback
    }

    // Dopo l'azione, fai reagire l'IA
    if (userMessage) {
        addMsg("user", userMessage);
        callGroq(userMessage, "action");
    }
}

function generateWorldNarration() {
    let narration = `<strong>🌍 Notizie dal Mondo Esterno:</strong><br>`;

    neighboringCounties.forEach(c => {
        const relationLevel = c.relations > 70 ? "alleate" : c.relations > 40 ? "neutra" : "ostile";
        const activity = c.aggression > 50 ? "prepara incursioni" : c.power > county.power * 1.2 ? "rafforza le difese" : "commercia pacificamente";

        narration += `${c.name} (${relationLevel}): ${c.description.split('.')[0]}. Attualmente ${activity}.<br>`;
    });

    // Aggiungi eventi casuali mondiali
    if (rand(0, 10) > 7) {
        const events = [
            "Banditi infestano le strade tra le contee, rallentando i commerci.",
            "Una carestia colpisce regioni lontane, aumentando la domanda di grano.",
            "Alleanze matrimoniali si formano tra nobili delle contee vicine."
        ];
        narration += `<em>${events[Math.floor(Math.random() * events.length)]}</em>`;
    }

    return narration;
}

function advanceSeasonManually() {
    addMsg("system", "➡️ Il Conte ordina di passare alla stagione successiva.");
    progressSeason({ silent:false });
}

function send() {
    ensureWorldSystems();
    const input = document.getElementById("u-input");
    const text = input.value.trim();
    if (!text) return;

    input.value = "";
    if (text === "/avanza") {
        advanceSeasonManually();
        return;
    }

    addMsg("user", text);

    // Ora IA (parte 6)
    callGroq(text, "action");
}

function timestamp() {
    return new Date().toLocaleTimeString("it-IT", {
        hour: "2-digit",
        minute: "2-digit"
    });
}

function addMsg(type, text) {
    const log = document.getElementById("chat-log");
    const div = document.createElement("div");

    // Gestione speciale per i messaggi delle fazioni (Riconosciuti dal nome in grassetto all'inizio)
    // L'IA tende a rispondere "Lord Emeric: ..." -> Lo intercettiamo
    if (type === 'ai' && text.includes(':')) {
        const parts = text.split(':');
        const possibleName = parts[0].trim().replace(/\*/g, ''); // Rimuovi bold markdown
        
        // Cerca se il nome corrisponde a una fazione
        let foundFaction = null;
        const factionNamesMap = {
            "Lord Emeric": "nobility", "Vescovo Aldebrando": "clergy", 
            "Capitano Ronan": "militia", "Odric": "peasants", 
            "Maestro Bernard": "burghers", "Ser Lothar": "merchants",
            "Madre Elowen": "mystics", "Rasko": "outcasts"
        };
        
        // Match parziale del nome
        for(let name in factionNamesMap) {
            if (possibleName.includes(name) || possibleName.includes(name.split(" ")[1])) {
                foundFaction = factionNamesMap[name];
                break;
            }
        }

        if (foundFaction) {
            // Renderizza come Card Fazione
            div.className = `msg-faction ${foundFaction}`;
            div.innerHTML = `
                <div class="faction-avatar">${FACTION_ICONS[foundFaction] || '👤'}</div>
                <span class="faction-title">${possibleName}</span>
                <div class="msg-text">${parts.slice(1).join(':').trim()}</div>
            `;
            log.appendChild(div);
            log.scrollTop = log.scrollHeight;
            return;
        }
    }

    // Fallback standard
    if (type === "system") {
        div.className = "msg-system";
        div.innerHTML = text; // Permetti HTML per il report
    } else {
        div.className = `msg msg-${type}`;
        div.innerHTML = `<div class="msg-text">${text}</div><div class="msg-meta">${timestamp()}</div>`;
    }
    
    log.appendChild(div);
    log.scrollTop = log.scrollHeight;
}

function addEventCard(text) {
    if (!text) return;
    const feed = document.getElementById("event-feed");
    if (!feed) return;

    const emptyState = feed.querySelector(".event-empty");
    if (emptyState) emptyState.remove();

    const card = document.createElement("div");
    card.className = "event-card";
    card.innerHTML = `
        <div class="event-time">${timestamp()}</div>
        <div class="msg-text">${text}</div>
    `;

    feed.prepend(card);

    const cards = feed.querySelectorAll(".event-card");
    if (cards.length > 8) {
        feed.removeChild(feed.lastElementChild);
    }
}

function addAdviceCard(text) {
    if (!text) return;
    const feed = document.getElementById("advice-feed");
    if (!feed) return;

    const emptyState = feed.querySelector(".advice-empty");
    if (emptyState) emptyState.remove();

    const card = document.createElement("div");
    card.className = "event-card";
    card.innerHTML = `
        <div class="event-time">${timestamp()}</div>
        <div class="msg-text">${text}</div>
    `;

    feed.prepend(card);

    const cards = feed.querySelectorAll(".event-card");
    if (cards.length > 6) {
        feed.removeChild(feed.lastElementChild);
    }
}

function renderActionSuggestions(actions, promptText = "Scegli un'azione proposta dalla corte.") {
    const list = document.getElementById("action-list");
    const promptEl = document.getElementById("action-prompt");
    if (!list || !promptEl) return;

    promptEl.innerText = promptText || "Scegli un'azione proposta dalla corte.";
    list.innerHTML = "";

    if (!actions.length) {
        promptEl.innerText = "In attesa di nuovi suggerimenti dalla corte.";
        list.innerHTML = '<p class="action-empty">Nessuna proposta al momento.</p>';
        return;
    }

    actions.forEach(action => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "action-card";
        btn.innerHTML = `<strong>${action.title}</strong><span>${action.desc}</span>`;
        btn.addEventListener("click", () => {
            const input = document.getElementById("u-input");
            if (!input) return;
            input.value = action.command || action.title;
            input.focus();
        });
        list.appendChild(btn);
    });
}

function extractActionsFromText(text) {
    const lower = text.toLowerCase();
    const idx = lower.indexOf("ecco le azioni");
    if (idx === -1) {
        return { remainingText: text, actions: [], prompt: "" };
    }

    const actionBlock = text.slice(idx).trim();
    const promptLineMatch = actionBlock.match(/^[^\n]+/);
    let prompt = promptLineMatch ? promptLineMatch[0].trim() : "Scegli un'azione proposta dalla corte.";
    const questionMatch = actionBlock.match(/Quale azione[^\n]*/i);
    if (questionMatch) prompt = questionMatch[0].trim();

    const listText = actionBlock.replace(/^[^\n]+\n?/, "").trim();
    const regex = /- \*\*(.+?)\*\*:([\s\S]*?)(?=\n- \*\*|$)/g;
    const actions = [];
    let match;
    while ((match = regex.exec(listText)) !== null) {
        actions.push({
            title: match[1].trim(),
            desc: match[2].replace(/\s+/g, " ").trim(),
            command: match[1].trim()
        });
    }

    return {
        remainingText: text.slice(0, idx).trim(),
        actions,
        prompt
    };
}

function askAdvisor() {
    // 1. Feedback visivo immediato nella chat principale
    addMsg("system", "🧠 Il Conte ha convocato Ser Dorian per un consulto privato...");

    // 2. Costruzione contesto
    let problems = [];
    if (county.gold < 100) problems.push("siamo poveri");
    if (county.food < 50) problems.push("c'è poca cibo");
    if (county.security < 40) problems.push("i confini sono deboli");
    
    const context = problems.length 
        ? `Mio signore, ${problems.join(", ")}. Dobbiamo agire.` 
        : "La situazione è stabile, ma possiamo sempre migliorare.";

    // 3. Chiamata API con modalità 'advice'
    // Nota: usiamo un prompt specifico per evitare conflitti con la chat
    const prompt = `
    ${context}
    Analizza la situazione attuale (Anno ${worldTime.year}, ${getSeason().label}) e dammi 2 consigli strategici brevi e diretti.
    `;
    
    callGroq(prompt, "advice");
}

function openBudgetModal() {
    const modal = document.getElementById("modal-budget");
    if (modal) {
        renderBudget();
        modal.classList.add("active");
    }
}

function closeLawModal() {
    document.getElementById("modal-law-creator").classList.remove("active");
}

function createLaw() {
    const name = document.getElementById("law-name").value.trim();
    const desc = document.getElementById("law-desc").value.trim();
    const upkeep = parseInt(document.getElementById("law-upkeep").value) || 0;
    const resourceKey = document.getElementById("law-resource").value;
    const resourceAmount = parseInt(document.getElementById("law-resource-amount").value) || 0;

    if (!name) {
        alert("Inserisci un nome per la legge.");
        return;
    }

    const lawKey = name.toLowerCase().replace(/\s+/g, '_');
    const law = {
        name: name,
        desc: desc,
        upkeepCost: upkeep,
        consumeResource: resourceAmount > 0 ? { [resourceKey]: resourceAmount } : null
    };

    // Aggiungi alla lista delle leggi disponibili (fittizia, in realtà salva in activeLaws)
    activeLaws.push(lawKey);
    // Salva la definizione
    if (!window.lawDefinitions) window.lawDefinitions = {};
    window.lawDefinitions[lawKey] = law;

    addMsg("system", `📜 Nuova legge promulgata: <strong>${name}</strong> - ${desc}`);
    closeLawModal();
    updateUI();
}

function getLawDefinition(key) {
    return window.lawDefinitions ? window.lawDefinitions[key] : null;
}

function renderBudget() {
    const container = document.getElementById("budget-content");
    if (!container) return;

    const inc = detailedBudget.income;
    const exp = detailedBudget.expenses;
    const totalInc = Object.values(inc).reduce((a,b)=>a+b,0);
    const totalExp = Object.values(exp).reduce((a,b)=>a+b,0);

    // Calcolo entrate dei pop per dare visione completa economia
    const popIncomes = {
        peasants: Math.floor(
            (populationGroups.peasants.count * 0.08) +
            ((county.resources.grain || 0) * 0.005) +
            ((county.resources.livestock || 0) * 0.01)
        ),
        burghers: Math.floor(
            (populationGroups.burghers.count * 1.5) +
            ((county.resources.textiles || 0) * 0.25) +
            ((county.resources.iron || 0) * 0.3) +
            ((county.resources.copper || 0) * 0.35)
        ),
        merchants: Math.floor(
            (populationGroups.merchants.count * 3) +
            ((seasonalTransactions.marketSales + seasonalTransactions.marketPurchases) * 0.12) +
            ((county.resources.luxuries || 0) * 0.4)
        ),
        nobility: Math.floor(
            (landOwnership.nobility * 8) +
            (county.gold * 0.015) +
            ((county.resources.grain || 0) * 0.03) +
            (populationGroups.nobility.count * 15)
        ),
        clergy: Math.floor(
            (landOwnership.clergy * 6) +
            (county.gold * 0.012) +
            (county.pop * 0.015) +
            (populationGroups.clergy.count * 8)
        )
    };

    container.innerHTML = `
        <div class="budget-columns">
            <div class="budget-col">
                <h4>💰 Entrate Tesoro (+${totalInc})</h4>
                <div class="budget-row"><span>Tasse Nobiltà</span> <span>${inc.taxes_nobility}</span></div>
                <div class="budget-row"><span>Tasse Borghesia</span> <span>${inc.taxes_burghers}</span></div>
                <div class="budget-row"><span>Tasse Contadini</span> <span>${inc.taxes_peasants}</span></div>
                <div class="budget-row"><span>Altri Ceti</span> <span>${inc.taxes_other}</span></div>
                <div class="budget-row"><span>Commercio/Export</span> <span>${inc.trade_export}</span></div>
                <div class="budget-row"><span>Produzione (Zecca)</span> <span>${inc.production_mint}</span></div>
            </div>
            
            <div class="budget-col">
                <h4>💸 Uscite Tesoro (-${totalExp})</h4>
                <div class="budget-row"><span>Militare & Difesa</span> <span class="money-minus">${exp.upkeep_military}</span></div>
                <div class="budget-row"><span>Corte & Prestigio</span> <span class="money-minus">${exp.upkeep_court}</span></div>
                <div class="budget-row"><span>Civile & Mercati</span> <span class="money-minus">${exp.upkeep_civil}</span></div>
                <div class="budget-row"><span>Infrastrutture</span> <span class="money-minus">${exp.upkeep_infrastructure}</span></div>
                <div class="budget-row"><span>Leggi & Welfare</span> <span class="money-minus">${exp.welfare_laws}</span></div>
                <div class="budget-row"><span>Importazioni</span> <span class="money-minus">${exp.import_costs}</span></div>
            </div>
        </div>
        
        <div class="net-balance-card">
            <div>Bilancio Tesoro</div>
            <div class="net-balance-val ${detailedBudget.net >= 0 ? 'money-plus' : 'money-minus'}">
                ${detailedBudget.net > 0 ? '+' : ''}${detailedBudget.net} 💰
            </div>
            <div style="font-size:0.8em; color:#888; margin-top:5px;">
                Tesoro Attuale: ${county.gold} 💰
            </div>
        </div>

        <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid var(--border-soft);">
            <h4 style="color: var(--accent); margin-bottom: 10px;">📊 Economia dei Ceti (redditi stagionali)</h4>
            <div class="budget-columns">
                <div class="budget-col">
                    <div class="budget-row"><span>👨‍🌾 Contadini</span> <span>${popIncomes.peasants} 💰</span></div>
                    <div class="budget-row"><span>🏪 Borghesi</span> <span>${popIncomes.burghers} 💰</span></div>
                    <div class="budget-row"><span>💼 Mercanti</span> <span>${popIncomes.merchants} 💰</span></div>
                </div>
                <div class="budget-col">
                    <div class="budget-row"><span>👑 Nobiltà</span> <span>${popIncomes.nobility} 💰</span></div>
                    <div class="budget-row"><span>⛪ Clero</span> <span>${popIncomes.clergy} 💰</span></div>
                </div>
            </div>
            <div style="font-size: 0.75em; color: var(--text-soft); margin-top: 8px; font-style: italic;">
                Questi redditi vengono guadagnati dai ceti attraverso produzione, commercio e rendite. 
                Il Tesoro della Contea li tassa attraverso le aliquote impostate.
            </div>
        </div>
    `;
}

</script>
<script>

/* ============================================================
   ========================= GROQ ENGINE ========================
   ============================================================ */

async function callGroq(userText, mode="action", retryCount = 0) {
    if (!ensureApiKey()) {
        addMsg("system", "🔐 Inserisci una chiave API.");
        activateScreen("screen-login");
        return;
    }

    // Stop dopo 3 tentativi per evitare loop infiniti
    if (retryCount > 3) {
        addMsg("system", "⚠️ La Corte è troppo affollata (Server occupato). Riprova tra poco.");
        return;
    }

    const promptData = buildPrompt(userText, mode);
    
    // OTTIMIZZAZIONE 1: Riduciamo la memoria storica per risparmiare token
    // Invece di 10 messaggi, ne teniamo solo 4 (più che sufficienti per il contesto immediato)
    if (publicChatHistory.length > 4) {
        publicChatHistory = publicChatHistory.slice(-4);
    }

    publicChatHistory.push({ role: "user", content: userText });

    const apiMessages = [
        { role: "system", content: promptData.system },
        ...publicChatHistory
    ];

    try {
        const resp = await fetch("https://api.groq.com/openai/v1/chat/completions", {
            method: "POST",
            headers: {
                "Content-Type":"application/json",
                "Authorization":"Bearer " + apiKey
            },
            body: JSON.stringify({
                model: "llama-3.1-8b-instant",
                temperature: 0.6,
                messages: apiMessages
            })
        });

        // GESTIONE ERRORE RATE LIMIT (429)
        if (resp.status === 429) {
            console.warn("Rate limit colpito. Attendo 2.5s...");
            // Rimuove l'ultimo messaggio utente dalla storia per non duplicarlo nel retry
            publicChatHistory.pop(); 
            // Aspetta 2500ms
            await new Promise(resolve => setTimeout(resolve, 2500));
            // Riprova ricorsivamente
            return callGroq(userText, mode, retryCount + 1);
        }

        const data = await resp.json();
        if (!resp.ok) throw new Error(data.error?.message || 'API Error');

        const aiMsg = data.choices[0].message.content;
        publicChatHistory.push({ role: "assistant", content: aiMsg });
        handleAIResponse(aiMsg, mode);

    } catch(e) {
        // Se è un errore diverso dal 429, lo mostriamo
        console.error(e);
        addMsg("system", "⚠️ Il consigliere tace (Errore: " + e.message + ")");
        publicChatHistory.pop(); // Clean up
    }
}


function getChatName(key) {
    // Gestione nomi standard
    const map = {
        nobility:"Lord Emeric", clergy:"Vescovo Aldebrando",
        militia:"Capitano Ronan", peasants:"Odric",
        burghers:"Maestro Bernard", merchants:"Ser Lothar",
        mystics:"Madre Elowen", outcasts:"Rasko",
        spouse: dynasty.spouse ? dynasty.spouse.name : "Consorte",
        auvrey:"Messo di Auvrey", falken:"Ambasciatrice Falken"
    };
    
    // Gestione dinamica Eredi
    if (key.startsWith('heir_')) {
        const idx = parseInt(key.split('_')[1]);
        return dynasty.heirs[idx] ? dynasty.heirs[idx].name : "Erede";
    }

    // Gestione dinamica Pretendenti (Chat pre-matrimonio)
    if (key.startsWith('suitor_')) {
        const idx = parseInt(key.split('_')[1]);
        return activeSuitorsList[idx] ? activeSuitorsList[idx].name : "Pretendente";
    }

    return map[key] || key;
}

function buildPrivatePrompt(factionKey, userText) {
    let systemPrompt = "";
    const name = getChatName(factionKey);
    const currentStats = generateKingdomSummary();

    // Istruzioni base per il parsing
    const logicInstructions = `
    REGOLE FONDAMENTALI DI COMPORTAMENTO:
    1. Sei un personaggio vivo, non un assistente.
    2. Valuta il tono dell'utente:
       - Se è gentile/adulatorio: Aumenta relazione.
       - Se è offensivo/inappropriato: Diminuisci relazione.
    3. FORMATO RISPOSTA (Obbligatorio):
       Scrivi la tua risposta discorsiva (dialogo).
       ALLA FINE, su una nuova riga, aggiungi SOLO questo tag tecnico invisibile all'utente:
       [REL: +X] o [REL: -X] (dove X è un numero da 1 a 10 in base all'impatto della frase).
       Se la conversazione sembra finita o in stallo, aggiungi anche: [STATUS: END].
    `;

    // --- 1. CASO CONSORTE ---
    if (factionKey === 'spouse' && dynasty.spouse) {
        systemPrompt = `
        Sei ${name}, consorte del Conte.
        ${logicInstructions}
        Il tuo obiettivo è proteggere la famiglia e i tuoi interessi di origine (${dynasty.spouse.originLabel}).
        Sii affettuoso ma esigente.
        `;
    }
    
    // --- 2. CASO PRETENDENTE (Corteggiamento) ---
    else if (factionKey.startsWith('suitor_')) {
        const idx = parseInt(factionKey.split('_')[1]);
        const suitor = activeSuitorsList[idx];
        
        systemPrompt = `
        Sei ${suitor.name}, un nobile che vuole sposare il Conte.
        Attuale Relazione: ${suitor.relation}/100.
        ${logicInstructions}
        
        OBIETTIVO: Farti sposare.
        Se la relazione supera 80, sii molto disponibile al matrimonio.
        Se è bassa, sii diffidente.
        `;
    }

    // --- 3. CASO FAZIONE STANDARD ---
    else {
        systemPrompt = `
        Sei ${name}. Rappresenti la tua fazione (${factionLabel(factionKey)}).
        Attuale Lealtà: ${factions[factionKey] || 50}.
        ${logicInstructions}
        Se il conte promette aiuto alla tua fazione, alza la relazione.
        `;
    }

    return { system: systemPrompt, user: userText };
}

/* ==================== CHAT PRIVATA ==================== */

async function callGroqPrivate(factionKey, userText) {

    if (!ensureApiKey()) {
        addPrivateMsg("system", "🔐 Chiave API mancante.");
        return;
    }

    const promptData = buildPrivatePrompt(factionKey, userText);
    
    // Recupera storico (assicurati che privateChats[factionKey] esista)
    if (!privateChats[factionKey]) privateChats[factionKey] = [];
    const history = privateChats[factionKey].slice(-6).map(msg => ({
        role: msg.from === "user" ? "user" : "assistant",
        content: msg.text // Nota: qui salviamo il testo pulito
    }));

    const apiMessages = [
        { role: "system", content: promptData.system },
        ...history,
        { role: "user", content: promptData.user }
    ];

    try {
        const resp = await fetch("https://api.groq.com/openai/v1/chat/completions", {
            method:"POST",
            headers:{
                "Content-Type":"application/json",
                "Authorization":"Bearer " + apiKey
            },
            body: JSON.stringify({
                model: "llama-3.1-8b-instant",
                temperature: 0.8,
                messages: apiMessages
            })
        });

        const data = await resp.json();
        if (!resp.ok) throw new Error('API Error');

        let rawMsg = data.choices[0].message.content;
        
        // --- PARSING DELLA RISPOSTA ---
        let cleanMsg = rawMsg;
        let relChange = 0;
        let suggestedEnd = false;

        // 1. Estrai cambio relazione [REL: +/-X]
        const relMatch = rawMsg.match(/\[REL:\s*([+-]?\d+)\]/i);
        if (relMatch) {
            relChange = parseInt(relMatch[1]);
            cleanMsg = cleanMsg.replace(relMatch[0], ""); // Rimuovi dal testo visibile
        }

        // 2. Estrai status fine [STATUS: END]
        if (rawMsg.includes("[STATUS: END]")) {
            suggestedEnd = true;
            cleanMsg = cleanMsg.replace("[STATUS: END]", "");
        }

        cleanMsg = cleanMsg.trim();

        // --- APPLICAZIONE EFFETTI ---
        if (relChange !== 0) {
            applyPrivateRelationChange(factionKey, relChange);
        }

        // Salvataggio e Display
        privateChats[factionKey].push({ from:"ai", text: cleanMsg });
        addPrivateMsg("ai", cleanMsg);

        // Se l'IA suggerisce di chiudere o se c'è un cambio relazione, mostra feedback
        if (relChange !== 0) {
            const sign = relChange > 0 ? "+" : "";
            const color = relChange > 0 ? "#6ada91" : "#ff7c7c";
            addPrivateMsg("system", `<span style="color:${color}">Rapporto ${sign}${relChange}</span>`);
        }

        if (suggestedEnd) {
            showPrivateActions(factionKey); // Mostra bottoni azione finale
        }

    } catch(e) {
        addPrivateMsg("system", "⚠️ Errore comunicazione: " + e);
    }
}


// Funzione helper per applicare i cambiamenti matematici
function applyPrivateRelationChange(key, delta) {
    // Caso Pretendente
    if (key.startsWith('suitor_')) {
        const idx = parseInt(key.split('_')[1]);
        const suitor = activeSuitorsList[idx];
        if (suitor) {
            suitor.relation = Math.max(0, Math.min(100, suitor.relation + delta));
            // Aggiorna UI se necessario (es. ricarica modale se aperto)
        }
    }
    // Caso Fazione / Personaggio Standard
    else {
        // Mappa chiave chat -> chiave fazione
        const map = {
            nobility:"nobility", clergy:"clergy", militia:"militia", 
            peasants:"peasants", burghers:"burghers", merchants:"merchants", 
            mystics:"mystics", outcasts:"outcasts"
        };
        
        // Se stiamo parlando con Lord Emeric (nobility), aggiorna la fazione nobility
        const factionKey = map[key] || key; // Fallback se la chiave è già quella giusta
        if (factions[factionKey] !== undefined) {
            factions[factionKey] = Math.max(0, Math.min(100, factions[factionKey] + delta));
        }
    }
}

function showPrivateActions(key) {
    const log = document.getElementById("private-chat-log");
    const actionsDiv = document.createElement("div");
    actionsDiv.className = "msg-actions";
    actionsDiv.style.marginTop = "15px";

    let html = `<div class="action-header">Concludi Colloquio</div>`;

    // Azioni Comuni
    html += `<button class="btn-sec" onclick="endPrivateChat('${key}', 'bye')">👋 Congeda / Arrivederci</button>`;

    // Azioni Specifiche per Pretendenti
    if (key.startsWith('suitor_')) {
        const idx = parseInt(key.split('_')[1]);
        const suitor = activeSuitorsList[idx];
        
        if (suitor.relation >= 60) {
             html += `<button class="btn-main" onclick="endPrivateChat('${key}', 'marry')">💍 Proponi Matrimonio</button>`;
        } else {
             html += `<button class="btn-sec" disabled style="opacity:0.5">💍 Proponi Matrimonio (Rapporto insufficiente)</button>`;
        }
        
        html += `<button class="btn-sec" onclick="giveGiftToSuitor(${idx})">🎁 Invia Regalo (+Relazione)</button>`;
    }

    actionsDiv.innerHTML = html;
    log.appendChild(actionsDiv);
    log.scrollTop = log.scrollHeight;
}

function endPrivateChat(key, action) {
    const log = document.getElementById("private-chat-log");
    
    if (action === 'bye') {
        addPrivateMsg("user", "Arrivederci.");
        setTimeout(() => {
            addPrivateMsg("system", "Il colloquio è terminato.");
            closePrivateChat();
        }, 800);
    }
    
    if (action === 'marry') {
        const idx = parseInt(key.split('_')[1]);
        addPrivateMsg("user", "Vuoi unire la tua casata alla mia?");
        setTimeout(() => {
            marrySuitorIndex(idx); // Funzione esistente
            closePrivateChat();
        }, 1000);
    }
}

/* ============================================================
   ======================= SUPER PROMPT =========================
   ============================================================ */

function getFeasibleActions() {
    const actions = [];
    const treasury = county.gold;
    
    // 1. ANALISI BISOGNI CRITICI (Priorità assoluta)
    if (lastNeedsReport) {
        Object.entries(lastNeedsReport).forEach(([key, data]) => {
            // Se stanno morendo di fame per povertà (Prezzi alti, Ricchezza bassa)
            if (data.mainIssue && data.mainIssue.includes("POVERTÀ") || data.wealth < 10) {
                actions.push(`DONARE ORO ai ${factionLabel(key)} (Costo: 50 oro) - Risolve la crisi economica`);
            }
            // Se stanno morendo di fame per mancanza merce
            else if (data.mainIssue && data.mainIssue.includes("CARESTIA")) {
                actions.push(`IMPORTARE CIBO d'urgenza per i ${factionLabel(key)}`);
            }
        });
    }

    // 2. ANALISI FINANZIARIA (Prestiti e Confische)
    Object.entries(populationGroups).forEach(([key, data]) => {
        const label = factionLabel(key);
        
        // Se la fazione è molto ricca e il Conte ha meno di 200 oro -> Suggerisci Prestito o Tassa
        if (data.wealth > 300 && treasury < 200) {
            actions.push(`CHIEDERE PRESTITO ai ${label} (Ottieni 100 oro, -5 Lealtà)`);
            if (factions[key] < 40) {
                // Se sono già ostili, tanto vale confiscare
                actions.push(`CONFISCARE BENI ai ${label} (Ottieni ${Math.floor(data.wealth/2)} oro, -25 Lealtà)`);
            }
        }
        
        // Se la fazione è arrabbiata (Lealtà < 40) ma non povera -> Corruzione/Regalo
        if (factions[key] < 40 && treasury > 100) {
            actions.push(`INVIARE DONO ai ${label} per calmarli (Costo: 50 oro)`);
        }
    });

    // 3. PROPOSTE COSTRUZIONI (Solo se pertinenti)
    if (treasury > 100) {
        if (county.food < 100) actions.push("COSTRUIRE Fattoria o Granaio (Priorità Cibo)");
        if (county.security < 40) actions.push("COSTRUIRE Torre di Guardia o Caserma (Priorità Sicurezza)");
    } else {
        actions.push("RISPARMIARE ORO (Nessuna costruzione consigliata)");
    }

    // Mescoliamo e prendiamo max 4 suggerimenti per non confondere l'IA
    return actions.sort(() => 0.5 - Math.random()).slice(0, 4).join("\n- ");
}

function getDynamicActions(response = "") {
    const actions = [];
    const lower = response.toLowerCase();

    // ... (tuoi controlli esistenti su costruzioni) ...
    if (lower.includes("costruzione") || lower.includes("edificio") || lower.includes("costruire")) {
        // Edifici costruibili
        const buildable = Object.entries(buildingData).filter(([key, data]) => {
            return checkResources(data.cost);
        });

        buildable.slice(0, 3).forEach(([key, data]) => {  // Limita a 3
            const effects = [];
            if (data.effect) effects.push(data.effect);
            if (data.housing) effects.push(`+${data.housing} alloggi`);
            effects.push(`Lealtà contadini +5`);
            const effectDesc = effects.join(", ");
            actions.push({
                label: `🏗️ Costruisci ${data.name} (${data.cost.gold} oro) - ${effectDesc}`,
                code: `build_${key}`
            });
        });
    }

    // Rilevamento intelligente delle azioni finanziarie
    Object.keys(populationGroups).forEach(key => {
        const label = factionLabel(key).toLowerCase();
        
        // DONAZIONI
        if (lower.includes(`donare`) && lower.includes(label)) {
            actions.push({
                label: `🎁 Dona 50 oro ai ${factionLabel(key)}`,
                code: `donate_${key}`
            });
        }
        
        // PRESTITI
        if ((lower.includes(`prestito`) || lower.includes(`chiedere oro`)) && lower.includes(label)) {
            actions.push({
                label: `💰 Chiedi prestito ai ${factionLabel(key)}`,
                code: `loan_${key}`
            });
        }
        
        // CONFISCHE
        if ((lower.includes(`confiscare`) || lower.includes(`tassa`) || lower.includes(`requisire`)) && lower.includes(label)) {
            actions.push({
                label: `⚖️ Confisca beni ai ${factionLabel(key)}`,
                code: `seize_${key}`
            });
        }
    });

    if (lower.includes("oro") || lower.includes("tesoro") || lower.includes("soldi") || lower.includes("povero")) {
        if (county.gold < 50) {
            actions.push({
                label: "💰 Tassa straordinaria ai Mercanti - +50 oro, lealtà mercanti -10, felicità generale -2",
                code: "emergency_tax_merchants"
            });
            actions.push({
                label: "⛪ Requisire beni alla Chiesa - +30 oro, lealtà chiesa -15, morale nobili -3",
                code: "emergency_tax_church"
            });
        }
    }

    if (lower.includes("legge") || lower.includes("decreto") || lower.includes("regola")) {
        actions.push({
            label: "📜 Crea una nuova legge - Personalizza effetti su tasse, produzione o fazioni",
            code: "open_law_modal"
        });
    }

    if (lower.includes("milizia") || lower.includes("soldati") || lower.includes("sicurezza") || lower.includes("banditi")) {
        actions.push({
            label: "🎖️ Convoca la milizia - +10 milizia, sicurezza +5, -20 oro, lealtà contadini -2",
            code: "recruit_militia"
        });
    }

    // Se c'è carestia o mancanza di cibo
    if (county.food < 40 || (lastNeedsReport && Object.values(lastNeedsReport).some(r => r.mainIssue.includes("CARESTIA")))) {
        actions.push({
            label: "🌾 Priorità Cibo (Editto) - Sposta lavoratori su campi e forni",
            code: "edict_prioritize_food"
        });
    }

    // Se c'è disoccupazione alta o richiesta armi
    if (warState.active || county.resources.weapons < 10) {
        actions.push({
            label: "⚒️ Priorità Industria (Editto) - Sposta lavoratori su miniere e fucine",
            code: "edict_prioritize_industry"
        });
    }

    return actions;
}

function generateDeepContext() {
    // VERSIONE OTTIMIZZATA (Low Token Usage)
    
    // 1. Dati Base
    let ctx = `[STATO ANNO ${worldTime.year} ${getSeason().label}]\n`;
    ctx += `CONTE: ${dynasty.ruler.name} (Salute ${dynasty.ruler.health}%). POP: ${county.pop} (Felicità ${county.happy}%, Sicurezza ${county.security}%).\n`;
    ctx += `ORO: ${county.gold}. CIBO: ${county.food}% fabbisogno.\n`;

    // 2. Guerra (Solo se attiva)
    if (warState.active) {
        ctx += `⚠️ GUERRA ATTIVA vs ${warState.enemy}. Leve: ${warState.mobilized ? "SÌ" : "NO"}. Eff. Militare: ${getArmyEfficiency()}%.\n`;
    }

    // 3. Risorse Scarse (Non elencare tutto, solo ciò che manca o è critico)
    const stats = calculateResourceStats();
    let issues = [];
    Object.entries(stats).forEach(([k, s]) => {
        if (getResourceStatus(s) === 'critical') issues.push(`${k.toUpperCase()} ESAURITO`);
        else if (getResourceStatus(s) === 'warning') issues.push(`${k} scaso`);
    });
    if (issues.length > 0) ctx += `CRISI RISORSE: ${issues.join(", ")}.\n`;

    // 4. Fazioni Arrabbiate (Solo quelle sotto 40)
    let angry = [];
    factionOrder.forEach(key => {
        if (factions[key] < 40) angry.push(`${key} (${factions[key]}%)`);
    });
    if (angry.length > 0) ctx += `RIVOLTE POSSIBILI: ${angry.join(", ")}.\n`;

    // 5. Vicini
    ctx += `VICINI: `;
    ctx += neighboringCounties.map(n => `${n.name.split(' ')[0]} (Rel ${n.relations}, Pot ${n.power})`).join(" | ");
    
    // CALCOLO STATISTICHE LAVORO PER IA
    let laborStats = "";
    const totalWorkforce = Object.values(populationGroups).reduce((sum, g) => sum + Math.floor(g.count * (g.workforceRatio||0.6)), 0);
    const totalEmployed = Object.values(populationGroups).reduce((sum, g) => sum + (g.employed || 0), 0);
    const unemploymentRate = Math.floor(((totalWorkforce - totalEmployed) / totalWorkforce) * 100);
    
    laborStats += `DISOCCUPAZIONE: ${unemploymentRate}% (Forza Lavoro: ${totalWorkforce}, Occupati: ${totalEmployed}).\n`;
    
    // Evidenzia problemi specifici
    if (populationGroups.burghers.employed >= Math.floor(populationGroups.burghers.count * 0.8)) {
        laborStats += "CRITICO: Mancano artigiani qualificati per le fabbriche.\n";
    }
    if (populationGroups.peasants.literacy < 10) {
        laborStats += "ISTRUZIONE: Bassa. Difficile trovare lavoratori qualificati.\n";
    }

    ctx += laborStats;
    
    return ctx;
}

/* ===================== DIPLOMAZIA VIVA ===================== */

function checkDiplomaticIntrusion() {
    // Se siamo già in guerra o in dialogo, evita
    if (activeDiplomacy.active || warState.active) return;

    // 30% di probabilità che un vicino intervenga a stagione
    if (Math.random() > 0.3) return;

    const neighbor = neighboringCounties[Math.floor(Math.random() * neighboringCounties.length)];
    const turn = county.turn;

    // Evita spam (minimo 2 turni di pausa)
    if (turn - neighbor.lastInteraction < 2) return;
    
    neighbor.lastInteraction = turn;
    triggerForeignDialog(neighbor);
}

async function triggerForeignDialog(neighbor) {
    activeDiplomacy.active = true;
    activeDiplomacy.partner = neighbor.key;

    // Determina l'intento in base alle statistiche
    let intent = "neutral";
    let contextPrompt = "";

    // CASO 1: Minaccia di Guerra (Relazioni basse o Aggressività alta)
    if (neighbor.relations < 30 || neighbor.aggression > 70) {
        activeDiplomacy.type = "threat";
        intent = "hostile";
        contextPrompt = `
        Il tuo obiettivo è minacciare il giocatore. Sei furioso.
        Pretendi un tributo di ${Math.floor(county.gold * 0.2)} oro o cedi territorio, altrimenti sarà guerra.
        Sii arrogante.
        `;
    }
    // CASO 2: Richiesta Commerciale (Falken o ricchi)
    else if (neighbor.key === 'falken' || neighbor.wealth < 30) {
        activeDiplomacy.type = "trade";
        intent = "mercantile";
        contextPrompt = `
        Vuoi comprare risorse o chiedere un prestito.
        Sii diplomatico ma viscido. Proponi un affare.
        `;
    }
    // CASO 3: Alleanza/Saluti (Relazioni alte)
    else {
        activeDiplomacy.type = "greeting";
        intent = "friendly";
        contextPrompt = `
        Vieni a portare i saluti e a rafforzare l'alleanza.
        Avvisa il giocatore di eventuali pericoli esterni.
        `;
    }

    // Chiediamo all'IA di generare il messaggio di ingresso
    const systemPrompt = `
    SEI ${neighbor.ruler} di ${neighbor.name}.
    Tratti: ${neighbor.traits.join(", ")}.
    Relazione con il giocatore: ${neighbor.relations}/100.
    
    CONTESTO: Entri nella sala del trono del giocatore (Chat).
    ${contextPrompt}
    
    Scrivi SOLO il dialogo diretto tra virgolette. Max 2 frasi.
    `;

    try {
        const resp = await fetch("https://api.groq.com/openai/v1/chat/completions", {
            method: "POST",
            headers: { "Content-Type":"application/json", "Authorization":"Bearer " + apiKey },
            body: JSON.stringify({
                model: "llama-3.1-8b-instant",
                temperature: 0.8,
                messages: [{ role: "system", content: systemPrompt }]
            })
        });
        
        const data = await resp.json();
        const msg = data.choices[0].message.content;

        // Mostra in Chat con stile speciale
        addForeignMsg(neighbor.key, neighbor.name, msg);
        
        // Aggiungi alla memoria IA
        publicChatHistory.push({ role: "assistant", content: `${neighbor.name}: "${msg}"` });

        // Genera le opzioni di risposta per il giocatore
        generateDiplomaticOptions(neighbor, activeDiplomacy.type);

    } catch(e) {
        console.error(e);
        activeDiplomacy.active = false; // Reset in caso di errore
    }
}

function addForeignMsg(key, name, text) {
    const log = document.getElementById("chat-log");
    const div = document.createElement("div");
    div.className = `msg-foreign ${key}`;
    div.innerHTML = `
        <span class="foreign-badge" style="color:white">${name}</span>
        <div class="msg-text" style="color:#eee; font-style:italic;">${text}</div>
    `;
    log.appendChild(div);
    log.scrollTop = log.scrollHeight;
}

function generateDiplomaticOptions(neighbor, type) {
    const actions = [];
    
    if (type === "threat") {
        const tribute = Math.floor(county.gold * 0.2);
        actions.push({
            label: `💸 Paga Tributo (${tribute} oro) - Evita guerra, -Orgoglio`,
            code: `diplo_pay_${neighbor.key}_${tribute}`
        });
        actions.push({
            label: `⚔️ Rifiuta e Insulta - PROBABILE GUERRA`,
            code: `diplo_refuse_war_${neighbor.key}`
        });
        actions.push({
            label: `🗣️ Cerca di negoziare (Carisma)`,
            code: `diplo_negotiate_${neighbor.key}`
        });
    } else if (type === "trade") {
        actions.push({
            label: `🤝 Accetta accordo commerciale`,
            code: `diplo_accept_trade_${neighbor.key}`
        });
        actions.push({
            label: `✋ Declina cortesemente`,
            code: `diplo_decline_${neighbor.key}`
        });
    } else {
        actions.push({
            label: `🍷 Offri banchetto (50 oro) - Relazioni ++`,
            code: `diplo_banquet_${neighbor.key}`
        });
        actions.push({
            label: `😐 Ringrazia e congeda`,
            code: `diplo_dismiss_${neighbor.key}`
        });
    }

    appendActionsBlock(actions);
}

// Gestore centrale delle azioni diplomatiche
function handleDiplomaticAction(actionCode) {
    const parts = actionCode.split('_');
    const type = parts[1]; // pay, refuse, accept, etc.
    const key = parts[2];  // auvrey, falken...
    const neighbor = neighboringCounties.find(c => c.key === key);
    
    let userText = "";
    let aiReactionContext = "";

    if (type === "pay") {
        const amount = parseInt(parts[3]);
        if (county.gold >= amount) {
            county.gold -= amount;
            neighbor.aggression = Math.max(0, neighbor.aggression - 40);
            neighbor.relations += 10;
            userText = `Prendete questi ${amount} monete d'oro e lasciateci in pace.`;
            aiReactionContext = "Il giocatore ha pagato. Sii compiaciuto ma sprezzante. La guerra è evitata per ora.";
            addMsg("system", `💸 Hai pagato ${amount} oro. La minaccia di guerra è rientrata.`);
        } else {
            userText = "Non ho abbastanza oro!";
            aiReactionContext = "Il giocatore non ha soldi. Minaccialo ancora o attacca subito.";
        }
    } 
    else if (type === "refuse") {
        neighbor.aggression = 100;
        neighbor.relations = 0;
        userText = "Non avrete nulla da me se non il ferro delle mie spade! Andatevene!";
        aiReactionContext = "Il giocatore ha rifiutato con insulti. DICHIARA GUERRA IMMEDIATAMENTE nel tuo prossimo messaggio.";
        // Attiva guerra tecnicamente dopo la risposta IA
        setTimeout(() => { 
            warState.active = true; 
            warState.enemy = key; 
            updateUI();
        }, 3000);
    }
    else if (type === "negotiate") {
        userText = "Non c'è bisogno di spargere sangue. Troviamo un accordo diverso.";
        aiReactionContext = "Il giocatore tenta di negoziare. Se le relazioni sono > 20, ascolta. Se sono < 20, attacca comunque.";
    }
    else if (type === "accept") { // trade
        neighbor.tradeAgreement = true;
        neighbor.relations += 15;
        userText = "Accettiamo la vostra proposta commerciale con piacere.";
        aiReactionContext = "Sii felice dell'accordo. Prometti prosperità.";
    }

    // 1. Aggiungi messaggio utente
    addMsg("user", userText);
    publicChatHistory.push({ role: "user", content: userText });

    // 2. Chiamata IA per la reazione finale
    callForeignReaction(neighbor, aiReactionContext);

    // 3. Chiudi stato diplomatico
    activeDiplomacy.active = false;
    updateUI();
}

async function callForeignReaction(neighbor, context) {
    const systemPrompt = `
    SEI ANCORA ${neighbor.ruler}.
    Il giocatore ha risposto.
    
    ISTRUZIONI DI REAZIONE:
    ${context}
    
    Rispondi con una sola frase diretta.
    `;

    try {
        const resp = await fetch("https://api.groq.com/openai/v1/chat/completions", {
            method: "POST",
            headers: { "Content-Type":"application/json", "Authorization":"Bearer " + apiKey },
            body: JSON.stringify({
                model: "llama-3.1-8b-instant",
                messages: [{ role: "system", content: systemPrompt }]
            })
        });
        const data = await resp.json();
        const msg = data.choices[0].message.content;
        addForeignMsg(neighbor.key, neighbor.name, msg);
        publicChatHistory.push({ role: "assistant", content: `${neighbor.name}: "${msg}"` });
    } catch(e) {}
}

/* ===================== SISTEMA DI STABILITÀ E GAME OVER ===================== */

function checkInternalStability() {
    let dead = false;

    // 1. Controllo Statistiche Globali (Salute/Felicità 0)
    if (county.health <= 0) {
        triggerGameOver("plague");
        return;
    }
    if (county.happy <= 0) {
        triggerGameOver("anarchy");
        return;
    }

    // 2. Controllo Fazioni
    factionOrder.forEach(key => {
        if (dead) return; // Se sei già morto, stop

        const loyalty = factions[key];
        
        // Se la lealtà è critica (< 20), aumenta la rabbia (era <= 30)
        if (loyalty <= 20) {
            rebellionState[key]++;
            handleUnrestEscalation(key, rebellionState[key]);
        } 
        // Se la lealtà torna alta (> 40), la rabbia scende più velocemente (era > 50)
        else if (loyalty >= 40 && rebellionState[key] > 0) {
            rebellionState[key] -= 2; // Scende più velocemente (era -1)
        }
        // Se la lealtà è media (> 30), la rabbia scende lentamente
        else if (loyalty >= 30 && rebellionState[key] > 0) {
            rebellionState[key]--;
        }
    });
}

function handleUnrestEscalation(factionKey, level) {
    const name = factionLabel(factionKey);
    
    // LIVELLO 1: Avvertimento
    if (level === UNREST_WARNING) {
        addMsg("system", `⚠️ <strong>Tensione:</strong> I ${name} sono furiosi. Si mormora di tradimento.`);
        publicChatHistory.push({ role: "system", content: `[ALLARME] I ${name} stanno pianificando qualcosa contro il Conte.` });
    }
    
    // LIVELLO 2: Sabotaggio (Danni economici)
    else if (level === UNREST_DANGER) {
        addMsg("system", `🔥 <strong>Sabotaggio:</strong> I ${name} hanno colpito le tue proprietà per protesta.`);
        
        if (factionKey === 'nobility' || factionKey === 'merchants') {
            county.gold = Math.max(0, county.gold - 200); // Furto o blocco fondi
        } else {
            // Danni fisici
            county.security -= 5;
            if (county.resources.grain) county.resources.grain -= 50; // Incendio granai
        }
        updateUI();
    }
    
    // LIVELLO 3: IL COLPO FINALE (Resa dei conti)
    else if (level >= UNREST_REVOLT) {
        triggerRevoltEvent(factionKey);
    }
}

function triggerRevoltEvent(factionKey) {
    // Reset del timer per evitare loop infiniti nello stesso turno
    rebellionState[factionKey] = 5; 

    // CASO A: RIVOLTA ARMATA (Contadini, Emarginati, Borghesi)
    if (['peasants', 'outcasts', 'burghers'].includes(factionKey)) {
        const rebelCount = populationGroups[factionKey].count;
        addMsg("system", `🔥 <strong>INSURREZIONE!</strong> Una folla di ${rebelCount} ${factionLabel(factionKey)} marcia sul castello con torce e forconi!`);
        
        // Scelta del giocatore
        const actions = [
            { label: "⚔️ Ordina alla Milizia di disperderli (Sangue)", code: `revolt_crush_${factionKey}` },
            { label: "🗣️ Tenta di calmarli di persona (Rischioso)", code: `revolt_speak_${factionKey}` },
            { label: "🏃 Fuggi dai passaggi segreti (Abdicazione)", code: `gameover_abdicate` }
        ];
        appendActionsBlock(actions);
    }
    
    // CASO B: COLPO DI STATO MILITARE (Milizia)
    else if (factionKey === 'militia') {
        addMsg("system", `⚔️ <strong>TRADIMENTO!</strong> Il Capitano Ronan entra nella sala del trono con la spada sguainata. "La contea ha bisogno di un leader forte..."`);
        
        // Se hai mercenari o nobili fedeli, forse ti salvi
        if (buildings.find(b => b.type === 'mercenary_camp' && b.stage === 'complete')) {
            const actions = [
                { label: "💰 Paga i Mercenari per difenderti (-300 oro)", code: `coup_mercenaries` },
                { label: "💀 Affrontalo a duello", code: `coup_duel` }
            ];
            appendActionsBlock(actions);
        } else {
            triggerGameOver("coup");
        }
    }
    
    // CASO C: INTRIGO E VELENO (Nobili, Clero, Mercanti, Mistici)
    else {
        triggerAssassinationAttempt(factionKey);
    }
}

// Gestione Assassinio
function triggerAssassinationAttempt(factionKey) {
    // Calcolo probabilità sopravvivenza - MOLTO MIGLIORATA
    // Base 50% (era 30%) + Bonus Sicurezza (max 30%) + Bonus Spie (20%) + Bonus Edifici (10%)
    let survivalChance = 0.5; // Base aumentata da 0.3 a 0.5
    
    // Bonus sicurezza più generoso
    if (county.security > 70) survivalChance += 0.3;
    else if (county.security > 50) survivalChance += 0.2;
    else if (county.security > 30) survivalChance += 0.1;
    
    // Bonus spie
    if (factions.outcasts > 70) survivalChance += 0.2;
    else if (factions.outcasts > 50) survivalChance += 0.1;
    
    // Bonus edifici difensivi
    if (buildings.find(b => (b.type === 'walls' || b.type === 'stone_walls') && b.stage === 'complete')) {
        survivalChance += 0.05;
    }
    if (buildings.find(b => b.type === 'watchtower' && b.stage === 'complete')) {
        survivalChance += 0.05;
    }
    
    // Cap massimo al 95% (sempre un minimo rischio)
    survivalChance = Math.min(0.95, survivalChance);
    
    addMsg("system", `🕵️ Un'ombra si muove nella notte... I ${factionLabel(factionKey)} hanno inviato un assassino.`);
    
    if (Math.random() < survivalChance) {
        // SALVO
        addMsg("system", `🛡️ <strong>SVENTATO!</strong> Le tue guardie hanno intercettato l'assassino all'ultimo secondo. La minaccia è passata, ma la tensione resta.`);
        rebellionState[factionKey] = Math.max(0, rebellionState[factionKey] - 3); // Reset maggiore
    } else {
        // MORTO
        triggerGameOver("assassination", factionKey);
    }
}

async function triggerGameOver(type, factionKey = "") {
    const modal = document.getElementById("modal-gameover");
    const storyDiv = document.getElementById("gameover-story");
    const factionName = factionKey ? factionLabel(factionKey) : "il destino";
    
    // Mostra subito il modale
    modal.classList.add("active");
    storyDiv.innerHTML = "<em>Scrivendo l'ultimo capitolo...</em>";
    
    // Prompt per l'IA
    let promptContext = "";
    switch(type) {
        case "plague": promptContext = "Il Conte è morto di peste, abbandonato da tutti nel castello infetto."; break;
        case "anarchy": promptContext = "L'anarchia regna. Il Conte è morto linciato dai suoi stessi sudditi in una rivolta generale."; break;
        case "coup": promptContext = "Il Capitano della Guardia ha decapitato il Conte e preso il potere."; break;
        case "assassination": promptContext = `Il Conte è stato avvelenato durante un banchetto dai ${factionName}.`; break;
        case "overrun": promptContext = `La milizia ha fallito. Una folla di ${factionName} ha invaso il castello e fatto a pezzi il Conte.`; break;
        case "mob_kill": promptContext = "Il Conte ha provato a parlare alla folla, ma è stato colpito da una pietra e linciato."; break;
        case "abdication": promptContext = "Il Conte è fuggito nella notte, vivendo il resto dei suoi giorni in esilio come un mendicante."; break;
    }

    const systemPrompt = `
    Scrivi un breve epitaffio drammatico (max 3 frasi) per il Conte ${heroName}.
    CAUSA MORTE: ${promptContext}
    Anno: ${worldTime.year}.
    Usa un tono solenne e tragico.
    `;

    try {
        const resp = await fetch("https://api.groq.com/openai/v1/chat/completions", {
            method: "POST",
            headers: { "Content-Type":"application/json", "Authorization":"Bearer " + apiKey },
            body: JSON.stringify({
                model: "llama-3.1-8b-instant",
                messages: [{ role: "system", content: systemPrompt }]
            })
        });
        const data = await resp.json();
        storyDiv.innerText = data.choices[0].message.content;
    } catch(e) {
        storyDiv.innerText = promptContext;
    }

    // Aggiorna statistiche finali
    document.getElementById("go-years").innerText = `${worldTime.year - 1325} anni`;
    
    // Pulisci salvataggio (Permadeath opzionale)
    // safeStorageRemove("conte_save_autosave");
}

function buildPrompt(userText, mode) {
    // 1. Genera il contesto completo e aggiornato
    const fullContext = generateDeepContext();
    
    // 2. Calcola azioni possibili (per aiutare l'IA a suggerire cose sensate)
    const feasibleOptions = getFeasibleActions();

    // 3. Costruisci il System Prompt (Il "cervello" dell'IA)
    let systemText = "";

    if (mode === "action") {
        systemText = `
SEI IL GAME MASTER E NARRATORE DI UN GIOCO STRATEGICO MEDIEVALE.
Il tuo compito è rispondere alle azioni del Conte (l'utente) basandoti RIGOROSAMENTE sui dati attuali del regno.

${fullContext}

=== REGOLE DI RISPOSTA ===
1. **Coerenza**: Se c'è carestia (Cibo basso), i contadini devono lamentarsi. Se c'è tanto Oro, i mercanti devono proporre affari. Non inventare risorse che non esistono.
2. **Stile**: Usa un tono appropriato all'epoca. Sii descrittivo ma conciso (max 3 frasi per la scena).
3. **Reattività**: Reagisci direttamente all'input dell'utente "${userText}".
4. **Output Strutturato**:
   - Inizia con "SCENA: " per descrivere l'atmosfera o la reazione immediata.
   - Usa "NOME_FAZIONE: " se qualcuno parla (es. "Odric: ...").
   - Alla fine, fornisci una lista "AZIONI:" basata sulle opzioni fattibili qui sotto.

=== OPZIONI FATTIBILI DA SUGGERIRE (Scegline 2 o 3 pertinenti) ===
${feasibleOptions}
`;
    } 
    
    else if (mode === "advice") {
        systemText = `
SEI SER DORIAN, IL CONSIGLIERE DI CORTE.
Parli in modo saggio, pragmatico e diretto.
Analizza i dati seguenti e dai un consiglio strategico urgente.

${fullContext}

Tuo compito:
Identifica il problema più critico (es. Cibo scarso, bassa Sicurezza, Fazioni ribelli) e suggerisci una soluzione concreta (es. Costruire edificio X, Alzare tasse, Fare accordi).
Non dilungarti in saluti. Vai al punto.
`;
    }

    return {
        system: systemText,
        user: userText
    };
}

function buildPrivatePrompt(factionKey, userText){
    const name = getChatName(factionKey);
    
    return {
        system: `
Tu sei ${name}. Non sei un'IA, sei un personaggio vivo in questo castello.
Parla in prima persona. Sii emotivo, manipolatore o servile in base alla tua lealtà (${factions[factionKey]}).
Usa dettagli sensoriali (la tua voce trema, batti il pugno sul tavolo, sussurri).

IMPORTANTE: Alla fine della tua risposta, se hai fatto una richiesta o esposto un problema, suggerisci implicitamente cosa dovrebbe fare il Conte (es. "Costruite quel mercato, mio signore, o moriremo di fame", "Firmate l'editto, ve ne prego").

Non usare liste puntate qui, usa solo il dialogo diretto.
`,
        user: userText
    };
}


/* ============================================================
   ======================== AI PARSING ==========================
   ============================================================ */

function handleAIResponse(response, mode) {
    // Rimuovi residui JSON
    response = response.replace(/\{[\s\S]*\}/g, "").trim();

    // ======================================================
    // 1. GESTIONE CONSIGLIERE (Barra Laterale)
    // ======================================================
    if (mode === "advice") {
        const feed = document.getElementById("advice-feed");
        if (!feed) return;

        // Rimuovi il messaggio "vuoto" se c'è
        const empty = feed.querySelector(".advice-empty");
        if (empty) empty.remove();

        // Crea la card del consiglio
        const card = document.createElement("div");
        card.className = "event-card";
        // Stile dorato specifico per Ser Dorian
        card.style.borderLeft = "3px solid #d4af37"; 
        card.style.background = "rgba(20, 20, 20, 0.9)";
        card.style.marginBottom = "8px";
        
        // Formattazione del testo (grassetto per i punti chiave)
        const formattedText = response.replace(/\*\*(.*?)\*\*/g, '<strong style="color:#d4af37">$1</strong>');

        card.innerHTML = `
            <div class="event-time" style="color:#666; font-size:0.7em; margin-bottom:4px;">${timestamp()} - Turno ${county.turn}</div>
            <div class="msg-text" style="font-size:0.9em; line-height:1.4;">${formattedText}</div>
        `;

        // Inserisci in cima
        feed.prepend(card);
        return; // <--- IMPORTANTE: Ferma qui la funzione!
    }

    // ======================================================
    // 2. GESTIONE CHAT PUBBLICA (Scene, Dialoghi, Azioni)
    // ======================================================
    
    const parts = response.split("AZIONI:");
    const scriptContent = parts[0].trim();
    const actionsContent = parts.length > 1 ? parts[1].trim() : "";
    const lines = scriptContent.split('\n').filter(line => line.trim() !== '');
    const chatLog = document.getElementById("chat-log");

    lines.forEach((line, index) => {
        setTimeout(() => {
            const cleanLine = line.trim();
            
            if (cleanLine.startsWith("SCENA:")) {
                const content = cleanLine.replace("SCENA:", "").trim();
                const div = document.createElement("div");
                div.className = "msg-scene";
                div.innerText = content;
                chatLog.appendChild(div);
            } 
            else if (cleanLine.includes(":")) {
                const splitIndex = cleanLine.indexOf(":");
                const name = cleanLine.substring(0, splitIndex).trim();
                const msg = cleanLine.substring(splitIndex + 1).trim();
                
                const div = document.createElement("div");
                div.className = "msg-char";
                div.innerHTML = `<span class="char-name">${name}</span><span class="char-text">${msg}</span>`;
                chatLog.appendChild(div);
            }
            else {
                const div = document.createElement("div");
                div.className = "msg-scene";
                div.innerText = cleanLine;
                chatLog.appendChild(div);
            }
            chatLog.scrollTop = chatLog.scrollHeight;

        }, index * 2200);
    });

    if (actionsContent) {
        setTimeout(() => {
            const { actions } = extractActionsFromRawText(actionsContent);
            
            const actionDiv = document.createElement("div");
            actionDiv.className = "msg-actions";
            actionDiv.innerHTML = `<div class="action-header">Ordini Disponibili</div>`;
            
            actions.forEach(act => {
                const btn = document.createElement("button");
                btn.className = "btn-sec";
                btn.style.width = "100%";
                btn.style.marginBottom = "5px";
                btn.style.textAlign = "left";
                btn.innerHTML = `<strong>${act.title}</strong>: ${act.desc}`;
                btn.onclick = () => {
                    document.getElementById("u-input").value = act.title;
                };
                actionDiv.appendChild(btn);
            });

            chatLog.appendChild(actionDiv);
            chatLog.scrollTop = chatLog.scrollHeight;
        }, lines.length * 1200 + 500);
    }

    // === BLOCCO DI AZIONI GENERATO IN AUTOMATICO ===
    setTimeout(() => {
        const dynamicActions = getDynamicActions(response);
        if (dynamicActions.length > 0) {
            appendActionsBlock(dynamicActions);
        }
    }, lines.length * 1200 + 1000);
}

function extractActionsFromRawText(text) {
    const actions = [];
    let remainingText = text;
    
    // Cerca righe che iniziano con "- **[title]**: desc"
    const actionRegex = /- \*\*\[([^\]]+)\]\*\*: (.+)/g;
    let match;
    while ((match = actionRegex.exec(text)) !== null) {
        const title = match[1].trim();
        const desc = match[2].trim();
        actions.push({ title, desc });
        remainingText = remainingText.replace(match[0], '').trim();
    }
    
    return { remainingText, actions };
}


/* ============================================================
   ============ GESTIONE SCHERMATE E AVVIO GIOCO ===============
   ============================================================ */

/* ============================================================
   =================== GRAFICA MAPPA "MEDIEVALE" ==============
   ============================================================ */

// Nuova Palette: Toni desaturati e naturali
const MEDIAEVAL_PALETTE = {
    paper: "#f4ecd8",         // Sfondo pergamena
    grid: "rgba(62, 39, 35, 0.1)", // Griglia stile matita leggera
    
    // Terreni
    plains: "#d8e2b6",        // Verde pallido / giallastro
    forest: "#8fac76",        // Verde salvia scuro
    hills: "#e6d6ad",         // Sabbia scura
    mountain: "#cfcfc4",      // Grigio pietra chiaro
    mountainPeak: "#8c8c8c",  // Grigio scuro per i picchi
    swamp: "#aeb58d",         // Verde marcio/grigiastro
    water: "#a4c4d6",         // Azzurro carta da zucchero
    waterDeep: "#89abbd",     // Dettagli acqua

    // Bordi proprietà
    borders: {
        count: "#d4af37",     // Oro
        nobility: "#8b0000",  // Rosso scuro inchiostro
        clergy: "#483d8b",    // Blu scuro ardesia
        commons: "#2f4f4f"    // Grigio ardesia scuro
    }
};

// Funzione per disegnare un "rumore" carta sopra la mappa
function drawPaperTexture(ctx, width, height) {
    const numGrains = (width * height) / 200; 
    ctx.fillStyle = "rgba(62, 39, 35, 0.03)";
    for (let i = 0; i < numGrains; i++) {
        const x = Math.random() * width;
        const y = Math.random() * height;
        const r = Math.random() * 2;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Disegna i dettagli specifici per ogni tipo di terreno
function drawTileVisuals(ctx, x, y, size, tile) {
    // 1. Sfondo base del tile
    ctx.fillStyle = MEDIAEVAL_PALETTE[tile.terrain] || "#fff";
    ctx.fillRect(x, y, size, size);

    // 2. Dettagli interni (Disegno a mano libera simulato)
    const cx = x + size / 2;
    const cy = y + size / 2;

    switch (tile.terrain) {
        case "forest":
            // Disegna 3 alberelli stilizzati (triangoli/cerchi)
            ctx.fillStyle = "#5e754a"; // Verde più scuro per le chiome
            drawTree(ctx, cx - 4, cy + 2, 3);
            drawTree(ctx, cx + 4, cy + 4, 4);
            drawTree(ctx, cx, cy - 4, 4);
            break;

        case "mountain":
            // Disegna un picco montuoso
            ctx.fillStyle = MEDIAEVAL_PALETTE.mountainPeak;
            ctx.beginPath();
            ctx.moveTo(x + 2, y + size - 2);
            ctx.lineTo(cx, y + 2);
            ctx.lineTo(x + size - 2, y + size - 2);
            ctx.fill();
            // Neve in cima
            ctx.fillStyle = "#fff";
            ctx.beginPath();
            ctx.moveTo(cx - 3, y + 10); // Punto sulla sinistra
            ctx.lineTo(cx, y + 2);      // Cima
            ctx.lineTo(cx + 3, y + 10); // Punto sulla destra
            ctx.fill();
            break;

        case "hills":
            // Disegna due curve morbide
            ctx.fillStyle = "#c2b280";
            ctx.beginPath();
            ctx.arc(cx - 3, cy + 4, 5, Math.PI, 0);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(cx + 3, cy + 2, 4, Math.PI, 0);
            ctx.fill();
            break;

        case "swamp":
            // Lineette orizzontali e colori scuri
            ctx.strokeStyle = "#6b705c";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + 4, y + size - 6); ctx.lineTo(x + 10, y + size - 6);
            ctx.moveTo(x + 12, y + 6); ctx.lineTo(x + 18, y + 6);
            ctx.moveTo(cx - 3, cy); ctx.lineTo(cx + 3, cy);
            ctx.stroke();
            break;

        case "lake":
        case "water":
            // Onde stilizzate
            ctx.strokeStyle = MEDIAEVAL_PALETTE.waterDeep;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(cx - 4, cy, 3, 0, Math.PI, false);
            ctx.arc(cx + 2, cy, 3, 0, Math.PI, false);
            ctx.stroke();
            break;
            
        case "plains":
            // Un piccolo ciuffo d'erba occasionale (non su tutti per pulizia)
            if ((x + y) % 3 === 0) {
                ctx.strokeStyle = "#889c6b";
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(cx, cy); ctx.lineTo(cx - 2, cy - 4);
                ctx.moveTo(cx, cy); ctx.lineTo(cx + 2, cy - 4);
                ctx.stroke();
            }
            break;
    }
}

function drawTree(ctx, x, y, r) {
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();
}

// Funzione Principale di Disegno Mappa
function drawCountyMap() {
    const canvas = document.getElementById("county-map");
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    
    // Assicura che worldMap sia caricato
    if (!worldMap || !worldMap.tiles || worldMap.tiles.length === 0) return;
    
    const tileSize = canvas.width / worldMap.width;

    // 1. Sfondo carta pergamena con texture migliorata
    ctx.fillStyle = MEDIAEVAL_PALETTE.paper;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // 2. Disegna Terreno con colori più realistici
    for (let y = 0; y < worldMap.height; y++) {
        for (let x = 0; x < worldMap.width; x++) {
            const tile = getTile(x, y);
            if (!tile) continue;
            drawTileVisuals(ctx, x * tileSize, y * tileSize, tileSize, tile);
        }
    }

    // 3. Texture Carta (Sopra il terreno, sotto l'UI)
    drawPaperTexture(ctx, canvas.width, canvas.height);

    // 4. Griglia leggera stile mappa medievale
    ctx.strokeStyle = MEDIAEVAL_PALETTE.grid;
    ctx.lineWidth = 0.5;
    ctx.beginPath();
    for (let i = 0; i <= worldMap.width; i++) {
        ctx.moveTo(i * tileSize, 0); ctx.lineTo(i * tileSize, canvas.height);
        ctx.moveTo(0, i * tileSize); ctx.lineTo(canvas.width, i * tileSize);
    }
    ctx.stroke();

    // 5. Bordi Proprietà (Stile inchiostro medievale)
    drawOwnershipBorders(ctx, tileSize);

    // 6. Insediamenti (villaggi con casette)
    drawSettlements(ctx, tileSize);
    
    // 7. Strutture produttive (miniere, segherie, cave, monasteri)
    drawStructureMarkers(ctx, tileSize);
    
    // 8. NUOVO: Edifici costruiti (dalla sintesi insediamenti)
    drawBuildingMarkers(ctx, tileSize);
    
    // 9. NUOVO: Legenda integrata nella mappa
    drawMapLegend(ctx, canvas.width, canvas.height);
    
    // 10. Vignettatura finale per effetto antico
    drawVignette(ctx, canvas.width, canvas.height);
}

function drawOwnershipBorders(ctx, size) {
    // Linee più spesse e tratteggiate per sembrare confini politici
    ctx.setLineDash([4, 2]); 
    
    for (let y = 0; y < worldMap.height; y++) {
        for (let x = 0; x < worldMap.width; x++) {
            const tile = getTile(x, y);
            if (!tile || !tile.owner || tile.owner === 'wild') continue;

            const px = x * size;
            const py = y * size;
            const color = MEDIAEVAL_PALETTE.borders[tile.owner] || "rgba(0,0,0,0.5)";

            const neighbors = [
                {dx: 0, dy: -1}, {dx: 1, dy: 0}, {dx: 0, dy: 1}, {dx: -1, dy: 0}
            ];

            neighbors.forEach(n => {
                const nx = x + n.dx;
                const ny = y + n.dy;
                const nTile = getTile(nx, ny);
                
                // Disegna bordo se il vicino è diverso
                if (!nTile || nTile.owner !== tile.owner) {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    if (n.dx === 0 && n.dy === -1) { // Sopra
                        ctx.moveTo(px, py); ctx.lineTo(px + size, py);
                    } else if (n.dx === 1 && n.dy === 0) { // Destra
                        ctx.moveTo(px + size, py); ctx.lineTo(px + size, py + size);
                    } else if (n.dx === 0 && n.dy === 1) { // Sotto
                        ctx.moveTo(px, py + size); ctx.lineTo(px + size, py + size);
                    } else if (n.dx === -1 && n.dy === 0) { // Sinistra
                        ctx.moveTo(px, py); ctx.lineTo(px, py + size);
                    }
                    ctx.stroke();
                }
            });
        }
    }
    ctx.setLineDash([]); // Resetta tratteggio
}

// Aggiornamento icone strutture (più pulite)
function drawStructureMarkers(ctx, tileSize) {
    const center = tileSize / 2;

    // Helper per disegnare icone
    const drawIcon = (list, color, char) => {
        ctx.fillStyle = "rgba(255, 255, 255, 0.8)"; // Sfondo per leggibilità
        ctx.font = "14px Segoe UI Emoji"; 
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        
        list.forEach(s => {
            const x = s.x * tileSize + center;
            const y = s.y * tileSize + center;
            // Piccolo alone chiaro sotto l'icona
            ctx.beginPath();
            ctx.arc(x, y, 8, 0, Math.PI*2);
            ctx.fill();
            
            // Icona
            ctx.fillStyle = "#000"; // Colore testo
            ctx.fillText(char, x, y + 1);
        });
    }

    // Usa Emoji o caratteri invece di forme geometriche astratte
    drawIcon(structures.mines, "#333", "⛏️");
    drawIcon(structures.sawmills, "#228B22", "🪚");
    drawIcon(structures.quarries, "#696969", "🧱");
    drawIcon(structures.monasteries, "#800080", "⛪");
}

// NUOVA FUNZIONE: Disegna gli edifici costruiti sulla mappa
function drawBuildingMarkers(ctx, tileSize) {
    const center = tileSize / 2;
    
    // Mappa icone per tipo di edificio
    const buildingIcons = {
        market: "🏪",
        barracks: "⚔️",
        walls: "🏰",
        church: "⛪",
        grand_cathedral: "⛪",
        forge: "🔨",
        watchtower: "🗼",
        library: "📚",
        hospital: "⚕️",
        theater: "🎭",
        university: "🎓",
        mint: "💰",
        guild_hall: "🏛️",
        courthouse: "⚖️",
        granary: "🌾",
        mill: "⚙️",
        tavern: "🍺",
        inn: "🏠",
        stable: "🐴",
        workshop: "🔧",
        cottage: "🏘️",
        tenement: "🏢",
        noble_estate: "🏛️",
        mercenary_camp: "⛺",
        training_ground: "🎯",
        armory: "🛡️",
        siege_workshop: "🎯"
    };
    
    ctx.font = "16px Segoe UI Emoji"; 
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    
    // Disegna solo gli edifici completati
    buildings.forEach(b => {
        if (b.stage !== 'complete') return;
        
        const icon = buildingIcons[b.type] || "🏗️";
        const x = b.x * tileSize + center;
        const y = b.y * tileSize + center;
        
        // Sfondo bianco leggermente più grande per edifici importanti
        ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
        ctx.beginPath();
        ctx.arc(x, y, 10, 0, Math.PI*2);
        ctx.fill();
        
        // Bordo dorato per edifici del conte
        ctx.strokeStyle = "rgba(212, 175, 55, 0.8)";
        ctx.lineWidth = 1.5;
        ctx.stroke();
        
        // Icona edificio
        ctx.fillStyle = "#000";
        ctx.fillText(icon, x, y + 1);
    });
}

// NUOVA FUNZIONE: Legenda integrata nella mappa
function drawMapLegend(ctx, width, height) {
    const legendX = 10;
    const legendY = height - 140;
    const lineHeight = 18;
    
    // Sfondo semitrasparente per la legenda
    ctx.fillStyle = "rgba(244, 236, 216, 0.95)";
    ctx.strokeStyle = "#8b7355";
    ctx.lineWidth = 2;
    ctx.fillRect(legendX, legendY, 145, 130);
    ctx.strokeRect(legendX, legendY, 145, 130);
    
    // Titolo legenda
    ctx.fillStyle = "#3e2723";
    ctx.font = "bold 11px Georgia";
    ctx.textAlign = "left";
    ctx.fillText("Legenda Dettagliata", legendX + 10, legendY + 15);
    
    // Voci della legenda con descrizioni
    ctx.font = "9px Georgia";
    const legendItems = [
        { icon: "🏘️", text: "Insediamenti" },
        { icon: "🏪", text: "Piazza Mercato" },
        { icon: "🏠", text: "Case & Strade" },
        { icon: "⛏️", text: "Miniere" },
        { icon: "🪚", text: "Segherie" },
        { icon: "🧱", text: "Cave di Pietra" },
        { icon: "⛪", text: "Luoghi Sacri" },
        { icon: "🏰", text: "Edifici Speciali" }
    ];
    
    legendItems.forEach((item, i) => {
        const y = legendY + 32 + (i * lineHeight);
        // Icona
        ctx.font = "11px Segoe UI Emoji";
        ctx.fillText(item.icon, legendX + 12, y);
        // Testo
        ctx.font = "9px Georgia";
        ctx.fillStyle = "#3e2723";
        ctx.fillText(item.text, legendX + 32, y);
    });
    
    // Nota in basso
    ctx.font = "italic 8px Georgia";
    ctx.fillStyle = "#666";
    ctx.fillText("Zoom sulla mappa", legendX + 10, legendY + 125);
    ctx.fillText("per vedere i dettagli", legendX + 10, legendY + 135);
}

function drawSettlements(ctx, tileSize) {
    settlements.forEach((s, index) => {
        const baseX = s.x * tileSize;
        const baseY = s.y * tileSize;
        const centerX = baseX + tileSize / 2;
        const centerY = baseY + tileSize / 2;
        
        // Determina dimensione del villaggio
        const villageSize = s.size || (index === 0 ? 3 : 2); // Il primo è il più grande
        
        // 1. SFONDO AREA INSEDIAMENTO (terreno ripulito)
        ctx.fillStyle = "rgba(245, 235, 220, 0.6)";
        ctx.fillRect(baseX + 2, baseY + 2, tileSize - 4, tileSize - 4);
        
        // 2. STRADE PRINCIPALI (croce centrale)
        ctx.strokeStyle = "#b8a88a";
        ctx.lineWidth = 3;
        ctx.lineCap = "round";
        
        // Strada verticale
        ctx.beginPath();
        ctx.moveTo(centerX, baseY);
        ctx.lineTo(centerX, baseY + tileSize);
        ctx.stroke();
        
        // Strada orizzontale
        ctx.beginPath();
        ctx.moveTo(baseX, centerY);
        ctx.lineTo(baseX + tileSize, centerY);
        ctx.stroke();
        
        // Bordi strade (più scuri)
        ctx.strokeStyle = "#9a8b72";
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        ctx.moveTo(centerX - 1.5, baseY);
        ctx.lineTo(centerX - 1.5, baseY + tileSize);
        ctx.moveTo(centerX + 1.5, baseY);
        ctx.lineTo(centerX + 1.5, baseY + tileSize);
        ctx.moveTo(baseX, centerY - 1.5);
        ctx.lineTo(baseX + tileSize, centerY - 1.5);
        ctx.moveTo(baseX, centerY + 1.5);
        ctx.lineTo(baseX + tileSize, centerY + 1.5);
        ctx.stroke();
        
        // 3. PIAZZA CENTRALE CON MERCATO
        drawMarketSquare(ctx, centerX, centerY, villageSize);
        
        // 4. CASE DISPOSTE LUNGO LE STRADE
        const housePositions = [
            // Quadrante Nord-Ovest
            {x: centerX - 12, y: centerY - 12, rotation: 0},
            {x: centerX - 20, y: centerY - 8, rotation: 0},
            {x: centerX - 12, y: centerY - 20, rotation: 0},
            // Quadrante Nord-Est
            {x: centerX + 8, y: centerY - 12, rotation: 0},
            {x: centerX + 16, y: centerY - 8, rotation: 0},
            {x: centerX + 8, y: centerY - 20, rotation: 0},
            // Quadrante Sud-Ovest
            {x: centerX - 12, y: centerY + 8, rotation: 0},
            {x: centerX - 20, y: centerY + 12, rotation: 0},
            {x: centerX - 12, y: centerY + 16, rotation: 0},
            // Quadrante Sud-Est
            {x: centerX + 8, y: centerY + 8, rotation: 0},
            {x: centerX + 16, y: centerY + 12, rotation: 0},
            {x: centerX + 8, y: centerY + 16, rotation: 0}
        ];
        
        // Disegna case in base alla dimensione del villaggio
        const numHouses = Math.min(housePositions.length, 4 + (villageSize * 3));
        for (let i = 0; i < numHouses; i++) {
            const pos = housePositions[i];
            drawHouse(ctx, pos.x, pos.y, pos.rotation);
        }
        
        // 5. EDIFICI SPECIALI se presenti
        drawVillageBuildings(ctx, s, centerX, centerY, tileSize);
        
        // 6. MURA se costruite
        drawVillageWalls(ctx, baseX, baseY, tileSize, s);
    });
}

function drawHouse(ctx, x, y, rotation) {
    ctx.save();
    ctx.translate(x, y);
    if (rotation) ctx.rotate(rotation * Math.PI / 180);
    
    // Ombra
    ctx.fillStyle = "rgba(0, 0, 0, 0.15)";
    ctx.fillRect(1, 1, 6, 5);
    
    // Corpo casa (legno)
    ctx.fillStyle = "#8B6F47";
    ctx.fillRect(0, 2, 6, 4);
    ctx.strokeStyle = "#5D4037";
    ctx.lineWidth = 0.5;
    ctx.strokeRect(0, 2, 6, 4);
    
    // Tetto (rosso/marrone)
    ctx.fillStyle = "#A0522D";
    ctx.beginPath();
    ctx.moveTo(-1, 2);
    ctx.lineTo(3, -1);
    ctx.lineTo(7, 2);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    // Dettagli tetto
    ctx.strokeStyle = "#7a3d1f";
    ctx.lineWidth = 0.3;
    ctx.beginPath();
    ctx.moveTo(0, 1.5);
    ctx.lineTo(6, 1.5);
    ctx.moveTo(-0.5, 1);
    ctx.lineTo(6.5, 1);
    ctx.stroke();
    
    // Porta
    ctx.fillStyle = "#4a3728";
    ctx.fillRect(2, 3, 2, 3);
    
    // Finestra
    ctx.fillStyle = "#e8d7b8";
    ctx.fillRect(0.5, 3.5, 1.2, 1.2);
    
    ctx.restore();
}

function drawMarketSquare(ctx, centerX, centerY, size) {
    // Piazza pavimentata
    ctx.fillStyle = "#d4c5a9";
    ctx.beginPath();
    ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
    ctx.fill();
    
    // Bordo piazza
    ctx.strokeStyle = "#a89c7a";
    ctx.lineWidth = 1;
    ctx.stroke();
    
    // Pattern pavimentazione
    ctx.strokeStyle = "rgba(0, 0, 0, 0.08)";
    ctx.lineWidth = 0.3;
    for (let i = -8; i <= 8; i += 2) {
        ctx.beginPath();
        ctx.moveTo(centerX + i, centerY - 8);
        ctx.lineTo(centerX + i, centerY + 8);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(centerX - 8, centerY + i);
        ctx.lineTo(centerX + 8, centerY + i);
        ctx.stroke();
    }
    
    // Bancarella mercato
    const marketStalls = [
        {x: -4, y: -4},
        {x: 4, y: -4},
        {x: -4, y: 4},
        {x: 4, y: 4}
    ];
    
    marketStalls.forEach(stall => {
        // Tenda
        ctx.fillStyle = "#c74440";
        ctx.beginPath();
        ctx.moveTo(centerX + stall.x - 2, centerY + stall.y);
        ctx.lineTo(centerX + stall.x, centerY + stall.y - 2);
        ctx.lineTo(centerX + stall.x + 2, centerY + stall.y);
        ctx.lineTo(centerX + stall.x + 2, centerY + stall.y + 2);
        ctx.lineTo(centerX + stall.x - 2, centerY + stall.y + 2);
        ctx.closePath();
        ctx.fill();
        
        ctx.strokeStyle = "#8b2e2b";
        ctx.lineWidth = 0.3;
        ctx.stroke();
        
        // Strisce tenda
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 0.2;
        ctx.beginPath();
        ctx.moveTo(centerX + stall.x - 1, centerY + stall.y - 1.5);
        ctx.lineTo(centerX + stall.x - 1, centerY + stall.y + 2);
        ctx.moveTo(centerX + stall.x + 1, centerY + stall.y - 1.5);
        ctx.lineTo(centerX + stall.x + 1, centerY + stall.y + 2);
        ctx.stroke();
    });
    
    // Fontana/pozzo centrale (se villaggio grande)
    if (size >= 3) {
        ctx.fillStyle = "#8a8a8a";
        ctx.strokeStyle = "#5a5a5a";
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        ctx.arc(centerX, centerY, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        // Acqua
        ctx.fillStyle = "#6bb6ff";
        ctx.beginPath();
        ctx.arc(centerX, centerY, 1.2, 0, Math.PI * 2);
        ctx.fill();
    }
}

function drawVillageBuildings(ctx, settlement, centerX, centerY, tileSize) {
    // Cerca edifici completati in questa posizione
    const localBuildings = buildings.filter(b => 
        b.stage === 'complete' && 
        b.x === settlement.x && 
        b.y === settlement.y
    );
    
    if (localBuildings.length === 0) return;
    
    // Posizioni per edifici speciali (fuori dal centro)
    const buildingSpots = [
        {x: centerX - 18, y: centerY - 18, type: 'large'},
        {x: centerX + 14, y: centerY - 18, type: 'large'},
        {x: centerX - 18, y: centerY + 14, type: 'medium'},
        {x: centerX + 14, y: centerY + 14, type: 'medium'}
    ];
    
    localBuildings.slice(0, 4).forEach((building, i) => {
        const spot = buildingSpots[i];
        if (!spot) return;
        
        const buildingInfo = buildingData[building.type];
        if (!buildingInfo) return;
        
        // Disegna edificio più grande e dettagliato
        const width = spot.type === 'large' ? 10 : 8;
        const height = spot.type === 'large' ? 12 : 10;
        
        // Ombra
        ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
        ctx.fillRect(spot.x + 1, spot.y + 1, width, height);
        
        // Edificio principale
        ctx.fillStyle = "#c9b998";
        ctx.fillRect(spot.x, spot.y, width, height);
        
        // Bordi
        ctx.strokeStyle = "#8a7a5a";
        ctx.lineWidth = 1;
        ctx.strokeRect(spot.x, spot.y, width, height);
        
        // Finestre
        ctx.fillStyle = "#6b8bad";
        for (let row = 0; row < 2; row++) {
            for (let col = 0; col < 2; col++) {
                ctx.fillRect(
                    spot.x + 2 + col * 4,
                    spot.y + 2 + row * 4,
                    2, 2
                );
            }
        }
        
        // Tetto
        ctx.fillStyle = "#8b4513";
        ctx.beginPath();
        ctx.moveTo(spot.x - 1, spot.y);
        ctx.lineTo(spot.x + width/2, spot.y - 4);
        ctx.lineTo(spot.x + width + 1, spot.y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Porta
        ctx.fillStyle = "#4a3728";
        ctx.fillRect(spot.x + width/2 - 1.5, spot.y + height - 4, 3, 4);
    });
}

function drawVillageWalls(ctx, baseX, baseY, tileSize, settlement) {
    // Controlla se ci sono mura costruite
    const hasWalls = buildings.some(b => 
        (b.type === 'walls' || b.type === 'stone_walls') && 
        b.stage === 'complete' &&
        b.x === settlement.x && 
        b.y === settlement.y
    );
    
    if (!hasWalls) return;
    
    // Disegna mura perimetrali
    ctx.strokeStyle = "#8a8a8a";
    ctx.lineWidth = 3;
    ctx.strokeRect(baseX + 4, baseY + 4, tileSize - 8, tileSize - 8);
    
    // Dettagli merlature
    ctx.strokeStyle = "#6a6a6a";
    ctx.lineWidth = 1;
    const merlonSpacing = 6;
    
    // Merlature superiori
    for (let x = baseX + 4; x < baseX + tileSize - 4; x += merlonSpacing) {
        ctx.fillStyle = "#8a8a8a";
        ctx.fillRect(x, baseY + 3, 3, 2);
    }
    
    // Torri angolari
    const towers = [
        {x: baseX + 4, y: baseY + 4},
        {x: baseX + tileSize - 8, y: baseY + 4},
        {x: baseX + 4, y: baseY + tileSize - 8},
        {x: baseX + tileSize - 8, y: baseY + tileSize - 8}
    ];
    
    towers.forEach(tower => {
        // Base torre
        ctx.fillStyle = "#9a9a9a";
        ctx.fillRect(tower.x, tower.y, 4, 4);
        ctx.strokeStyle = "#6a6a6a";
        ctx.lineWidth = 0.5;
        ctx.strokeRect(tower.x, tower.y, 4, 4);
        
        // Tetto torre
        ctx.fillStyle = "#c74440";
        ctx.beginPath();
        ctx.moveTo(tower.x - 0.5, tower.y);
        ctx.lineTo(tower.x + 2, tower.y - 2);
        ctx.lineTo(tower.x + 4.5, tower.y);
        ctx.closePath();
        ctx.fill();
    });
}

// Etichette migliorate con sfondo carta
function drawLabel(ctx, s, size, label, color) {
    const x = s.x * size + size / 2;
    const y = s.y * size + size / 2 - 18; 

    ctx.font = "bold 10px Georgia";
    const textWidth = ctx.measureText(label).width;
    
    // Sfondo etichetta
    ctx.fillStyle = "rgba(244, 236, 216, 0.9)"; // Color pergamena chiaro
    ctx.strokeStyle = "#8b7355";
    ctx.lineWidth = 1;
    
    // Rettangolo arrotondato (simulato)
    const pad = 4;
    ctx.fillRect(x - textWidth/2 - pad, y - 8, textWidth + pad*2, 12);
    ctx.strokeRect(x - textWidth/2 - pad, y - 8, textWidth + pad*2, 12);

    ctx.fillStyle = "#3e2723"; // Inchiostro scuro
    ctx.textAlign = "center";
    ctx.fillText(label, x, y + 1);
}

function drawVignette(ctx, width, height) {
    const gradient = ctx.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, Math.max(width, height) / 2);
    gradient.addColorStop(0, "rgba(0,0,0,0)");
    gradient.addColorStop(0.7, "rgba(0,0,0,0.1)");
    gradient.addColorStop(1, "rgba(0,0,0,0.3)");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);
}

function loginManual() {
    const key = document.getElementById("api-key-input").value.trim();
    if (!key) {
        updateApiKeyStatus("Inserisci una chiave valida.", false);
        return;
    }
    setApiKey(key);
    activateScreen("screen-editor");
}

function startGame() {
    if (!ensureApiKey()) {
        updateApiKeyStatus("Imposta la chiave API prima di iniziare.", false);
        activateScreen("screen-login");
        return;
    }

    const enteredHero = document.getElementById("hero-name").value.trim();
    const enteredDesc = document.getElementById("county-desc-init").value.trim();
    const advisorName = document.getElementById("adv-name").value.trim();
    const advisorTone = document.getElementById("adv-pers").value;

    resetGameState();

    heroName = enteredHero || "Il Conte";
    dynasty.ruler.name = heroName;
    county.desc = enteredDesc || "Una giovane contea in attesa del suo destino…";
    advisor.name = advisorName || "Consigliere di Corte";
    advisor.personality = advisorTone || personalitySettings.advisorTone;

    // Genera tutto
    generateWorldMap();
    generateSettlements();
    autogenerateStructures();
    drawCountyMap();
    drawRegionMap();

    updateUI();
    updateDynastyUI();
    updateAssetSummaryUI(); // Popola la sintesi insediamenti

    activateScreen("screen-game");
    
    // Aggiorna nuovamente l'UI dopo che lo schermo è attivo
    setTimeout(() => updateUI(), 100);

    refreshAllStats();
    triggerStartupNarrative(true);

    addMsg("ai", `📜 Benvenuto, ${heroName}. Il tuo regno attende le tue decisioni.`);
    if (personalitySettings && personalitySettings.notes) {
        addMsg("system", `🖋️ Appunti della corte: ${personalitySettings.notes}`);
    }

    autoSaveGame();
}

function switchTab(id, btn){
    document.querySelectorAll(".tab-view").forEach(t => t.classList.remove("active-tab"));
    document.getElementById(id).classList.add("active-tab");

    document.querySelectorAll(".hud-nav-bar button").forEach(b => b.classList.remove("active"));
    if (btn) btn.classList.add("active");

    if (id === 'tab-market') renderMarket();
    if (id === 'tab-warehouse') renderWarehouse();
    if (id === 'tab-dominio') updateUI();
}

/* ================= GESTIONE MODULO EDIFICI ================= */

function openBuildingModal() {
    const modal = document.getElementById("modal-buildings");
    const grid = document.getElementById("building-grid");
    if(!modal || !grid) return;

    grid.innerHTML = "";
    
    Object.keys(buildingData).forEach(key => {
        const b = buildingData[key];
        const canBuild = checkResources(b.cost); 
        
        // Creazione HTML Costi
        let costHtml = "";
        Object.entries(b.cost).forEach(([res, amount]) => {
            // === CORREZIONE QUI ===
            // Se la risorsa è gold, controlliamo county.gold, altrimenti county.resources
            let have = 0;
            if (res === 'gold' || res === 'oro') {
                have = county.gold || 0;
            } else {
                have = county.resources[res] || 0;
            }
            // ======================

            const missingClass = have < amount ? "missing" : "";
            costHtml += `<span class="cost-item ${missingClass}">
                ${resourceIcon(res)} ${amount}
            </span>`;
        });

        const card = document.createElement("div");
        card.className = "building-card-ui";
        card.innerHTML = `
            <div class="b-header">
                <span class="b-title">${b.name}</span>
                <span class="b-time">⏳ ${b.time} turni</span>
            </div>
            <div class="b-desc">${b.desc}</div>
            <div class="b-effect">✨ ${b.effect}</div>
            <div class="b-cost">${costHtml}</div>
            <button class="btn-main" 
                style="font-size:0.85em; padding:8px; margin-top:6px; ${canBuild ? '' : 'opacity:0.5; cursor:not-allowed;'}"
                onclick="${canBuild ? `orderBuilding('${key}')` : ''}">
                ${canBuild ? 'Avvia Cantiere' : 'Risorse Insufficienti'}
            </button>
        `;
        grid.appendChild(card);
    });

    modal.classList.add("active");
}

function closeBuildingModal() {
    document.getElementById("modal-buildings").classList.remove("active");
}

function resourceIcon(res) {
    const map = { gold:"💰", wood:"🌲", stone:"🪨", iron:"⛏️", copper:"🥉" };
    return map[res] || res;
}

function checkResources(cost) {
    for (let k in cost) {
        // SE il costo è "gold" o "oro", controlliamo il TESORO (county.gold)
        if (k === 'gold' || k === 'oro') {
            // Usa (county.gold || 0) per sicurezza
            if ((county.gold || 0) < cost[k]) return false;
        }
        // ALTRIMENTI controlliamo le RISORSE nel magazzino (county.resources)
        else {
            if ((county.resources[k] || 0) < cost[k]) return false;
        }
    }
    return true;
}

function orderBuilding(key) {
    const b = buildingData[key];
    if (!checkResources(b.cost)) return;

    // 1. Avvia la costruzione usando la funzione esistente
    startBuilding({
        type: key,
        x: 0, y: 0, // Costruzione astratta nel centro città
        turns: b.time,
        cost: b.cost
    });

    // 2. Notifica in chat pubblica simulando un ordine del giocatore
    const msg = `Ho ordinato la costruzione di: ${b.name}. I lavori iniziano immediatamente.`;
    publicChatHistory.push({ role: "user", content: msg }); // Aggiorna memoria IA
    addMsg("user", msg);
    
    // 3. Chiudi modale e aggiorna UI
    closeBuildingModal();
    updateUI();
}

function updateConstructionUI() {
    const container = document.getElementById("construction-feed");
    if (!container) return;

    // Filtra solo i cantieri attivi ("building")
    const activeProjects = buildings.filter(b => b.stage === "building");

    if (activeProjects.length === 0) {
        container.innerHTML = '<p class="event-empty">Nessun cantiere attivo al momento.</p>';
        return;
    }

    let html = "";
    activeProjects.forEach(b => {
        // Recuperiamo i dati originali per calcolare la %
        const bData = buildingData[b.type];
        const totalTurns = bData ? bData.time : b.turns_left; // Fallback
        
        // Calcolo progresso: (Totale - Rimanenti) / Totale
        // Nota: b.turns_left diminuisce ogni turno
        const completedTurns = totalTurns - b.turns_left;
        let pct = Math.round((completedTurns / totalTurns) * 100);
        pct = Math.max(5, Math.min(100, pct)); // Clamp grafico tra 5% e 100%

        const turnsLabel = b.turns_left === 1 ? "1 turno al termine" : `${b.turns_left} turni al termine`;

        html += `
            <div class="const-card">
                <div class="const-header">
                    <strong>${bData ? bData.name : "Edificio sconosciuto"}</strong>
                    <span style="color:var(--accent)">${pct}%</span>
                </div>
                <div class="const-progress-bg">
                    <div class="const-progress-fill" style="width: ${pct}%"></div>
                </div>
                <div class="const-meta">
                    <span>📍 (${b.x}, ${b.y})</span>
                    <span>⏳ ${turnsLabel}</span>
                </div>
            </div>
        `;
    });

    container.innerHTML = html;
}

function getResourceStats() {
    const stats = {};
    const lastEco = county.lastEconomy;
    if (!lastEco) {
        // Valori di default se non ancora calcolati
        RESOURCE_KEYS.forEach(key => {
            stats[key] = {
                production: Math.floor(Math.random() * 20) + 5,
                consumption: Math.floor(Math.random() * 15) + 5,
                net: Math.floor(Math.random() * 10) - 5
            };
        });
    } else {
        RESOURCE_KEYS.forEach(key => {
            const production = lastEco.production[key] || 0;
            const consumption = lastEco.deficits[key] || 0;
            const net = production - consumption;
            stats[key] = {
                production: production,
                consumption: consumption,
                net: net
            };
        });
    }
    return stats;
}

function renderResourceStats() {
    const container = document.getElementById("resource-stats");
    if (!container) return;

    const stats = getResourceStats();
    let html = `<div class="resource-stats-grid">`;

    RESOURCE_KEYS.forEach(key => {
        const s = stats[key];
        const icon = resourceIcon(key);
        const netClass = s.net > 0 ? 'positive' : s.net < 0 ? 'negative' : '';
        html += `
            <div class="resource-stat-item">
                <div class="resource-stat-header">
                    ${icon} ${resourceLabels[key] || key}
                </div>
                <div class="resource-stat-values">
                    <span>Prod: ${s.production}</span>
                    <span>Cons: ${s.consumption}</span>
                    <span class="${netClass}">Net: ${s.net > 0 ? '+' : ''}${s.net}</span>
                </div>
            </div>
        `;
    });

    html += `</tbody></table>`;
    container.innerHTML = html;
}

function getBasePrices() {
    return {
        // Materie Prime (Basso costo)
        grain: 2, wool: 3, iron: 5, wood: 2, clay: 1,
        
        // Semilavorati (Valore aggiunto dalla manodopera)
        flour: 5,       // Da grain (2)
        fabric: 8,      // Da wool (3)
        iron_ingots: 10,// Da iron (5) + carbone/legno
        leather: 6,     // Da livestock
        
        // Prodotti Finiti (Alto valore di mercato)
        bread: 8,       // Cibo di qualità
        clothes: 25,    // Vestiti (richiesti dalla popolazione)
        tools: 20,      // Utensili (aumentano efficienza)
        furniture: 15,  // Mobili (comfort)
        weapons: 40, 
        armor: 60,
        pottery: 5,
        
        // Altri
        stone: 8, copper: 12, gold: 1, herbs: 4, livestock: 10, textiles: 20, luxuries: 50, arcane: 100
    };
}

function getMarketPrices() {
    const prices = getBasePrices();
    // Modifica basati su relazioni e accordi commerciali
    neighboringCounties.forEach(c => {
        const relation = c.relations || 50;
        let modifier = 1 + (50 - relation) / 100; // Più alta relazione, prezzi migliori (più bassi per comprare)
        if (c.tradeAgreement) {
            modifier *= 0.8; // Ulteriore sconto del 20% con accordo commerciale
        }
        Object.keys(prices).forEach(res => {
            prices[res] *= modifier;
        });
    });
    return prices;
}

/* ===================== NUOVE FUNZIONI MERCATO ===================== */

// Helper per leggere la quantità dall'input
function getQtyValue(id) {
    const el = document.getElementById(id);
    if (!el) return 1;
    const val = parseInt(el.value);
    return (isNaN(val) || val < 1) ? 1 : val;
}

/* ===================== SISTEMA MAGAZZINO ===================== */

// Calcola produzione, consumo e autonomia per ogni risorsa
function calculateResourceStats() {
    const stats = {};
    
    // Usa le funzioni esistenti del gioco per calcolare produzione e consumo
    const production = calculateVillageProduction() || {};
    const consumption = calculateVillageConsumption() || {};
    
    // Aggiungi anche i bisogni logistici
    const logisticNeeds = calculateLogisticNeeds() || [];
    logisticNeeds.forEach(need => {
        consumption[need.resource] = (consumption[need.resource] || 0) + need.amount;
    });

    // Raccogli tutte le risorse (sia quelle in magazzino che quelle con produzione/consumo)
    const allResources = new Set([
        ...Object.keys(county.resources || {}),
        ...Object.keys(production),
        ...Object.keys(consumption)
    ]);

    // Calcola statistiche per ogni risorsa
    allResources.forEach(key => {
        const currentStock = county.resources[key] || 0;
        const productionRate = production[key] || 0;
        const consumptionRate = consumption[key] || 0;
        const netRate = productionRate - consumptionRate;
        
        let daysLeft = 0;
        if (netRate < 0) {
            // Consumo > produzione: calcola autonomia
            daysLeft = currentStock > 0 ? Math.floor(currentStock / Math.abs(netRate)) : 0;
        } else if (netRate === 0 && consumptionRate > 0) {
            // Produzione = consumo: calcola quanto dura lo stock
            daysLeft = currentStock > 0 ? Math.floor(currentStock / consumptionRate) : 0;
        } else {
            // Produzione > consumo: autonomia infinita
            daysLeft = 999;
        }

        stats[key] = {
            current: currentStock,
            consumption: consumptionRate,
            production: productionRate,
            net: netRate,
            daysLeft: daysLeft
        };
    });

    return stats;
}

// Determina lo stato di una risorsa (critical/warning/healthy)
function getResourceStatus(stat) {
    if (stat.daysLeft <= 2 && stat.daysLeft >= 0) return "critical";
    if (stat.daysLeft <= 5 && stat.daysLeft > 2) return "warning";
    if (stat.net >= 0) return "healthy";
    return "warning";
}

// Icone per le risorse
function getResourceIcon(key) {
    const icons = {
        // Risorse base
        food: "🍞",
        wood: "🪵",
        stone: "🪨",
        iron: "⚒️",
        tools: "🔨",
        cloth: "🧵",
        leather: "🥾",
        gold: "💰",
        copper: "🔶",
        silver: "⚪",
        gems: "💎",
        herbs: "🌿",
        mystic_crystals: "🔮",
        // Risorse del sistema village
        grain: "🌾",
        livestock: "🐄",
        textiles: "🧵",
        luxuries: "💎",
        arcane: "🔮"
    };
    return icons[key] || "📦";
}

// Renderizza una singola card risorsa
function renderResourceCard(key, stat) {
    const status = getResourceStatus(stat);
    const icon = getResourceIcon(key);
    const label = resourceLabels[key] || key;

    let autonomyText = "";
    let autonomyClass = "";
    
    if (stat.net > 0) {
        autonomyText = "✓ Produzione eccedente";
        autonomyClass = "infinite";
    } else if (stat.net === 0 && stat.consumption === 0) {
        autonomyText = "♾️ Risorsa stabile";
        autonomyClass = "infinite";
    } else if (stat.daysLeft >= 999) {
        autonomyText = "♾️ Nessun consumo";
        autonomyClass = "infinite";
    } else if (stat.daysLeft <= 0) {
        autonomyText = "⚠️ ESAURITA!";
        autonomyClass = "critical";
    } else {
        autonomyText = `${stat.daysLeft} ${stat.daysLeft === 1 ? 'stagione' : 'stagioni'} rimanenti`;
        autonomyClass = status;
    }

    return `
        <div class="resource-item ${status}">
            <div class="resource-header-w">
                <div style="display: flex; align-items: center;">
                    <div class="resource-icon-w">${icon}</div>
                    <div class="resource-name-w">${label}</div>
                </div>
                <div class="resource-quantity">${stat.current}</div>
            </div>
            <div class="resource-details-w">
                <div class="resource-row-w ${stat.production > 0 ? 'positive' : ''}">
                    <span>📈 Produzione:</span>
                    <span>+${stat.production}/stagione</span>
                </div>
                <div class="resource-row-w ${stat.consumption > 0 ? 'negative' : ''}">
                    <span>📉 Consumo:</span>
                    <span>-${stat.consumption}/stagione</span>
                </div>
                <div class="resource-row-w ${stat.net >= 0 ? 'positive' : 'negative'}">
                    <span>⚖️ Bilancio:</span>
                    <span>${stat.net >= 0 ? '+' : ''}${stat.net}/stagione</span>
                </div>
            </div>
            <div class="resource-autonomy ${autonomyClass}">
                ${autonomyText}
            </div>
        </div>
    `;
}

// Renderizza il magazzino completo
function renderWarehouse() {
    const stats = calculateResourceStats();
    const totalPop = county.pop || 0;

    // Riepilogo veloce
    const summary = document.getElementById("warehouse-summary");
    if (summary) {
        const criticalCount = Object.values(stats).filter(s => getResourceStatus(s) === "critical").length;
        const warningCount = Object.values(stats).filter(s => getResourceStatus(s) === "warning").length;
        const healthyCount = Object.values(stats).filter(s => getResourceStatus(s) === "healthy").length;

        summary.innerHTML = `
            <div class="warehouse-stat">
                <div class="warehouse-stat-value">${Object.keys(county.resources).length}</div>
                <div class="warehouse-stat-label">Risorse Totali</div>
            </div>
            <div class="warehouse-stat">
                <div class="warehouse-stat-value" style="color: #f44336;">${criticalCount}</div>
                <div class="warehouse-stat-label">Critiche</div>
            </div>
            <div class="warehouse-stat">
                <div class="warehouse-stat-value" style="color: #ff9800;">${warningCount}</div>
                <div class="warehouse-stat-label">In Attenzione</div>
            </div>
            <div class="warehouse-stat">
                <div class="warehouse-stat-value" style="color: #4caf50;">${healthyCount}</div>
                <div class="warehouse-stat-label">Stabili</div>
            </div>
        `;
    }

    // Risorse critiche
    const criticalResources = Object.keys(stats).filter(k => getResourceStatus(stats[k]) === "critical");
    const criticalSection = document.getElementById("critical-resources-section");
    const criticalContainer = document.getElementById("critical-resources");
    
    if (criticalContainer && criticalSection) {
        if (criticalResources.length > 0) {
            criticalSection.style.display = "block";
            criticalContainer.innerHTML = criticalResources.map(key => renderResourceCard(key, stats[key])).join("");
        } else {
            criticalSection.style.display = "none";
        }
    }

    // Risorse in attenzione
    const warningResources = Object.keys(stats).filter(k => getResourceStatus(stats[k]) === "warning");
    const warningSection = document.getElementById("warning-resources-section");
    const warningContainer = document.getElementById("warning-resources");
    
    if (warningContainer && warningSection) {
        if (warningResources.length > 0) {
            warningSection.style.display = "block";
            warningContainer.innerHTML = warningResources.map(key => renderResourceCard(key, stats[key])).join("");
        } else {
            warningSection.style.display = "none";
        }
    }

    // Tutte le risorse
    const allContainer = document.getElementById("all-resources");
    if (allContainer) {
        allContainer.innerHTML = Object.keys(stats)
            .sort((a, b) => {
                const statusOrder = { critical: 0, warning: 1, healthy: 2 };
                return statusOrder[getResourceStatus(stats[a])] - statusOrder[getResourceStatus(stats[b])];
            })
            .map(key => renderResourceCard(key, stats[key]))
            .join("");
    }

    // Bisogni popolazione
    const needsContainer = document.getElementById("population-needs");
    if (needsContainer) {
        // Mostra tutte le risorse che hanno consumo > 0
        const needsList = [];
        
        Object.keys(stats).forEach(key => {
            const stat = stats[key];
            if (stat.consumption > 0) {
                needsList.push({
                    title: resourceLabels[key] || key,
                    value: stat.consumption,
                    desc: `Consumo della popolazione e strutture`,
                    icon: getResourceIcon(key)
                });
            }
        });
        
        // Aggiungi popolazione totale
        needsList.push({
            title: "Popolazione Totale",
            value: totalPop,
            desc: `Base per tutti i calcoli di consumo`,
            icon: "👥"
        });

        needsContainer.innerHTML = needsList.map(need => `
            <div class="need-card">
                <div class="need-title">${need.icon} ${need.title}</div>
                <div class="need-value">${need.value}</div>
                <div class="need-desc">${need.desc}</div>
            </div>
        `).join("");
    }
}

function renderMarket() {
    const container = document.getElementById("market-content");
    if (!container) return;

    const prices = getMarketPrices();
    const stats = getResourceStats();
    const marketDynamics = calculateMarketDemand();

    let html = `
        <!-- Summary Cards -->
        <div class="warehouse-summary" style="margin-bottom: 20px;">
            <div class="warehouse-stat">
                <div class="warehouse-stat-value">${county.gold}</div>
                <div class="warehouse-stat-label">💰 Oro Disponibile</div>
            </div>
            <div class="warehouse-stat">
                <div class="warehouse-stat-value">${seasonalTransactions.marketPurchases || 0}</div>
                <div class="warehouse-stat-label">Acquisti Stagione</div>
            </div>
            <div class="warehouse-stat">
                <div class="warehouse-stat-value">${seasonalTransactions.marketSales || 0}</div>
                <div class="warehouse-stat-label">Vendite Stagione</div>
            </div>
        </div>

        <!-- Market Resources Grid -->
        <div class="warehouse-section">
            <h3 style="color: var(--accent); margin-top: 0; margin-bottom: 15px;">📊 Mercato Globale</h3>
            <p style="font-size:0.85em; color:var(--text-soft); margin-bottom:20px;">
                Compra e vendi risorse ai prezzi di mercato. I prezzi variano in base alla domanda e offerta.
            </p>
            <div class="resource-list">
    `;

    RESOURCE_KEYS.forEach(key => {
        const have = county.resources[key] || 0;
        const demand = Math.round(marketDynamics.demand[key] || 0);
        const supply = Math.round(marketDynamics.supply[key] || 0);
        
        // Calcolo Prezzi
        let priceMultiplier = 1.0;
        if (demand > supply) priceMultiplier = 1.0 + (demand - supply) * 0.005;
        else if (supply > demand) priceMultiplier = Math.max(0.5, 1.0 - (supply - demand) * 0.005);
        
        const basePrice = prices[key];
        const buyPrice = Math.max(1, Math.round(basePrice * priceMultiplier * 1.3)); 
        const sellPrice = Math.max(1, Math.round(basePrice * priceMultiplier * 0.8));

        const fabbisogno = stats[key].consumption;
        const icon = resourceIcon(key);
        const inputId = `qty-${key}`;
        
        // Determina lo stato della risorsa
        const net = stats[key].net;
        let statusClass = "healthy";
        if (net < 0) statusClass = "critical";
        else if (net < fabbisogno / 2) statusClass = "warning";

        html += `
            <div class="resource-item ${statusClass}">
                <div class="resource-header-w">
                    <div style="display: flex; align-items: center;">
                        <span class="resource-icon-w">${icon}</span>
                        <span class="resource-name-w">${resourceLabels[key] || key}</span>
                    </div>
                    <div class="resource-quantity">${have}</div>
                </div>
                
                <div class="resource-details-w">
                    <div class="resource-row-w">
                        <span>Fabbisogno:</span>
                        <span>${fabbisogno}/turno</span>
                    </div>
                    <div class="resource-row-w ${net >= 0 ? 'positive' : 'negative'}">
                        <span>Bilancio:</span>
                        <span>${net >= 0 ? '+' : ''}${net}/turno</span>
                    </div>
                    <div class="resource-row-w">
                        <span>Domanda:</span>
                        <span>${demand}</span>
                    </div>
                    <div class="resource-row-w">
                        <span>Offerta:</span>
                        <span>${supply}</span>
                    </div>
                </div>

                <div style="margin: 12px 0; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                        <span style="color: #ff7c7c; font-weight: bold;">💰 Acquisto: ${buyPrice}</span>
                        <span style="color: #6ada91; font-weight: bold;">💰 Vendita: ${sellPrice}</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 8px;">
                        <button class="btn-sec" style="padding: 4px 8px; font-size: 0.75em;" 
                            onclick="document.getElementById('${inputId}').value=1">1</button>
                        <input id="${inputId}" type="number" class="market-qty-input" 
                            value="1" min="1" style="flex: 1; padding: 6px; text-align: center;">
                        <button class="btn-sec" style="padding: 4px 8px; font-size: 0.75em;" 
                            onclick="document.getElementById('${inputId}').value=10">10</button>
                        <button class="btn-sec" style="padding: 4px 8px; font-size: 0.75em;" 
                            onclick="document.getElementById('${inputId}').value=50">50</button>
                    </div>
                    
                    <div style="display: flex; gap: 8px;">
                        <button class="btn-sec" style="flex: 1; background: rgba(255, 124, 124, 0.1); border-color: #ff7c7c;" 
                            onclick="buyResource('${key}', ${buyPrice}, getQtyValue('${inputId}'))">
                            Compra
                        </button>
                        <button class="btn-sec" style="flex: 1; background: rgba(106, 218, 145, 0.1); border-color: #6ada91;" 
                            onclick="sellResource('${key}', ${sellPrice}, getQtyValue('${inputId}'))" 
                            ${have > 0 ? '' : 'disabled'}>
                            Vendi
                        </button>
                    </div>
                </div>
            </div>
        `;
    });

    html += `
            </div>
        </div>
    `;

    // Sezione Merci Speciali
    const tradePartners = neighboringCounties.filter(c => c.tradeAgreement);
    if (tradePartners.length > 0) {
        html += `
            <div class="warehouse-section">
                <h3 style="color: var(--accent); margin-top: 0; margin-bottom: 15px;">✨ Merci Speciali dai Regni Alleati</h3>
                <div class="resource-list">
        `;
        
        tradePartners.forEach(c => {
            const special = c.specialResource;
            if (special) {
                const relationModifier = c.relations / 100;
                const basePrice = prices[special] || 10;
                const buyPrice = Math.round(basePrice * 1.2 * (2 - relationModifier));
                const icon = resourceIcon(special);
                const have = county.resources[special] || 0;

                html += `
                    <div class="resource-item" style="border-color: var(--accent); background: rgba(212, 175, 55, 0.08);">
                        <div class="resource-header-w">
                            <div style="display: flex; align-items: center;">
                                <span class="resource-icon-w">${icon}</span>
                                <span class="resource-name-w">${resourceLabels[special] || special}</span>
                            </div>
                            <div class="resource-quantity" style="color: var(--accent);">${have}</div>
                        </div>
                        
                        <div class="resource-details-w">
                            <div class="resource-row-w">
                                <span>Origine:</span>
                                <span>${c.name}</span>
                            </div>
                            <div class="resource-row-w ${c.relations >= 70 ? 'positive' : c.relations >= 50 ? '' : 'negative'}">
                                <span>Relazioni:</span>
                                <span>${c.relations}/100</span>
                            </div>
                            <div class="resource-row-w">
                                <span>Accordo:</span>
                                <span style="color: var(--accent);">✓ Attivo</span>
                            </div>
                        </div>

                        <div style="margin-top: 12px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px;">
                            <div style="text-align: center; margin-bottom: 8px; color: var(--accent); font-weight: bold;">
                                💰 Prezzo Speciale: ${buyPrice} oro
                            </div>
                            <button class="btn-main" style="width: 100%; padding: 10px;" 
                                onclick="buySpecialResource('${c.key}', '${special}', ${buyPrice})">
                                Acquista (1 unità)
                            </button>
                            <p style="font-size: 0.75em; color: var(--text-soft); margin-top: 8px; margin-bottom: 0; text-align: center;">
                                Risorsa pregiata esclusiva. Prezzi vantaggiosi grazie all'alleanza.
                            </p>
                        </div>
                    </div>
                `;
            }
        });
        
        html += `
                </div>
            </div>
        `;
    } else {
        html += `
            <div class="warehouse-section" style="text-align: center; padding: 30px;">
                <h3 style="color: var(--text-soft); margin-top: 0;">✨ Merci Speciali</h3>
                <p style="color: var(--text-soft); font-size: 0.9em;">
                    Firma accordi commerciali in diplomazia per accedere alle merci speciali dei regni vicini.
                </p>
            </div>
        `;
    }

    container.innerHTML = html;
}

function buyResource(res, unitPrice, qty) {
    if (qty < 1) qty = 1;
    const totalPrice = unitPrice * qty;

    if (county.gold >= totalPrice) {
        county.gold -= totalPrice;
        county.resources[res] = (county.resources[res] || 0) + qty;
        seasonalTransactions.marketPurchases += totalPrice;
        
        updateUI();
        renderMarket(); // Rerender per aggiornare stock e input
        
        addMsg("system", `🛒 Acquistati <strong>${qty}</strong> unità di ${resourceLabels[res] || res} per ${totalPrice} oro.`);
    } else {
        // Calcola quanti ne può comprare al massimo
        const maxAffordable = Math.floor(county.gold / unitPrice);
        if (maxAffordable > 0) {
            addMsg("system", `⚠️ Oro insufficiente per ${qty}. Puoi permettertene al massimo ${maxAffordable}.`);
        } else {
            addMsg("system", "⚠️ Oro insufficiente per l'acquisto.");
        }
    }
}

function sellResource(res, unitPrice, qty) {
    if (qty < 1) qty = 1;
    const have = county.resources[res] || 0;

    if (have >= qty) {
        const totalRevenue = unitPrice * qty;
        county.gold += totalRevenue;
        county.resources[res] -= qty;
        seasonalTransactions.marketSales += totalRevenue;
        
        updateUI();
        renderMarket();
        
        addMsg("system", `⚖️ Venduti <strong>${qty}</strong> unità di ${resourceLabels[res] || res} per ${totalRevenue} oro.`);
    } else {
        addMsg("system", `⚠️ Non hai abbastanza ${resourceLabels[res] || res} in magazzino (Disponibili: ${have}).`);
    }
}

function buySpecialResource(neighborKey, res, price) {
    if (county.gold >= price) {
        county.gold -= price;
        county.resources[res] = (county.resources[res] || 0) + 1;
        seasonalTransactions.specialPurchases += price;
        // Migliora leggermente relazioni
        const neighbor = neighboringCounties.find(c => c.key === neighborKey);
        if (neighbor) neighbor.relations = Math.min(100, neighbor.relations + 2);
        updateUI();
        renderMarket();
        addMsg("system", `Acquistato 1 ${resourceLabels[res] || res} speciale da ${neighbor.name} per ${price} oro. Relazioni migliorate.`);
    } else {
        addMsg("system", "Oro insufficiente per l'acquisto.");
    }
}

function drawRegionMap() {
    const canvas = document.getElementById("region-map");
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    const size = canvas.width / 8;

    // Sfondo carta antica con texture migliorata
    ctx.fillStyle = "#e8dcc0"; 
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Aggiungi texture pergamena più realistica
    ctx.fillStyle = "rgba(139, 115, 85, 0.08)";
    for (let i = 0; i < 80; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        const w = Math.random() * 30 + 5;
        const h = Math.random() * 30 + 5;
        ctx.fillRect(x, y, w, h);
    }

    // Disegna territori con sistema più coerente
    const territoryMap = [
        ['auvrey', 'auvrey', 'wild', 'wild', 'wild', 'count', 'count', 'count'],
        ['auvrey', 'auvrey', 'wild', 'count', 'count', 'count', 'count', 'wild'],
        ['wild', 'wild', 'count', 'count', 'count', 'count', 'wild', 'wild'],
        ['wild', 'count', 'count', 'count', 'count', 'count', 'wild', 'wild'],
        ['count', 'count', 'count', 'count', 'count', 'wild', 'wild', 'wild'],
        ['wild', 'wild', 'count', 'count', 'wild', 'wild', 'falken', 'falken'],
        ['wild', 'wild', 'wild', 'wild', 'wild', 'falken', 'falken', 'falken'],
        ['wild', 'wild', 'wild', 'wild', 'wild', 'wild', 'falken', 'falken']
    ];

    for (let y = 0; y < 8; y++) {
        for (let x = 0; x < 8; x++) {
            const owner = territoryMap[y][x];
            const px = x * size;
            const py = y * size;

            // Riempimento con gradiente per profondità e rilievo
            const gradient = ctx.createLinearGradient(px, py, px + size, py + size);
            gradient.addColorStop(0, getRegionColor(owner, 0.25));
            gradient.addColorStop(0.5, getRegionColor(owner, 0.35));
            gradient.addColorStop(1, getRegionColor(owner, 0.45));
            ctx.fillStyle = gradient;
            ctx.fillRect(px, py, size, size);
            
            // Bordi più definiti e visibili
            ctx.strokeStyle = getRegionColor(owner, 0.9);
            ctx.lineWidth = 1.5;
            ctx.strokeRect(px, py, size, size);
            
            // Aggiungi texture interna casuale per simulare terreno
            if (Math.random() < 0.3) {
                ctx.fillStyle = getRegionColor(owner, 0.15);
                ctx.fillRect(px + size * 0.2, py + size * 0.2, size * 0.6, size * 0.6);
            }
        }
    }
    
    // Disegna strade principali più visibili
    ctx.strokeStyle = "rgba(101, 67, 33, 0.7)";
    ctx.lineWidth = 4;
    ctx.setLineDash([8, 4]);
    
    // Strada principale diagonale NW-SE
    ctx.beginPath();
    ctx.moveTo(0, canvas.height * 0.2);
    ctx.lineTo(canvas.width * 0.4, canvas.height * 0.5);
    ctx.lineTo(canvas.width, canvas.height * 0.8);
    ctx.stroke();
    
    // Strada principale diagonale NE-SW
    ctx.beginPath();
    ctx.moveTo(canvas.width, canvas.height * 0.3);
    ctx.lineTo(canvas.width * 0.6, canvas.height * 0.5);
    ctx.lineTo(0, canvas.height * 0.7);
    ctx.stroke();
    
    // Strada orizzontale centrale
    ctx.beginPath();
    ctx.moveTo(0, canvas.height * 0.5);
    ctx.lineTo(canvas.width, canvas.height * 0.5);
    ctx.stroke();
    
    ctx.setLineDash([]);
    
    // Disegna fiumi stilizzati
    ctx.strokeStyle = "rgba(100, 150, 200, 0.4)";
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(canvas.width * 0.3, 0);
    ctx.quadraticCurveTo(
        canvas.width * 0.4, canvas.height * 0.5,
        canvas.width * 0.6, canvas.height
    );
    ctx.stroke();
    
    // Etichette dei territori
    const labels = [
        { name: "Contea di Auvrey", x: 1, y: 1, owner: 'auvrey' },
        { name: "Terre del Conte", x: 4, y: 3, owner: 'count' },
        { name: "Contea di Falken", x: 6, y: 6, owner: 'falken' },
        { name: "Terre Selvagge", x: 2, y: 5, owner: 'wild' }
    ];
    
    labels.forEach(label => {
        const px = label.x * size + size/2;
        const py = label.y * size + size/2;
        
        // Sfondo etichetta
        ctx.fillStyle = "rgba(244, 236, 216, 0.85)";
        ctx.font = "bold 10px Georgia";
        const textWidth = ctx.measureText(label.name).width;
        ctx.fillRect(px - textWidth/2 - 4, py - 8, textWidth + 8, 16);
        
        // Bordo etichetta
        ctx.strokeStyle = getRegionColor(label.owner, 1);
        ctx.lineWidth = 1.5;
        ctx.strokeRect(px - textWidth/2 - 4, py - 8, textWidth + 8, 16);
        
        // Testo
        ctx.fillStyle = "#3e2723";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(label.name, px, py);
    });
    
    // Disegna città/capitali
    drawRegionalCities(ctx, size);
    
    // Pins delle contee vicine
    drawNeighborPins(ctx);
    
    // Vignettatura
    drawVignette(ctx, canvas.width, canvas.height);
    
    // Legenda migliorata
    drawRegionalLegend(ctx, canvas.width, canvas.height);
}

// NUOVA FUNZIONE: Disegna città importanti sulla mappa regionale
function drawRegionalCities(ctx, size) {
    const cities = [
        { x: 4, y: 3, name: "Capitale", size: "large" },  // Città principale del conte
        { x: 1, y: 1, name: "Auvrey", size: "medium" },
        { x: 6, y: 6, name: "Falken", size: "medium" }
    ];
    
    cities.forEach(city => {
        const px = city.x * size + size/2;
        const py = city.y * size + size/2;
        const radius = city.size === "large" ? 6 : 4;
        
        // Cerchio città
        ctx.fillStyle = "#3e2723";
        ctx.strokeStyle = "#d4af37";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(px, py, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        // Stella per capitale
        if (city.size === "large") {
            ctx.fillStyle = "#d4af37";
            ctx.font = "12px Arial";
            ctx.textAlign = "center";
            ctx.fillText("★", px, py - 12);
        }
    });
}

// NUOVA FUNZIONE: Legenda regionale migliorata
function drawRegionalLegend(ctx, width, height) {
    const legendX = 10;
    const legendY = height - 100;
    
    // Sfondo legenda
    ctx.fillStyle = "rgba(244, 236, 216, 0.95)";
    ctx.strokeStyle = "#8b7355";
    ctx.lineWidth = 2;
    ctx.fillRect(legendX, legendY, 140, 90);
    ctx.strokeRect(legendX, legendY, 140, 90);
    
    ctx.font = "bold 11px Georgia";
    ctx.textAlign = "left";
    ctx.fillStyle = "#3e2723";
    ctx.fillText("Legenda Regionale:", legendX + 10, legendY + 15);
    
    const owners = [
        { key: "count", name: "Terre del Conte" },
        { key: "auvrey", name: "Contea Auvrey" },
        { key: "falken", name: "Contea Falken" },
        { key: "wild", name: "Terre Selvagge" }
    ];
    
    ctx.font = "10px Georgia";
    owners.forEach((o, i) => {
        const y = legendY + 32 + i * 16;
        
        // Quadrato colore
        ctx.fillStyle = getRegionColor(o.key, 0.8);
        ctx.fillRect(legendX + 10, y - 8, 12, 12);
        ctx.strokeStyle = getRegionColor(o.key, 1);
        ctx.lineWidth = 1;
        ctx.strokeRect(legendX + 10, y - 8, 12, 12);
        
        // Testo
        ctx.fillStyle = "#3e2723";
        ctx.fillText(o.name, legendX + 28, y);
    });
}

function getRegionColor(owner, alpha) {
    const map = {
        count: `rgba(212, 175, 55, ${alpha})`,  // Oro per il conte
        auvrey: `rgba(180, 40, 40, ${alpha})`,  // Rosso scuro per Auvrey
        falken: `rgba(20, 60, 120, ${alpha})`,  // Blu scuro per Falken
        wild: `rgba(100, 100, 100, ${alpha})`   // Grigio neutro per terre selvagge
    };
    return map[owner] || map.wild;
}

function drawNeighborPins(ctx) {
    const canvas = ctx.canvas;
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const radius = canvas.width * 0.35;

    neighboringCounties.forEach((c, idx) => {
        const angle = (idx / neighboringCounties.length) * Math.PI * 2;
        const x = centerX + Math.cos(angle) * radius;
        const y = centerY + Math.sin(angle) * radius;

        ctx.beginPath();
        ctx.fillStyle = getRegionColor(c.key, 1);
        ctx.arc(x, y, 12, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "#3e2723";
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.fillStyle = "#fff";
        ctx.font = "10px Georgia";
        ctx.textAlign = "center";
        ctx.fillText(c.name.split(" ")[0], x, y + 3);
    });
}

function closeBudgetModal() {
    const modal = document.getElementById("modal-budget");
    if (modal) modal.classList.remove("active");
}

document.addEventListener("DOMContentLoaded", initStartScreen);

</script>

<div id="modal-budget" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Bilancio Stagionale</h3>
            <button class="close-btn" onclick="closeBudgetModal()">✕</button>
        </div>
        <div id="budget-content">
            <!-- Contenuto popolato da renderBudget() -->
        </div>
    </div>
</div>

<!-- MODALE CRONACHE STAGIONALI -->
<div id="modal-chronicle" class="modal" style="background: rgba(0,0,0,0.9); z-index: 5000;">
    <div class="modal-content chronicle-content">
        <div class="chronicle-header">
            <h2 id="chronicle-title">Cronache del Regno</h2>
            <div id="chronicle-date" style="color:var(--text-soft); font-style:italic;">Anno 1325, Primavera</div>
        </div>
        
        <hr style="border-color:var(--accent); opacity:0.3; margin: 15px 0;">
        
        <div id="chronicle-body" class="chronicle-text">
            <div class="loading-story">
                <span class="scribe-icon">✍️</span>
                <p>Il Mastrocronista sta scrivendo la storia della stagione...</p>
            </div>
        </div>

        <button class="btn-main" onclick="closeChronicleModal()" style="margin-top:20px;">Continua a Governare</button>
    </div>
</div>

<!-- MODALE CREAZIONE LEGGI -->
<div id="modal-law-creator" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3>📜 Crea una Nuova Legge</h3>
            <button class="close-btn" onclick="closeLawModal()">✕</button>
        </div>
        <div style="padding: 20px;">
            <div style="margin-bottom: 15px;">
                <label>Nome della Legge:</label>
                <input type="text" id="law-name" placeholder="Es. Legge sul Pane" style="width: 100%; padding: 8px; margin-top: 5px;">
            </div>
            <div style="margin-bottom: 15px;">
                <label>Descrizione:</label>
                <textarea id="law-desc" placeholder="Descrivi gli effetti della legge..." rows="3" style="width: 100%; padding: 8px; margin-top: 5px;"></textarea>
            </div>
            <div style="margin-bottom: 15px;">
                <label>Costo di Mantenimento (oro/turno):</label>
                <input type="number" id="law-upkeep" min="0" value="0" style="width: 100%; padding: 8px; margin-top: 5px;">
            </div>
            <div style="margin-bottom: 15px;">
                <label>Risorsa da Consumare (opzionale):</label>
                <select id="law-resource" style="width: 48%; padding: 8px; margin-top: 5px;">
                    <option value="">Nessuna</option>
                    <option value="grain">Grano</option>
                    <option value="wood">Legno</option>
                    <option value="stone">Pietra</option>
                    <option value="iron">Ferro</option>
                    <option value="gold">Oro</option>
                </select>
                <input type="number" id="law-resource-amount" min="0" value="0" placeholder="Quantità" style="width: 48%; padding: 8px; margin-top: 5px; margin-left: 4%;">
            </div>
            <button class="btn-main" onclick="createLaw()" style="width: 100%;">Promulga la Legge</button>
        </div>
    </div>
</div>

</body>
</html>

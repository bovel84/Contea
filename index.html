<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Il Conte – Simulatore Medievale Completo</title>

    <!-- ===================== STILI BASE + ESPANSIONI ===================== -->
    <style>
        :root {
            --bg-main: #050505;
            --bg-panel: #0f0f0f;
            --bg-panel-alt: #171717;
            --border-soft: #2a2a2a;
            --border-strong: #3a3a3a;
            --accent: #d4af37;
            --accent-muted: #b68a1f;
            --text: #f2f2f2;
            --text-soft: #b3b3b3;
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Georgia', serif;
            background: radial-gradient(circle at top, #171717, var(--bg-main));
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
            overflow-y: auto;
        }

        h1, h2, h3 {
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 0;
        }

        .screen {
            display: none;
            flex: 1;
            overflow-y: auto;
            padding: clamp(16px, 4vw, 28px);
            background: linear-gradient(145deg, rgba(15,15,15,0.95), rgba(8,8,8,0.9));
        }
        .screen.active { display: flex; flex-direction: column; }

        input, textarea, select {
            width: 100%;
            padding: 12px;
            background: #121212;
            border: 1px solid var(--border-soft);
            border-radius: 6px;
            color: var(--text);
            margin-bottom: 15px;
        }

        .btn-main {
            width: 100%;
            padding: 14px;
            background: linear-gradient(120deg, var(--accent), #a7720d);
            color: black;
            font-weight: bold;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 6px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.45);
        }

        .btn-sec {
            padding: 8px 12px;
            background: var(--bg-panel-alt);
            border: 1px solid var(--border-soft);
            border-radius: 8px;
            color: var(--text-soft);
            cursor: pointer;
            transition: border-color 0.2s ease;
        }

        .btn-sec:hover { border-color: var(--accent-muted); }

        .panel {
            background: var(--bg-panel);
            border: 1px solid var(--border-soft);
            border-radius: 18px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.35);
        }

        #screen-start {
            background: radial-gradient(circle at top, #101010, #030303);
        }

        .start-hero {
            text-align: center;
            margin-bottom: 24px;
        }

        .start-hero h1 {
            font-size: clamp(1.8rem, 5vw, 2.8rem);
            margin-bottom: 6px;
        }

        .start-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 18px;
        }

        .start-card {
            background: rgba(8,8,8,0.92);
            border: 1px solid var(--border-soft);
            border-radius: 18px;
            padding: 18px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.45);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .start-card h3 {
            margin: 0;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.9em;
        }

        .save-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid rgba(255,255,255,0.06);
            border-radius: 12px;
            padding: 10px 12px;
            margin-bottom: 8px;
            background: rgba(6,6,6,0.9);
            gap: 10px;
        }

        .save-entry-details {
            display: flex;
            flex-direction: column;
            font-size: 0.8em;
            color: var(--text-soft);
        }

        .save-entry-actions {
            display: flex;
            gap: 6px;
        }

        .save-empty {
            font-size: 0.85em;
            color: var(--text-soft);
        }

        .game-toolbar {
            display: flex;
            flex-wrap: nowrap;
            gap: 10px;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 14px;
        }

        .toolbar-status {
            font-size: 0.75em;
            color: var(--text-soft);
        }

        .season-banner {
            border: 1px solid var(--border-soft);
            border-radius: 12px;
            padding: 8px 14px;
            margin-bottom: 18px;
            background: rgba(12,12,12,0.85);
            display: flex;
            justify-content: space-between;
            gap: 10px;
            font-size: 0.85em;
            color: var(--text);
        }

        .season-highlight {
            color: var(--accent);
            font-weight: 600;
        }

        .resource-grid .stat-card {
            position: relative;
        }

        .res-delta {
            position: absolute;
            right: 10px;
            bottom: 8px;
            font-size: 0.75em;
            color: var(--text-soft);
        }

        .res-delta.positive { color: #6ada91; }
        .res-delta.negative { color: #ff7c7c; }

        .faction-effects {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px,1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .faction-effect-card {
            border: 1px solid var(--border-soft);
            border-radius: 12px;
            padding: 12px;
            background: rgba(10,10,10,0.85);
            font-size: 0.85em;
        }

        .faction-effect-card strong {
            color: var(--accent);
            display: block;
            margin-bottom: 4px;
        }

        .tax-panel {
            border: 1px solid var(--border-soft);
            border-radius: 14px;
            padding: 14px;
            margin-bottom: 20px;
            background: rgba(6,6,6,0.9);
        }

        .tax-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px,1fr));
            gap: 12px;
            margin-bottom: 12px;
        }

        .tax-card {
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 12px;
            padding: 10px;
            background: rgba(12,12,12,0.85);
        }

        .tax-card label {
            display: flex;
            justify-content: space-between;
            font-size: 0.8em;
            text-transform: uppercase;
            color: var(--text-soft);
        }

        .tax-card input[type=range] {
            width: 100%;
        }

        .tax-summary {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            font-size: 0.85em;
            color: var(--text);
        }

        .law-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px,1fr));
            gap: 12px;
        }

        .law-card {
            border: 1px solid var(--border-soft);
            border-radius: 14px;
            padding: 12px;
            background: rgba(10,10,10,0.88);
        }

        .law-card h4 {
            margin: 0 0 6px 0;
            color: var(--accent);
        }

        .law-card p {
            margin: 0 0 10px 0;
            font-size: 0.85em;
            color: var(--text-soft);
        }

        .section-toggle {
            width: 100%;
            margin: 12px 0 6px;
            padding: 10px 14px;
            text-align: left;
            background: rgba(12,12,12,0.85);
            color: var(--text);
            border: 1px solid var(--border-soft);
            border-radius: 10px;
            font-size: 0.95em;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .section-toggle span {
            font-size: 0.85em;
            color: var(--text-soft);
        }

        .section-panel {
            border: 1px solid rgba(255,255,255,0.05);
            border-radius: 14px;
            padding: 12px;
            background: rgba(5,5,5,0.85);
            margin-bottom: 10px;
        }

        .section-panel.collapsed {
            display: none;
        }

        .asset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 12px;
        }

        .asset-card {
            border: 1px solid var(--border-soft);
            border-radius: 12px;
            padding: 12px;
            background: rgba(8,8,8,0.9);
            font-size: 0.85em;
        }

        .asset-card h4 {
            margin: 0 0 6px 0;
            color: var(--accent);
        }

        .asset-flow {
            font-size: 0.8em;
            color: var(--text-soft);
            margin-top: 4px;
        }

        .law-creator {
            border-top: 1px dashed rgba(255,255,255,0.08);
            margin-top: 12px;
            padding-top: 12px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px,1fr));
            gap: 10px;
        }

        .law-creator textarea,
        .law-creator input,
        .law-creator select {
            margin: 0;
        }

        .law-creator button {
            grid-column: 1 / -1;
        }

        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.65);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
            z-index: 100;
        }

        .modal.active { display: flex; }

        .modal-content {
            background: var(--bg-panel);
            border: 1px solid var(--border-soft);
            border-radius: 18px;
            width: min(520px, 92vw);
            max-height: 90vh;
            overflow-y: auto;
            padding: 20px;
            box-shadow: 0 30px 70px rgba(0,0,0,0.65);
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .close-btn {
            background: none;
            border: none;
            color: var(--text);
            font-size: 1.2em;
            cursor: pointer;
        }

        .personality-form label {
            font-size: 0.85em;
            color: var(--text-soft);
        }

        .personality-form textarea { min-height: 80px; }

        /* ===================== NAVIGAZIONE ===================== */
        .bottom-nav {
            display: flex;
            height: 60px;
            background: rgba(5,5,5,0.95);
            border-top: 1px solid var(--border-soft);
            align-items: center;
            justify-content: space-around;
            position: sticky;
            bottom: 0;
            z-index: 10;
            backdrop-filter: blur(10px);
        }

        .nav-btn {
            background: none;
            border: none;
            color: var(--text-soft);
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 0.77em;
            gap: 3px;
        }
        .nav-btn.active { color: #d4af37; }

        .nav-icon { font-size: 1.4em; }

        /* ===================== TAB VIEW ===================== */
        .tab-view {
            display: none;
            height: 100%;
            overflow-y: auto;
            padding: clamp(16px, 4vw, 26px);
            background: linear-gradient(135deg, rgba(12,12,12,0.95), rgba(5,5,5,0.92));
            border: 1px solid var(--border-soft);
            border-radius: 20px;
            margin-bottom: 70px;
            box-shadow: 0 20px 45px rgba(0,0,0,0.4);
        }
        .tab-view.active-tab { display: flex; flex-direction: column; gap: 16px; }

        /* ===================== STATISTICHE ===================== */
        .grid-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 20px;
        }

        .resource-grid {
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        }

        .stat-card {
            background: var(--bg-panel);
            border: 1px solid var(--border-soft);
            padding: 14px;
            border-radius: 14px;
            text-align: center;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.03);
        }

        .stat-val { font-size: 1.3em; font-weight: bold; }

        /* ===================== BARS ===================== */
        .need-row { margin-bottom: 15px; }
        .need-header {
            display: flex;
            justify-content: space-between;
            font-size: 0.85em;
            margin-bottom: 4px;
        }
        .need-bar-bg {
            background: #333;
            height: 8px;
            border-radius: 4px;
            width: 100%;
        }
        .need-bar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s;
        }
        .fill-food { background: #e6bf00; }
        .fill-health { background: #4caf50; }
        .fill-happy { background: #2196f3; }
        .fill-stability { background: #9c27b0; }

        /* ===================== DIPLOMAZIA ===================== */
        .diplomacy-card {
            background: linear-gradient(140deg, rgba(22,22,22,0.95), rgba(12,12,12,0.9));
            border: 1px solid var(--border-soft);
            padding: 14px 16px;
            border-radius: 14px;
            margin-bottom: 14px;
            box-shadow: 0 12px 26px rgba(0,0,0,0.4);
        }

        .relation-row {
            display: flex;
            justify-content: space-between;
            border-bottom: 1px dashed rgba(255,255,255,0.05);
            padding: 6px 0;
            font-size: 0.92em;
        }

        .relation-row span:first-child { color: var(--text-soft); }

        /* ===================== SALA DEL TRONO (CHAT) - VERSIONE LEGGIBILE ===================== */
        .chat-panel {
            /* Sfondo schiarito: da nero #111 a grigio scuro #1a1a1a */
            background: #1a1a1a;
            border: 1px solid #333; /* Bordo più visibile */
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            height: 75vh; 
            min-height: 600px; /* Minimo garantito su desktop */
            background: #111; /* Sfondo più scuro per immersione */
            border: 1px solid #444;
            box-shadow: 0 0 30px rgba(0,0,0,0.8); /* Ombra profonda */
            position: relative;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        /* Texture sfondo: Molto più leggera, non copre il testo */
        .chat-panel::before {
            content: "";
            position: absolute;
            inset: 0;
            /* Gradiente ridotto drasticamente: dal 90% di opacità al 20% */
            background: radial-gradient(circle at 50% 30%, rgba(40, 35, 30, 0.1), rgba(0,0,0,0.4));
            pointer-events: none;
            z-index: 0;
        }

        .chat-header {
            z-index: 2;
            /* Sfondo più chiaro e distinto */
            background: #252525;
            border-bottom: 1px solid #444;
            padding: 12px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #d4af37; /* Oro leggibile */
            font-family: 'Georgia', serif;
            font-size: 0.95em;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .chat-log {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 25px;
            scroll-behavior: smooth;
            z-index: 1;
            /* Colore testo base molto più chiaro */
            color: #e0e0e0;
            font-size: 1.05em; /* Testo leggermente più grande */
            line-height: 1.6; /* Interlinea per narrativa */
            padding: 25px;
            background: radial-gradient(circle at center, #1a1a1a 0%, #080808 100%); /* Effetto vignetta */
        }

        /* Chips Fazioni (i pulsanti in alto) */
        .faction-chips {
            z-index: 2;
            padding: 10px 15px;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid #333;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .faction-chip {
            background: #2a2a2a; /* Sfondo grigio, non nero */
            border: 1px solid #555; /* Bordo visibile */
            color: #ccc;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.75em;
            cursor: pointer;
            transition: all 0.2s;
        }
        .faction-chip:hover {
            background: #3a3a3a;
            border-color: #d4af37;
            color: #fff;
        }

        /* Area Input (in basso) */
        .input-area {
            z-index: 2;
            background: #202020; /* Ben distinto dallo sfondo */
            padding: 15px;
            border-top: 1px solid #444;
            display: flex;
            gap: 10px;
        }

        .input-area input {
            background: #111;
            border: 1px solid #555;
            color: #fff; /* Testo bianco puro */
            padding: 10px;
            border-radius: 6px;
            font-size: 1em;
        }
        .input-area input::placeholder {
            color: #777;
        }

        /* Pulsante "Avanza Stagione" */
        .season-advance-btn {
            margin: 0; /* Reset margini */
            width: 100%;
            padding: 12px;
            background: #2c2c2c;
            border: 1px solid #555;
            color: #e0e0e0;
            font-weight: bold;
            cursor: pointer;
            border-radius: 0; /* Full width style */
            transition: background 0.2s;
        }
        .season-advance-btn:hover {
            background: #3a3a3a;
            border-color: #d4af37;
            color: #fff;
        }

        /* Messaggi Chat */
        .msg-system {
            background: transparent;
            border: none;
            border-top: 1px solid #333;
            border-bottom: 1px solid #333;
            color: #888;
            font-style: italic;
            text-align: left;
            padding: 10px 0;
            margin: 15px 0;
        }

        /* Correzione colori Messaggi Fazione per leggibilità */
        .msg-faction {
            background: #222;
            border: 1px solid #444;
            color: #eee; /* Testo chiaro */
        }
        .msg-faction .msg-text {
            color: #dcdcdc; /* Grigio chiarissimo */
        }
        .faction-title {
            font-weight: bold;
            letter-spacing: 1px;
            margin-bottom: 5px;
            display: block;
        }

        /* ===================== EVENTI & AZIONI ===================== */
        .panel-title {
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--accent);
            margin-bottom: 8px;
        }

        .event-panel,
        .action-panel,
        .advice-panel {
            background: linear-gradient(135deg, rgba(16,16,16,0.92), rgba(8,8,8,0.9));
            border: 1px solid var(--border-soft);
            border-radius: 18px;
            padding: 18px;
            box-shadow: 0 15px 30px rgba(0,0,0,0.4);
        }

        .event-feed {
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-height: 320px;
            overflow-y: auto;
        }

        .event-card {
            background: linear-gradient(135deg, rgba(212,175,55,0.12), rgba(255,255,255,0.03));
            border: 1px solid rgba(212,175,55,0.2);
            border-radius: 14px;
            padding: 12px 14px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.35);
        }

        .event-time {
            font-size: 0.7em;
            color: var(--text-soft);
            text-align: right;
            margin-bottom: 6px;
        }

        .event-empty,
        .action-empty {
            color: var(--text-soft);
            font-size: 0.85em;
            margin: 0;
        }

        .action-panel { margin-top: 16px; }

        .action-prompt {
            margin: 0 0 8px 0;
            font-size: 0.85em;
            color: #ccc;
        }

        .action-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .action-card {
            border: 1px solid rgba(52,152,219,0.35);
            background: rgba(36,75,95,0.35);
            color: #e4f4ff;
            border-radius: 12px;
            padding: 12px;
            text-align: left;
            display: flex;
            flex-direction: column;
            gap: 4px;
            cursor: pointer;
            font-size: 0.95em;
            transition: transform 0.15s ease, border-color 0.15s ease;
        }

        .legend-circle {
            background: #f4d88b;
            box-shadow: inset 0 0 4px rgba(0,0,0,0.4);
        }

        .legend-diamond {
            background: #c27b26;
            transform: rotate(45deg);
        }

        .legend-triangle {
            display: inline-block;
            width: 0;
            height: 0;
            border-left: 9px solid transparent;
            border-right: 9px solid transparent;
            border-bottom: 16px solid #5ba86c;
            border-radius: 2px;
        }

        .legend-square {
            background: #cfcfcf;
        }

        .legend-cross {
            position: relative;
            width: 18px;
            height: 18px;
        }

        .legend-cross::before,
        .legend-cross::after {
            content: "";
            position: absolute;
            background: #f5f0d0;
            border-radius: 2px;
        }

        .legend-cross::before {
            width: 6px;
            height: 18px;
            left: 6px;
        }

        .legend-cross::after {
            width: 18px;
            height: 6px;
            top: 6px;
        }

        /* ===================== POPOLAZIONE ===================== */
        .pop-grid {
            display: grid;
            grid-template-columns: repeat(2,1fr);
            gap: 10px;
        }

        .pop-card {
            background: linear-gradient(135deg, rgba(28,28,28,0.95), rgba(14,14,14,0.92));
            border: 1px solid var(--border-soft);
            padding: 14px;
            border-radius: 12px;
            box-shadow: 0 10px 22px rgba(0,0,0,0.35);
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            gap: 10px;
            font-size: 0.95em;
        }

        .pop-card strong { color: var(--accent); }
        .pop-card span { color: var(--text); }

        /* ===================== PERSONAGGI (FAZIONI) ===================== */
        .person-card {
            background: linear-gradient(120deg, rgba(20,20,20,0.95), rgba(10,10,10,0.92));
            border: 1px solid var(--border-soft);
            padding: 16px;
            border-radius: 16px;
            margin-bottom: 14px;
            box-shadow: 0 15px 30px rgba(0,0,0,0.4);
        }
        .person-name {
            color: #d4af37;
            font-size: 1.1em;
            margin-bottom: 6px;
        }

        .private-selector {
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            background: rgba(8,8,8,0.85);
            border: 1px solid var(--border-soft);
            border-radius: 18px;
            padding: 14px;
        }

.building-card-ui {
    background: rgba(18, 18, 18, 0.95);
    border: 1px solid var(--border-soft);
    border-radius: 12px;
    padding: 14px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    transition: transform 0.2s;
}
.building-card-ui:hover {
    border-color: var(--accent);
    transform: translateY(-2px);
}
.b-header {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    border-bottom: 1px dashed rgba(255,255,255,0.1);
    padding-bottom: 6px;
    margin-bottom: 4px;
}
.b-title { color: var(--accent); font-weight: bold; font-size: 0.95em; }
.b-time { font-size: 0.75em; color: #aaa; }
.b-desc { font-size: 0.85em; color: #ddd; line-height: 1.3; flex-grow: 1; }
.b-effect { font-size: 0.75em; color: #81c784; margin-top: 4px; }
.b-cost { 
    display: flex; 
    gap: 8px; 
    flex-wrap: wrap; 
    font-size: 0.75em; 
    color: var(--text-soft); 
    background: rgba(0,0,0,0.3);
    padding: 6px;
    border-radius: 6px;
}
.cost-item { display: flex; align-items: center; gap: 3px; }
.cost-item.missing { color: #ff6b6b; }

/* Stile per il pannello cantieri */
.const-card {
    background: linear-gradient(90deg, rgba(20,20,20,0.9), rgba(30,30,30,0.9));
    border: 1px solid var(--border-soft);
    border-left: 3px solid var(--accent);
    padding: 10px 12px;
    border-radius: 8px;
    margin-bottom: 8px;
    display: flex;
    flex-direction: column;
    gap: 6px;
}

.const-header {
    display: flex;
    justify-content: space-between;
    font-size: 0.9em;
    color: var(--text);
}

.const-meta {
    font-size: 0.75em;
    color: var(--text-soft);
    display: flex;
    justify-content: space-between;
}

.const-progress-bg {
    background: #333;
    height: 6px;
    width: 100%;
    border-radius: 3px;
    overflow: hidden;
}

.const-progress-fill {
    background: var(--accent);
    height: 100%;
    width: 0%;
    transition: width 0.4s ease;
    box-shadow: 0 0 8px rgba(212, 175, 55, 0.4);
}

/* ===================== MEDIA QUERIES PER MOBILE ===================== */
@media (max-width: 768px) {
    body {
        font-size: 14px;
    }

    .screen {
        padding: clamp(8px, 2vw, 16px);
    }

    .screen.active {
        display: flex;
        flex-direction: column;
    }

    #screen-game {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr auto;
        gap: 10px;
    }

    .start-grid {
        grid-template-columns: 1fr;
        gap: 12px;
    }

    .start-card {
        padding: 12px;
    }

    .game-toolbar {
        flex-wrap: wrap;
        gap: 6px;
        font-size: 0.8em;
    }

    .toolbar-status {
        font-size: 0.7em;
    }

    .season-banner {
        padding: 6px 10px;
        font-size: 0.8em;
        flex-direction: column;
        gap: 4px;
        align-items: flex-start;
    }

    .tab-view {
        padding: clamp(12px, 3vw, 20px);
        margin-bottom: 60px;
    }

    .grid-stats {
        grid-template-columns: 1fr;
        gap: 8px;
    }

    .resource-grid {
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    }

    .stat-card {
        padding: 10px;
        font-size: 0.9em;
    }

    .stat-val {
        font-size: 1.1em;
    }

    .need-row {
        margin-bottom: 12px;
    }

    .need-header {
        font-size: 0.8em;
    }

    .diplomacy-card {
        padding: 10px 12px;
        margin-bottom: 10px;
    }

    .relation-row {
        font-size: 0.85em;
        padding: 4px 0;
    }

    .chat-panel {
        height: 65vh;
        min-height: auto;
    }

    .chat-log {
        padding: 15px;
        gap: 10px;
    }

    .msg {
        padding: 10px 12px;
        max-width: 95%;
        font-size: 0.9em;
    }

    .input-area {
        padding: 12px;
        gap: 8px;
    }

    .send-btn {
        width: 44px;
        font-size: 1em;
    }

    .season-advance-btn {
        padding: 8px 10px;
        font-size: 0.85em;
    }

    .event-feed {
        max-height: 250px;
    }

    .event-card {
        padding: 10px 12px;
        font-size: 0.9em;
    }

    .action-card {
        padding: 10px;
        font-size: 0.9em;
    }

    .pop-grid {
        grid-template-columns: 1fr;
        gap: 8px;
    }

    .pop-card {
        padding: 10px;
        font-size: 0.9em;
    }

    .person-card {
        padding: 8px;
        margin-bottom: 6px;
        font-size: 0.9em;
    }

    .representatives-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
    }

    .person-name {
        font-size: 1em;
    }

    .private-selector {
        padding: 10px;
        gap: 8px;
    }

    .private-selector button {
        font-size: 0.8em;
        padding: 6px 8px;
    }

    .faction-effects {
        grid-template-columns: 1fr;
        gap: 8px;
    }

    .faction-effect-card {
        padding: 10px;
        font-size: 0.9em;
    }

    .tax-grid {
        grid-template-columns: 1fr;
        gap: 8px;
    }

    .tax-card {
        padding: 8px;
    }

    .law-list {
        grid-template-columns: 1fr;
        gap: 8px;
    }

    .law-card {
        padding: 10px;
        font-size: 0.9em;
    }

    .law-creator {
        grid-template-columns: 1fr;
        gap: 8px;
    }

    .asset-grid {
        grid-template-columns: 1fr;
        gap: 8px;
    }

    .asset-card {
        padding: 10px;
        font-size: 0.9em;
    }

    .modal-content {
        width: 95vw;
        max-height: 85vh;
        padding: 16px;
    }

    .modal-header {
        margin-bottom: 4px;
    }

    .close-btn {
        font-size: 1.1em;
    }

    .bottom-nav {
        height: 50px;
        font-size: 0.75em;
    }

    .nav-btn {
        font-size: 0.7em;
    }

    .nav-icon {
        font-size: 1.2em;
    }

    canvas {
        max-width: 100%;
        height: auto;
    }

    .map-legend {
        font-size: 0.9em;
    }

    .legend-item {
        margin-bottom: 6px;
    }

    .building-card-ui {
        padding: 12px;
        font-size: 0.9em;
    }

    .b-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 4px;
    }

    .b-title {
        font-size: 0.95em;
    }

    .b-time {
        font-size: 0.75em;
    }

    .b-desc {
        font-size: 0.85em;
    }

    .b-cost {
        font-size: 0.75em;
        padding: 6px;
    }

    .const-card {
        padding: 8px 10px;
        font-size: 0.9em;
    }

    .const-header {
        font-size: 0.9em;
    }

    .const-meta {
        font-size: 0.75em;
    }

    .save-entry {
        padding: 8px 10px;
        font-size: 0.85em;
    }

    .save-entry-details {
        font-size: 0.8em;
    }

    .save-entry-actions {
        gap: 4px;
    }

    .panel {
        border-radius: 12px;
    }

    .btn-main {
        padding: 12px;
        font-size: 0.9em;
    }

    .btn-sec {
        padding: 6px 10px;
        font-size: 0.85em;
    }

    h1, h2, h3 {
        font-size: clamp(1.4rem, 4vw, 2.2rem);
        margin-bottom: 12px;
    }

    .section-toggle {
        padding: 8px 12px;
        font-size: 0.9em;
    }

    .section-panel {
        padding: 10px;
    }

    .faction-chips {
        padding: 8px 15px 0;
    }

    .faction-chip {
        font-size: 0.7em;
        padding: 3px 8px;
    }

    .msg-system {
        font-size: 0.65em;
    }

    .msg-meta {
        font-size: 0.65em;
    }

    .panel-title {
        font-size: 0.8em;
    }

    .event-empty,
    .action-empty {
        font-size: 0.8em;
    }

    .action-prompt {
        font-size: 0.8em;
    }

    .toolbar-status {
        font-size: 0.7em;
    }

    .season-highlight {
        font-size: 0.9em;
    }

    .res-delta {
        font-size: 0.7em;
    }

    .need-bar-bg {
        height: 6px;
    }

    .need-bar-fill {
        height: 100%;
    }

    .legend-circle,
    .legend-diamond,
    .legend-square,
    .legend-cross {
        width: 16px;
        height: 16px;
    }

    .legend-triangle {
        border-left-width: 8px;
        border-right-width: 8px;
        border-bottom-width: 14px;
    }

    .legend-cross::before,
    .legend-cross::after {
        width: 5px;
        height: 16px;
        left: 5.5px;
    }

    .legend-cross::after {
        width: 16px;
        height: 5px;
        top: 5.5px;
    }

    .const-progress-bg {
        height: 5px;
    }

    .const-progress-fill {
        height: 100%;
    }

    .court-layout {
        flex-direction: column;
    }

    .court-main, .court-sidebar {
        flex: none;
        width: 100%;
    }
}

@media (max-width: 480px) {
    body {
        font-size: 13px;
    }

    .screen {
        padding: clamp(6px, 2vw, 12px);
    }

    .tab-view {
        padding: clamp(10px, 3vw, 16px);
        margin-bottom: 55px;
    }

    .chat-panel {
        height: 50vh;
    }

    .chat-log {
        padding: 12px;
        gap: 8px;
    }

    .msg {
        padding: 8px 10px;
        max-width: 98%;
        font-size: 0.85em;
    }

    .input-area {
        padding: 10px;
    }

    .send-btn {
        width: 40px;
        font-size: 0.9em;
    }

    .bottom-nav {
        height: 45px;
        font-size: 0.7em;
    }

    .nav-btn {
        font-size: 0.65em;
    }

    .nav-icon {
        font-size: 1.1em;
    }

    .modal-content {
        width: 98vw;
        padding: 12px;
    }

    .btn-main {
        padding: 10px;
        font-size: 0.85em;
    }

    .btn-sec {
        padding: 5px 8px;
        font-size: 0.8em;
    }

    h1, h2, h3 {
        font-size: clamp(1.3rem, 4vw, 2rem);
        margin-bottom: 10px;
    }

    .stat-card {
        padding: 8px;
    }

    .stat-val {
        font-size: 1em;
    }

    .pop-card {
        padding: 8px;
    }

    .person-card {
        padding: 10px;
    }

    .diplomacy-card {
        padding: 8px 10px;
    }

    .law-card {
        padding: 8px;
    }

    .asset-card {
        padding: 8px;
    }

    .faction-effect-card {
        padding: 8px;
    }

    .tax-card {
        padding: 6px;
    }

    .event-card {
        padding: 8px 10px;
    }

    .action-card {
        padding: 8px;
    }

    .building-card-ui {
        padding: 10px;
    }

    .save-entry {
        padding: 6px 8px;
    }

    .section-toggle {
        padding: 6px 10px;
    }

    .section-panel {
        padding: 8px;
    }

    .private-selector button {
        font-size: 0.75em;
        padding: 5px 6px;
    }

    .faction-chip {
        font-size: 0.65em;
        padding: 2px 6px;
    }

    .panel-title {
        font-size: 0.75em;
    }

    .event-empty,
    .action-empty {
        font-size: 0.75em;
    }

    .action-prompt {
        font-size: 0.75em;
    }

    .toolbar-status {
        font-size: 0.65em;
    }

    .season-highlight {
        font-size: 0.85em;
    }

    .res-delta {
        font-size: 0.65em;
    }

    .need-header {
        font-size: 0.75em;
    }

    .relation-row {
        font-size: 0.8em;
    }

    .const-card {
        padding: 6px 8px;
    }

    .const-header {
        font-size: 0.85em;
    }

    .const-meta {
        font-size: 0.7em;
    }

    .map-legend {
        font-size: 0.85em;
    }

    .legend-item {
        margin-bottom: 4px;
    }

    .legend-circle,
    .legend-diamond,
    .legend-square,
    .legend-cross {
        width: 14px;
        height: 14px;
    }

    .legend-triangle {
        border-left-width: 7px;
        border-right-width: 7px;
        border-bottom-width: 12px;
    }

    .legend-cross::before,
    .legend-cross::after {
        width: 4px;
        height: 14px;
        left: 5px;
    }

    .legend-cross::after {
        width: 14px;
        height: 4px;
        top: 5px;
    }

    .const-progress-bg {
        height: 4px;
    }

    .const-progress-fill {
        height: 100%;
    }
}

.court-layout {
    display: grid;
    grid-template-columns: 1fr 300px;
    gap: 20px;
    align-items: start;
}

.court-main {
    min-width: 0;
}

.court-sidebar {
    min-width: 0;
}

.sidebar-panel {
    background: #161616;
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 8px;
    margin-bottom: 8px;
}

.event-feed.compact {
    max-height: 200px;
    overflow-y: auto;
}

.panel-title {
    font-size: 0.9em;
    font-weight: bold;
    margin-bottom: 6px;
}

.faction-chips-inline {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
    align-items: center;
}

.faction-chip {
    font-size: 0.75em;
    padding: 2px 6px;
    border-radius: 4px;
    background: var(--accent);
    color: #000;
}

@media (max-width: 900px) {
    .court-layout {
        grid-template-columns: 1fr;
        gap: 10px;
    }

    .court-sidebar {
        order: -1;
    }
}

/* ===================== MODALE BILANCIO (TESORERIA) ===================== */
.budget-container {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.budget-columns {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
}

@media (max-width: 600px) {
    .budget-columns { grid-template-columns: 1fr; }
}

.budget-col h4 {
    border-bottom: 1px solid var(--border-soft);
    padding-bottom: 8px;
    margin-bottom: 10px;
    color: var(--text-soft);
    text-transform: uppercase;
    font-size: 0.85em;
}

.budget-row {
    display: flex;
    justify-content: space-between;
    padding: 6px 0;
    border-bottom: 1px dashed rgba(255,255,255,0.05);
    font-size: 0.9em;
}

.budget-row.total {
    border-top: 1px solid var(--border-soft);
    border-bottom: none;
    margin-top: 10px;
    padding-top: 10px;
    font-weight: bold;
    font-size: 1.1em;
}

.money-plus { color: #6ada91; }
.money-minus { color: #ff7c7c; }

.net-balance-card {
    background: rgba(0,0,0,0.3);
    border: 1px solid var(--border-soft);
    border-radius: 12px;
    padding: 15px;
    text-align: center;
    margin-top: 10px;
}

.net-balance-val {
    font-size: 1.8em;
    font-weight: bold;
    margin: 5px 0;
}

#modal-budget {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.7);
    z-index: 1000;
    justify-content: center;
    align-items: center;
}

#modal-budget.active {
    display: flex;
}

#budget-content {
    background: var(--bg-card);
    padding: 20px;
    border-radius: 12px;
    max-width: 600px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
}

.budget-section {
    margin-bottom: 20px;
}

.budget-section h3 {
    margin-bottom: 10px;
    color: var(--accent);
}

.budget-row {
    display: flex;
    justify-content: space-between;
    padding: 5px 0;
    border-bottom: 1px solid var(--border-soft);
}

.budget-total {
    font-weight: bold;
    margin-top: 10px;
}

.money-plus {
    color: #4caf50;
}

.money-minus {
    color: #f44336;
}

.budget-net {
    text-align: center;
    font-size: 1.2em;
    margin-top: 20px;
    padding: 10px;
    border-radius: 8px;
    background: var(--bg-hover);
}

/* Stile per il nome del personaggio */
.chat-name {
    display: block;
    font-size: 0.85em;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--accent); /* Oro */
    margin-bottom: 4px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    padding-bottom: 2px;
    width: fit-content;
}

/* Stile per il testo del messaggio */
.chat-content {
    color: #e0e0e0;
    font-size: 1em;
    line-height: 1.5;
}

/* Stile specifico per la Narrazione (SCENA) */
.msg-narrative {
    background: rgba(0, 0, 0, 0.4);
    border-left: 3px solid #555;
    color: #aaa;
    font-style: italic;
    padding: 10px 15px;
    margin: 10px 0;
    border-radius: 0 8px 8px 0;
}

/* ===================== NUOVI STILI MESSAGGI ===================== */

/* 1. LA SCENA (Narrativa) - Sfondo scuro, corsivo, centrato o largo */
.msg-scene {
    background: rgba(20, 20, 25, 0.6);
    border-left: 4px solid #666;
    color: #aaa; /* Grigio chiaro */
    font-family: 'Georgia', serif;
    font-style: italic;
    padding: 12px 16px;
    margin: 15px 0; /* Spazio sopra e sotto */
    border-radius: 4px;
    font-size: 0.95em;
    box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
}

/* 2. IL DIALOGO (Personaggi) - Bolle separate */
.msg-char {
    background: #1e1e1e;
    border: 1px solid #333;
    border-radius: 12px;
    padding: 12px 16px;
    margin-bottom: 10px; /* Separazione tra messaggi */
    position: relative;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    max-width: 90%; /* Non prende tutta la larghezza */
}

/* Nome del personaggio sopra il messaggio */
.char-name {
    color: var(--accent); /* Oro */
    font-size: 0.75em;
    text-transform: uppercase;
    letter-spacing: 1px;
    font-weight: bold;
    margin-bottom: 4px;
    display: block;
    border-bottom: 1px solid rgba(255,255,255,0.05);
    padding-bottom: 4px;
}

.char-text {
    color: #eee;
    line-height: 1.5;
    font-size: 1em;
}

/* 3. LE AZIONI (Proposte) - Contenitore dedicato */
.msg-actions {
    margin-top: 15px;
    padding: 10px;
    background: rgba(44, 62, 80, 0.3); /* Bluastro scuro */
    border: 1px dashed var(--accent);
    border-radius: 12px;
    text-align: center;
}

.action-header {
    font-size: 0.8em;
    text-transform: uppercase;
    color: #888;
    margin-bottom: 8px;
}

.market-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 12px;
}

.market-item {
    border: 1px solid var(--border-soft);
    border-radius: 12px;
    padding: 12px;
    background: var(--bg-panel);
}

.market-header {
    display: flex;
    justify-content: space-between;
    font-weight: bold;
    margin-bottom: 8px;
}

.market-prices {
    display: flex;
    gap: 8px;
    margin-bottom: 8px;
}

.market-stats {
    font-size: 0.8em;
    color: var(--text-soft);
}

.resource-stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 8px;
}

.resource-stat-item {
    border: 1px solid var(--border-soft);
    border-radius: 8px;
    padding: 8px;
    background: var(--bg-panel);
}

.resource-stat-header {
    font-weight: bold;
    margin-bottom: 4px;
}

.resource-stat-values {
    display: flex;
    justify-content: space-between;
    font-size: 0.8em;
}

.resource-stat-values .positive { color: #6ada91; }
.resource-stat-values .negative { color: #ff7c7c; }

.market-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 12px;
}

.market-item {
    border: 1px solid var(--border-soft);
    border-radius: 12px;
    padding: 12px;
    background: var(--bg-panel);
}

.market-item.special {
    border-color: var(--accent);
    background: rgba(212, 175, 55, 0.1);
}

.market-header {
    display: flex;
    justify-content: space-between;
    font-weight: bold;
    margin-bottom: 8px;
}

.market-prices {
    display: flex;
    gap: 8px;
    margin-bottom: 8px;
}

.market-stats {
    font-size: 0.8em;
    color: var(--text-soft);
}

.market-desc {
    font-size: 0.8em;
    color: var(--text-soft);
    margin-top: 4px;
}

.diplomacy-actions {
    margin-top: 12px;
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
}

.market-section {
    margin-bottom: 20px;
}

.market-section h5 {
    color: var(--accent);
    margin-bottom: 8px;
    font-size: 0.9em;
}

.market-item.surplus {
    border-color: #4CAF50;
    background: rgba(76, 175, 80, 0.1);
}

.market-item.deficit {
    border-color: #f44336;
    background: rgba(244, 67, 54, 0.1);
}

.market-table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 20px;
    background: var(--bg-panel);
    border: 1px solid var(--border-soft);
    border-radius: 8px;
    overflow: hidden;
}

.market-table th {
    background: var(--bg-panel-alt);
    color: var(--accent);
    padding: 12px 8px;
    text-align: left;
    font-weight: bold;
    border-bottom: 1px solid var(--border-soft);
}

.market-table td {
    padding: 10px 8px;
    border-bottom: 1px solid var(--border-soft);
    vertical-align: middle;
}

.market-table tr:hover {
    background: rgba(212, 175, 55, 0.05);
}

.market-table .btn-sec {
    margin: 0 2px;
    padding: 4px 8px;
    font-size: 0.8em;
}

/* ===================== CLASSI SOCIALI ===================== */
.social-classes-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    gap: 8px;
    margin-bottom: 16px;
}

.social-class-card {
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 10px;
    text-align: center;
    transition: all 0.2s ease;
}

.social-class-card:hover {
    border-color: var(--accent);
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.social-class-header {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    margin-bottom: 8px;
    font-size: 0.9em;
    font-weight: 500;
}

.social-class-icon {
    font-size: 1.2em;
}

.social-class-name {
    color: var(--text);
}

.social-class-stats {
    display: flex;
    flex-direction: column;
    gap: 2px;
}

.social-class-count {
    font-size: 1.1em;
    font-weight: bold;
    color: var(--text);
}

.social-class-wealth {
    font-size: 0.8em;
    color: var(--text-soft);
}

/* ===================== STILI MERCATO MIGLIORATI ===================== */

.market-qty-input {
    width: 60px !important; /* Forza larghezza fissa */
    padding: 6px !important;
    text-align: center;
    margin: 0 4px;
    background: #222;
    border: 1px solid var(--border-soft);
    color: var(--text);
    border-radius: 4px;
}

/* Nascondi le frecce input number (opzionale, per pulizia) */
.market-qty-input::-webkit-outer-spin-button,
.market-qty-input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
}

/* Responsive Table: Trasforma la tabella in card su mobile */
@media (max-width: 768px) {
    .market-table, .market-table tbody, .market-table tr, .market-table td {
        display: block;
        width: 100%;
    }
    
    .market-table thead {
        display: none; /* Nascondi intestazione su mobile */
    }
    
    .market-table tr {
        margin-bottom: 15px;
        background: var(--bg-panel);
        border: 1px solid var(--border-soft);
        border-radius: 12px;
        padding: 12px;
        box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    }
    
    .market-table td {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 0;
        border-bottom: 1px solid rgba(255,255,255,0.05);
        text-align: right;
    }
    
    .market-table td:last-child {
        border-bottom: none;
        padding-top: 12px;
        justify-content: center;
        flex-wrap: wrap;
        gap: 8px;
    }

    /* Aggiunge etichette simulate via CSS per ogni cella */
    .market-table td:nth-of-type(1):before { content: "Risorsa"; font-weight: bold; color: var(--accent); }
    .market-table td:nth-of-type(2):before { content: "In Stock"; color: var(--text-soft); }
    .market-table td:nth-of-type(3):before { content: "Fabbisogno"; color: var(--text-soft); }
    .market-table td:nth-of-type(4):before { content: "Domanda"; color: var(--text-soft); }
    .market-table td:nth-of-type(5):before { content: "Offerta"; color: var(--text-soft); }
    .market-table td:nth-of-type(6):before { content: "Prezzo Acquisto"; color: #ff7c7c; }
    .market-table td:nth-of-type(7):before { content: "Prezzo Vendita"; color: #6ada91; }

    /* Nascondi il label per la cella delle azioni */
    .market-table td:last-child:before { content: ""; display: none; }

    /* Stile risorsa principale più grande */
    .market-table td:nth-of-type(1) {
        font-size: 1.1em;
        border-bottom: 1px solid var(--accent);
        margin-bottom: 8px;
        padding-bottom: 8px;
    }
}

/* ===================== STILI DINASTIA ===================== */

.dynasty-header-card {
    background: linear-gradient(135deg, #2c1e10, #1a1a1a);
    border: 2px solid var(--accent);
    padding: 20px;
    border-radius: 12px;
    text-align: center;
    margin-bottom: 20px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
}

.dynasty-role {
    font-size: 0.8em;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--text-soft);
    margin-bottom: 5px;
}

.dynasty-stats {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin: 10px 0;
    font-size: 1.1em;
}

.dynasty-traits {
    font-style: italic;
    color: #aaa;
}

.dynasty-section {
    margin-bottom: 20px;
    background: rgba(255,255,255,0.03);
    padding: 15px;
    border-radius: 12px;
    border: 1px solid var(--border-soft);
}

.dynasty-section h4 {
    border-bottom: 1px solid var(--border-soft);
    padding-bottom: 8px;
    margin-bottom: 15px;
    color: var(--accent);
}

.dynasty-empty-slot {
    text-align: center;
    padding: 20px;
    border: 2px dashed var(--border-soft);
    border-radius: 8px;
    color: var(--text-soft);
}

.heir-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 10px;
}

.person-card-ui {
    background: #222;
    border: 1px solid #444;
    padding: 10px;
    border-radius: 8px;
    text-align: center;
}

.person-card-ui.heir { border-color: #6ada91; }
.person-card-ui.spouse { border-color: #d4af37; }

.candidate-card {
    background: #1a1a1a;
    border: 1px solid #444;
    padding: 15px;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.candidate-origin { font-size: 0.8em; color: var(--accent); }
.candidate-bonus { font-size: 0.9em; color: #81c784; }

.top-hud {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    background: linear-gradient(135deg, #2c1810 0%, #4a2c1a 100%);
    border-bottom: 2px solid #8b4513;
    z-index: 1000;
    padding: 10px 20px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
}

.hud-stats-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.hud-stats-bar .stat {
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 1.1em;
    color: #f4e4bc;
}

.hud-stats-bar .stat i {
    color: #daa520;
}

.hud-nav-bar {
    display: flex;
    justify-content: center;
    gap: 15px;
}

.hud-nav-bar button {
    background: rgba(255,255,255,0.1);
    border: 1px solid #daa520;
    color: #f4e4bc;
    padding: 8px 16px;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 0.9em;
}

.hud-nav-bar button:hover {
    background: rgba(255,255,255,0.2);
    transform: translateY(-1px);
}

.hud-nav-bar button.active {
    background: #daa520;
    color: #2c1810;
}

.system-toolbar {
    margin-top: 80px; /* Space for fixed HUD */
    padding: 20px;
}

.season-effects-text {
    text-align: center;
    margin-bottom: 20px;
    font-style: italic;
    color: #8b4513;
}

/* Mobile responsiveness */
@media (max-width: 768px) {
    .top-hud {
        padding: 8px 10px;
    }
    .hud-stats-bar {
        flex-direction: column;
        gap: 8px;
        align-items: flex-start;
    }
    .hud-stats-bar .stat {
        font-size: 1em;
    }
    .hud-nav-bar {
        flex-wrap: wrap;
        gap: 8px;
    }
    .hud-nav-bar button {
        padding: 6px 12px;
        font-size: 0.8em;
    }
    .system-toolbar {
        margin-top: 120px; /* Adjust for mobile HUD height */
        padding: 15px;
    }
}

    </style>
</head>

<body>

<!-- MENU INIZIALE -->
<div id="screen-start" class="screen active">
    <div class="start-hero">
        <h1>Il Conte a Corte</h1>
        <p>Gestisci il tuo dominio, conserva la memoria delle partite e prepara il tono della corte.</p>
    </div>

    <div class="start-grid">
        <div class="start-card">
            <h3>Chiave API Groq</h3>
            <p class="toolbar-status">Archivia la chiave per evitarne l'inserimento a ogni avvio.</p>
            <input id="api-key-start" type="password" placeholder="gsk_xxxxxxxxx" />
            <div style="display:flex; gap:10px; flex-wrap:wrap;">
                <button class="btn-main" onclick="saveApiKeyFromStart()">Salva chiave</button>
                <button class="btn-sec" onclick="clearStoredApiKey()">Rimuovi</button>
                <button class="btn-sec" onclick="openLoginScreen()">Accedi</button>
            </div>
            <span id="api-key-status" class="toolbar-status">Chiave non impostata.</span>
        </div>

        <div class="start-card">
            <h3>Nuova Partita</h3>
            <p class="toolbar-status">Prepara un nuovo regno e configura i tuoi consiglieri.</p>
            <button class="btn-main" onclick="goToEditorScreen()">Crea nuovo regno</button>
            <button class="btn-sec" onclick="openLoginScreen()">Gestisci accesso</button>
        </div>

        <div class="start-card">
            <h3>Partite Salvate</h3>
            <div id="save-list"></div>
            <button class="btn-sec" onclick="openLoadModal()">Gestisci salvataggi</button>
            <div class="start-nav-icons" style="margin-top:12px; display:flex; gap:18px; justify-content:space-between; align-items:center; padding-top:10px; border-top:1px dashed var(--border-soft);">
                <div style="text-align:center; flex:1;">
                    <div style="font-size:20px">🏰</div>
                    <div style="font-size:12px; color:var(--text-soft);">Dominio</div>
                </div>
                <div style="text-align:center; flex:1;">
                    <div style="font-size:20px">⚖️</div>
                    <div style="font-size:12px; color:var(--text-soft);">Diplomazia</div>
                </div>
                <div style="text-align:center; flex:1;">
                    <div style="font-size:20px">🗺️</div>
                    <div style="font-size:12px; color:var(--text-soft);">Mappa</div>
                </div>
                <div style="text-align:center; flex:1;">
                    <div style="font-size:20px">📜</div>
                    <div style="font-size:12px; color:var(--text-soft);">Cronache</div>
                </div>
                <div style="text-align:center; flex:1;">
                    <div style="font-size:20px">🗣️</div>
                    <div style="font-size:12px; color:var(--text-soft);">Interlocutori</div>
                </div>
            </div>
        </div>

        <div class="start-card personality-form">
            <h3>Editor Personalità</h3>
            <label for="personality-tone">Tono del Consigliere</label>
            <select id="personality-tone">
                <option value="saggio">Saggio</option>
                <option value="pragmatico">Pragmatico</option>
                <option value="ambizioso">Ambizioso</option>
                <option value="misterioso">Misterioso</option>
            </select>

            <label for="personality-mood">Atmosfera della Corte</label>
            <select id="personality-mood">
                <option value="prudente">Prudente</option>
                <option value="bellicosa">Bellicosa</option>
                <option value="visionaria">Visionaria</option>
                <option value="ombrosa">Ombrosa</option>
            </select>

            <label for="personality-notes">Appunti della Corte</label>
            <textarea id="personality-notes" placeholder="Annota mantra, paure o principi che guidano il regno..."></textarea>

            <button class="btn-main" onclick="savePersonalitySettingsForm()">Salva Personalità</button>
        </div>
    </div>
</div>

<!-- SCHERMATA LOGIN -->
<div id="screen-login" class="screen">
    <h2>Accesso al Regno</h2>
    <label>Chiave API Groq:</label>
    <input id="api-key-input" type="text" placeholder="gsk_xxxxxxxxx" />

    <button class="btn-main" onclick="loginManual()">Entra</button>
</div>

<!-- EDITOR INIZIALE -->
<div id="screen-editor" class="screen">
    <h2>Crea il tuo Regno</h2>

    <label>Nome del Conte:</label>
    <input id="hero-name" type="text" placeholder="Es. Conte Alaric" />

    <label>Descrivi la tua Contea iniziale:</label>
    <textarea id="county-desc-init"></textarea>

    <label>Consigliere – Nome:</label>
    <input id="adv-name" type="text" placeholder="Es. Ser Dorian" />

    <label>Consigliere – Personalità:</label>
    <select id="adv-pers">
        <option value="saggio">Saggio</option>
        <option value="pragmatico">Pragmatico</option>
        <option value="ambizioso">Ambizioso</option>
        <option value="pauroso">Pauroso</option>
        <option value="corrotto">Corrotto</option>
    </select>

    <button class="btn-main" onclick="startGame()">Inizia il Regno</button>
</div>

<!-- SCHERMATA DI GIOCO PRINCIPALE -->
<div id="screen-game" class="screen">
    <div class="top-hud">
        <div class="hud-stats-bar">
            <div class="stat"><i class="fas fa-calendar-alt"></i> <span id="hud-season">Primavera 1325</span></div>
            <div class="stat"><i class="fas fa-coins"></i> <span id="hud-gold">0</span></div>
            <div class="stat"><i class="fas fa-users"></i> <span id="hud-pop">0</span></div>
            <div class="stat"><i class="fas fa-smile"></i> <span id="hud-happy">50</span></div>
            <div class="stat"><i class="fas fa-shield-alt"></i> <span id="hud-security">50</span></div>
        </div>
        <div class="hud-nav-bar">
            <button onclick="switchTab('tab-dominio', this)">🏰 Dominio</button>
            <button onclick="switchTab('tab-diplomacy', this)">⚖️ Diplomazia</button>
            <button onclick="switchTab('tab-map', this)">🗺️ Mappa</button>
            <button onclick="switchTab('tab-market', this)">🏪 Mercato</button>
            <button onclick="switchTab('tab-dynasty', this)">👑 Dinastia</button>
            <button onclick="switchTab('tab-chat', this)">📜 Cronache</button>
            <button onclick="switchTab('tab-private', this)">🗣️ Interlocutori</button>
        </div>
    </div>

    <div class="system-toolbar">
        <div class="season-effects-text" id="season-effects-text">Il clima è mite, i raccolti prosperano.</div>

<!-- ================= TAB: DOMINIO ================= -->
<div id="tab-dominio" class="tab-view active-tab">

    <h2>Il Dominio del Conte</h2>

    <h3>Descrizione</h3>
    <p id="visual-desc">Una giovane contea in attesa del suo destino…</p>

    <!-- ===================== STATISTICHE GENERALI ===================== -->
    <h3>Statistiche</h3>
    <div class="grid-stats">
        <div class="stat-card">
            <div class="stat-val" id="val-pop">0</div>
            <div class="stat-sub">Popolazione</div>
        </div>

        <div class="stat-card" style="cursor:pointer;" onclick="openBudgetModal()">
            <div class="stat-val" id="val-gold">0</div>
            <div class="stat-sub">Oro</div>
        </div>
    </div>

    <!-- ===================== NEED BARS ===================== -->
    <div class="need-row">
        <div class="need-header">
            <span>Cibo</span>
            <span id="txt-food">0%</span>
        </div>
        <div class="need-bar-bg">
            <div class="need-bar-fill fill-food" id="bar-food"></div>
        </div>
    </div>

    <div class="need-row">
        <div class="need-header">
            <span>Salute</span>
            <span id="txt-health">0%</span>
        </div>
        <div class="need-bar-bg">
            <div class="need-bar-fill fill-health" id="bar-health"></div>
        </div>
    </div>

    <div class="need-row">
        <div class="need-header">
            <span>Felicità</span>
            <span id="txt-happy">0%</span>
        </div>
        <div class="need-bar-bg">
            <div class="need-bar-fill fill-happy" id="bar-happy"></div>
        </div>
    </div>

    <div class="need-row">
        <div class="need-header">
            <span>Stabilità Sociale</span>
            <span id="txt-stability">0%</span>
        </div>
        <div class="need-bar-bg">
            <div class="need-bar-fill fill-stability" id="bar-stability"></div>
        </div>
    </div>

    <!-- ===================== CLASSI SOCIALI ===================== -->
    <h3>Classi Sociali</h3>
    <div class="social-classes-grid">
        <div class="social-class-card">
            <div class="social-class-header">
                <span class="social-class-icon">👑</span>
                <span class="social-class-name">Nobiltà</span>
            </div>
            <div class="social-class-stats">
                <div class="social-class-count" id="nobility-count">0</div>
                <div class="social-class-wealth" id="nobility-wealth">0💰</div>
            </div>
        </div>
        
        <div class="social-class-card">
            <div class="social-class-header">
                <span class="social-class-icon">⛪</span>
                <span class="social-class-name">Clero</span>
            </div>
            <div class="social-class-stats">
                <div class="social-class-count" id="clergy-count">0</div>
                <div class="social-class-wealth" id="clergy-wealth">0💰</div>
            </div>
        </div>
        
        <div class="social-class-card">
            <div class="social-class-header">
                <span class="social-class-icon">⚔️</span>
                <span class="social-class-name">Milizia</span>
            </div>
            <div class="social-class-stats">
                <div class="social-class-count" id="militia-count">0</div>
                <div class="social-class-wealth" id="militia-wealth">0💰</div>
            </div>
        </div>
        
        <div class="social-class-card">
            <div class="social-class-header">
                <span class="social-class-icon">🏛️</span>
                <span class="social-class-name">Borghesi</span>
            </div>
            <div class="social-class-stats">
                <div class="social-class-count" id="burghers-count">0</div>
                <div class="social-class-wealth" id="burghers-wealth">0💰</div>
            </div>
        </div>
        
        <div class="social-class-card">
            <div class="social-class-header">
                <span class="social-class-icon">👥</span>
                <span class="social-class-name">Contadini</span>
            </div>
            <div class="social-class-stats">
                <div class="social-class-count" id="peasants-count">0</div>
                <div class="social-class-wealth" id="peasants-wealth">0💰</div>
            </div>
        </div>
        
        <div class="social-class-card">
            <div class="social-class-header">
                <span class="social-class-icon">🔮</span>
                <span class="social-class-name">Mistici</span>
            </div>
            <div class="social-class-stats">
                <div class="social-class-count" id="mystics-count">0</div>
                <div class="social-class-wealth" id="mystics-wealth">0💰</div>
            </div>
        </div>
        
        <div class="social-class-card">
            <div class="social-class-header">
                <span class="social-class-icon">🏚️</span>
                <span class="social-class-name">Emarginati</span>
            </div>
            <div class="social-class-stats">
                <div class="social-class-count" id="outcasts-count">0</div>
                <div class="social-class-wealth" id="outcasts-wealth">0💰</div>
            </div>
        </div>
        
        <div class="social-class-card">
            <div class="social-class-header">
                <span class="social-class-icon">⚖️</span>
                <span class="social-class-name">Mercanti</span>
            </div>
            <div class="social-class-stats">
                <div class="social-class-count" id="merchants-count">0</div>
                <div class="social-class-wealth" id="merchants-wealth">0💰</div>
            </div>
        </div>
    </div>

    <!-- ===================== RISORSE INVENTARIO ===================== -->
    <h3>Territorio</h3>

    <div class="grid-stats">
        <div class="stat-card">
            <div class="stat-val" id="land-count">0</div>
            <div class="stat-sub">Terre del Conte</div>
        </div>
        <div class="stat-card">
            <div class="stat-val" id="land-nobility">0</div>
            <div class="stat-sub">Nobiltà</div>
        </div>
        <div class="stat-card">
            <div class="stat-val" id="land-clergy">0</div>
            <div class="stat-sub">Clero</div>
        </div>
        <div class="stat-card">
            <div class="stat-val" id="land-commons">0</div>
            <div class="stat-sub">Comuni</div>
        </div>
    </div>

    <!-- ===================== RISORSE INVENTARIO ===================== -->
    <button class="section-toggle" onclick="togglePanel('panel-resources')">
        Risorse e Magazzini
        <span>Apri/chiudi elenco</span>
    </button>
    <div id="panel-resources" class="section-panel">
        <div class="grid-stats resource-grid">
            <div class="stat-card">
                <div class="stat-val" id="res-wood">0</div>
                <div class="stat-sub">Legno</div>
                <small class="res-delta" id="res-wood-delta">—</small>
            </div>
            <div class="stat-card">
                <div class="stat-val" id="res-stone">0</div>
                <div class="stat-sub">Pietra</div>
                <small class="res-delta" id="res-stone-delta">—</small>
            </div>
            <div class="stat-card">
                <div class="stat-val" id="res-iron">0</div>
                <div class="stat-sub">Ferro</div>
                <small class="res-delta" id="res-iron-delta">—</small>
            </div>
            <div class="stat-card">
                <div class="stat-val" id="res-copper">0</div>
                <div class="stat-sub">Rame</div>
                <small class="res-delta" id="res-copper-delta">—</small>
            </div>
            <div class="stat-card">
                <div class="stat-val" id="res-gold">0</div>
                <div class="stat-sub">Oro grezzo</div>
                <small class="res-delta" id="res-gold-delta">—</small>
            </div>
            <div class="stat-card">
                <div class="stat-val" id="res-herbs">0</div>
                <div class="stat-sub">Erbe medicinali</div>
                <small class="res-delta" id="res-herbs-delta">—</small>
            </div>
            <div class="stat-card">
                <div class="stat-val" id="res-grain">0</div>
                <div class="stat-sub">Grano</div>
                <small class="res-delta" id="res-grain-delta">—</small>
            </div>
            <div class="stat-card">
                <div class="stat-val" id="res-livestock">0</div>
                <div class="stat-sub">Bestiame</div>
                <small class="res-delta" id="res-livestock-delta">—</small>
            </div>
            <div class="stat-card">
                <div class="stat-val" id="res-textiles">0</div>
                <div class="stat-sub">Tessuti</div>
                <small class="res-delta" id="res-textiles-delta">—</small>
            </div>
            <div class="stat-card">
                <div class="stat-val" id="res-luxuries">0</div>
                <div class="stat-sub">Beni di pregio</div>
                <small class="res-delta" id="res-luxuries-delta">—</small>
            </div>
            <div class="stat-card">
                <div class="stat-val" id="res-arcane">0</div>
                <div class="stat-sub">Essenza arcana</div>
                <small class="res-delta" id="res-arcane-delta">—</small>
            </div>
        </div>
    </div>

    <button class="section-toggle" onclick="togglePanel('panel-assets')">
        Sintesi Insediamenti
        <span>Case, botteghe, campi…</span>
    </button>
    <div id="panel-assets" class="section-panel collapsed">
        <div id="asset-summary" class="asset-grid">
            <div class="asset-card">I dettagli compariranno dopo l'avvio.</div>
        </div>
    </div>

    <button class="section-toggle" onclick="togglePanel('panel-factions')">
        Influenze delle Fazioni
        <span>Mostra condizioni correnti</span>
    </button>
    <div id="panel-factions" class="section-panel collapsed">
        <div id="faction-impact-list" class="faction-effects">
            <div class="faction-effect-card">Le fazioni reagiranno dopo il primo turno.</div>
        </div>
    </div>

    <button class="section-toggle" onclick="togglePanel('panel-taxes')">
        Politica Fiscale
        <span>Modifica categorie</span>
    </button>
    <div id="panel-taxes" class="section-panel collapsed">
        <div class="tax-panel">
            <div id="tax-grid" class="tax-grid"></div>
            <div class="tax-summary">
                <span>Entrate ultimo turno: <strong id="tax-last">0</strong> oro</span>
                <span>Trend: <strong id="tax-trend">—</strong></span>
            </div>
        </div>
    </div>

    <button class="section-toggle" onclick="togglePanel('panel-laws')">
        Leggi e Decreti
        <span>Gestisci editti</span>
    </button>
    <div id="panel-laws" class="section-panel collapsed">
        <div id="law-list" class="law-list" style="margin-bottom:12px;"></div>
        <div class="law-creator">
            <input id="law-custom-name" type="text" placeholder="Nome della legge" />
            <textarea id="law-custom-desc" placeholder="Descrivi obiettivi e vincoli"></textarea>
            <select id="law-custom-type">
                <option value="production">Bonus produzione</option>
                <option value="taxes">Modifica tassazione</option>
                <option value="factions">Influenza fazioni</option>
            </select>
            <select id="law-custom-target"></select>
            <input id="law-custom-value" type="number" step="0.5" placeholder="Valore (es. 10)" />
            <button class="btn-main" onclick="createCustomLaw()">Istituisci nuova legge</button>
        </div>
    </div>

    <!-- ===================== RAPPRESENTANTI DELLE FAZIONI ===================== -->
    <h3>Rappresentanti delle Fazioni</h3>

    <div class="representatives-grid">
        <div class="person-card">
            <div class="person-name">Lord Emeric di Montferrand</div>
            <div>Nobiltà — 46 anni. Orgoglioso e ambizioso.</div>
        </div>

        <div class="person-card">
            <div class="person-name">Vescovo Aldebrando di Sorenza</div>
            <div>Clero — 62 anni. Inflessibile e calcolatore.</div>
        </div>

        <div class="person-card">
            <div class="person-name">Capitano Ronan il Ferro</div>
            <div>Milizia — 38 anni. Diretto, leale, irritabile.</div>
        </div>

        <div class="person-card">
            <div class="person-name">Odric il Lavoratore</div>
            <div>Contadini — 33 anni. Paziente ma oppresso.</div>
        </div>

        <div class="person-card">
            <div class="person-name">Maestro Bernard Forgiatore</div>
            <div>Artigiani — 51 anni. Orgoglioso del mestiere.</div>
        </div>

        <div class="person-card">
            <div class="person-name">Ser Lothar dei Ponti</div>
            <div>Mercanti — 42 anni. Subdolo, affabile.</div>
        </div>

        <div class="person-card">
            <div class="person-name">Madre Elowen la Veggente</div>
            <div>Mistici — 67 anni. Enigmatica, calma.</div>
        </div>

        <div class="person-card">
            <div class="person-name">Rasko il Senzapatria</div>
            <div>Emarginati — 29 anni. Imprevedibile e rapido.</div>
        </div>
    </div>

</div>
<!-- ====================== TAB: DIPLOMAZIA ====================== -->
<div id="tab-diplomacy" class="tab-view">

    <h2>Diplomazia con le Contee Vicine</h2>

    <!-- Contea di Auvrey -->
    <div class="diplomacy-card">
        <h3>Contea di Auvrey</h3>
        <div class="relation-row">
            <span>Relazioni:</span> <span id="rel-auvrey">0</span>
        </div>
        <div class="relation-row">
            <span>Potenza:</span> <span id="pow-auvrey">0</span>
        </div>
        <div class="relation-row">
            <span>Aggressività:</span> <span id="agg-auvrey">0</span>
        </div>
        <div class="relation-row">
            <span>Territorio:</span> <span id="land-auvrey">0</span>
        </div>
        <div class="diplomacy-actions">
            <button class="btn-sec" onclick="requestTradeMeeting('auvrey')">Chiedi Incontro per Accordi Commerciali</button>
        </div>
    </div>

    <!-- Baronia di Falken -->
    <div class="diplomacy-card">
        <h3>Baronia di Falken</h3>
        <div class="relation-row">
            <span>Relazioni:</span> <span id="rel-falken">0</span>
        </div>
        <div class="relation-row">
            <span>Potenza:</span> <span id="pow-falken">0</span>
        </div>
        <div class="relation-row">
            <span>Aggressività:</span> <span id="agg-falken">0</span>
        </div>
        <div class="relation-row">
            <span>Territorio:</span> <span id="land-falken">0</span>
        </div>
        <div class="diplomacy-actions">
            <button class="btn-sec" onclick="requestTradeMeeting('falken')">Chiedi Incontro per Accordi Commerciali</button>
        </div>
    </div>

</div>


<!-- ====================== TAB: MAPPA ====================== -->
<div id="tab-map" class="tab-view">

    <h2>Mappa della Contea</h2>
    <canvas id="county-map" width="480" height="480"
            style="border:1px solid #333; width:100%; margin-bottom:20px;"></canvas>

    <div class="map-legend">
        <div class="legend-item">
            <span class="legend-marker legend-circle"></span>
            <span>Villaggi e borghi del Conte</span>
        </div>
        <div class="legend-item">
            <span class="legend-marker legend-diamond"></span>
            <span>Miniere (metalli preziosi)</span>
        </div>
        <div class="legend-item">
            <span class="legend-triangle"></span>
            <span>Segherie e taglialegna</span>
        </div>
        <div class="legend-item">
            <span class="legend-marker legend-square"></span>
            <span>Cave e cantieri di pietra</span>
        </div>
        <div class="legend-item">
            <span class="legend-marker legend-cross"></span>
            <span>Monasteri e luoghi sacri</span>
        </div>
    </div>

    <h3>Mappa Regionale</h3>
    <canvas id="region-map" width="320" height="320"
            style="border:1px solid #333; width:100%;"></canvas>

</div>


<!-- ====================== TAB: MERCATO ====================== -->
<div id="tab-market" class="tab-view">
    <h3>Mercato Commerciale</h3>
    <p>Scambia risorse con le contee vicine e gestisci il mercato interno. I prezzi esterni riflettono gli accordi commerciali, mentre il mercato interno mostra surplus e deficit locali.</p>
    
    <div id="market-content">
        <!-- Contenuto popolato da renderMarket() -->
    </div>
</div>

<!-- ====================== TAB: DINASTIA ====================== -->
<div id="tab-dynasty" class="tab-view">
    <h2>Casata Reale</h2>
    
    <div class="dynasty-header-card">
        <div class="dynasty-role">Regnante Attuale</div>
        <h3 id="dynasty-ruler-name">Conte Alaric</h3>
        <div class="dynasty-stats">
            <span>Età: <strong id="dynasty-ruler-age">25</strong></span>
            <span>Salute: <strong id="dynasty-ruler-health">Ottima</strong></span>
        </div>
        <p id="dynasty-ruler-traits" class="dynasty-traits">Tratti: Ambizioso, Carismatico</p>
    </div>

    <div class="dynasty-section">
        <h4>Consorte</h4>
        <div id="spouse-container">
            <div class="dynasty-empty-slot">
                <p>Il Conte non è sposato.</p>
                <button class="btn-main" onclick="openMarriageMarket()">Cerca Pretendenti</button>
            </div>
        </div>
    </div>

    <div class="dynasty-section">
        <h4>Eredi e Figli</h4>
        <div id="heirs-list" class="heir-grid">
            <p class="text-soft">Nessun erede. La linea di successione è a rischio!</p>
        </div>
    </div>

    <div class="dynasty-section">
        <button class="section-toggle" onclick="togglePanel('court-marriage-panel')">
            Matrimoni di Corte
            <span>Fai sposare i consiglieri</span>
        </button>
        <div id="court-marriage-panel" class="section-panel collapsed">
            <p class="text-soft">Puoi combinare matrimoni per i tuoi consiglieri per rafforzare la lealtà delle fazioni.</p>
            <div id="court-marriage-list"></div>
        </div>
    </div>
</div>

<!-- ====================== TAB: CRONACHE (CHAT PUBBLICA) ====================== -->
<div id="tab-chat" class="tab-view">
    <div class="court-layout">
        
        <div class="court-main">
            <div class="chat-panel">
                <div class="chat-header">
                    <div style="display:flex; align-items:center; gap:10px;">
                        <span>👑 SALA DEL TRONO</span>
                        <span id="chat-turn" style="opacity:0.6; font-size:0.8em;">Anno 1325</span>
                    </div>
                    <div id="chat-faction-chips" class="faction-chips-inline"></div>
                </div>

                <div id="chat-log" class="chat-log"></div>

                <div class="input-area">
                    <input type="text" id="u-input" 
                           placeholder="Pronuncia un ordine, Conte..." 
                           autocomplete="off"
                           onkeypress="if(event.key==='Enter') send()">
                    <button class="send-btn" onclick="send()">➤</button>
                </div>
                
                <button class="season-advance-btn" onclick="advanceSeasonManually()">
                    🔔 Suona la campana (Avanza Stagione)
                </button>
            </div>
        </div>

        <div class="court-sidebar">
            
            <div class="sidebar-panel">
                <div class="panel-title">🏗️ Cantieri Reali</div>
                <div id="construction-feed" class="event-feed">
                    <p class="event-empty">Nessun cantiere.</p>
                </div>
            </div>

            <div class="sidebar-panel">
                <div class="panel-title">📜 Dispacci</div>
                <div id="event-feed" class="event-feed compact">
                    <p class="event-empty">Tutto tace.</p>
                </div>
            </div>

            <div class="sidebar-panel action-wrapper">
                <div class="panel-title">⚖️ Proposte</div>
                <div id="action-list" class="action-list compact"></div>
                <button class="btn-sec small" onclick="askAdvisor()">🧠 Chiedi consiglio</button>
            </div>

            <div class="sidebar-panel">
                <div class="panel-title">🧠 I Consigli di Ser Dorian</div>
                <div id="advice-feed" class="event-feed compact" style="min-height: 100px;">
                    <p class="advice-empty">Sono al vostro servizio, mio Signore.</p>
                </div>
            </div>

        </div>
    </div>
</div>


<!-- ====================== TAB: INTERLOCUTORI (CHAT PRIVATE) ====================== -->
<div id="tab-private" class="tab-view">
    <h2>Colloqui Privati</h2>

    <div id="family-chat-buttons" style="border-bottom:1px dashed #444; padding-bottom:10px; margin-bottom:10px; display:none;">
        <h4 style="margin:0 0 5px 0; color:var(--accent);">Casata Reale</h4>
        <div id="family-selector" class="private-selector" style="margin:0;">
            </div>
    </div>

    <h4 style="margin:0 0 5px 0; color:#888;">Fazioni e Vicini</h4>
    <div id="private-selector" class="private-selector">
        <button class="btn-sec" onclick="openPrivateChat('nobility')">Lord Emeric (Nobiltà)</button>
        <button class="btn-sec" onclick="openPrivateChat('clergy')">Vescovo Aldebrando (Clero)</button>
        <button class="btn-sec" onclick="openPrivateChat('militia')">Cap. Ronan (Milizia)</button>
        <button class="btn-sec" onclick="openPrivateChat('peasants')">Odric (Contadini)</button>
        <button class="btn-sec" onclick="openPrivateChat('burghers')">Bernard Forgiatore (Artigiani)</button>
        <button class="btn-sec" onclick="openPrivateChat('merchants')">Ser Lothar (Mercanti)</button>
        <button class="btn-sec" onclick="openPrivateChat('mystics')">Madre Elowen (Mistici)</button>
        <button class="btn-sec" onclick="openPrivateChat('outcasts')">Rasko (Emarginati)</button>
        <button class="btn-sec" onclick="openPrivateChat('auvrey')">Messo di Auvrey</button>
        <button class="btn-sec" onclick="openPrivateChat('falken')">Ambasciatrice di Falken</button>
    </div>

    <div id="private-chat-box" style="display:none;">
        <div class="chat-panel">
            <div class="chat-header" id="private-chat-title">Colloquio</div>
            <div id="private-chat-log" class="chat-log"></div>
            <div class="input-area">
                <input id="private-input" type="text" placeholder="Parla privatamente..." onkeypress="if(event.key==='Enter') sendPrivate()" />
                <button class="send-btn" onclick="sendPrivate()">➤</button>
            </div>
        </div>
        <button class="btn-main" style="margin-top:10px;" onclick="closePrivateChat()">Concludi colloquio</button>
    </div>
</div>

</div>

</div>

<div id="load-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Salvataggi</h3>
            <button class="close-btn" onclick="closeLoadModal()">✕</button>
        </div>

        <label for="save-slot-name">Nome salvataggio</label>
        <input id="save-slot-name" type="text" placeholder="Es. dopo assedio" />
        <button class="btn-main" onclick="manualSaveFromModal()">Salva in nuovo slot</button>

        <div id="modal-save-list"></div>
    </div>
</div>

<div id="modal-buildings" class="modal">
    <div class="modal-content" style="width: min(700px, 95vw);">
        <div class="modal-header">
            <h3>Registro dell'Architetto</h3>
            <button class="close-btn" onclick="closeBuildingModal()">✕</button>
        </div>
        <p style="font-size:0.9em; color:#aaa; margin-bottom:15px;">
            Seleziona un progetto per avviare il cantiere. Le risorse verranno dedotte immediatamente.
        </p>
        <div id="building-grid" class="start-grid">
            </div>
    </div>
</div>

<div id="modal-marriage" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Proposte di Matrimonio</h3>
            <button class="close-btn" onclick="closeMarriageModal()">✕</button>
        </div>
        <div id="marriage-candidates" class="start-grid"></div>
    </div>
</div>

<div id="modal-gameover" class="modal" style="z-index: 9999; background: black;">
    <div class="modal-content" style="text-align:center; border-color: #ff4444;">
        <h1 style="color:#ff4444; font-size: 3em;">DINASTIA ESTINTA</h1>
        <p id="gameover-reason">Il Conte è morto senza eredi legittimi.</p>
        <br>
        <button class="btn-main" onclick="location.reload()">Torna al Menu Principale</button>
    </div>
</div>

<script>
/* ============================================================
   =================== VARIABILI PRINCIPALI ====================
   ============================================================ */

let apiKey = "";
let heroName = "";

// --- DATI DINASTIA ---
let dynasty = {
    ruler: {
        name: "Conte", // Sarà sovrascritto da heroName
        age: 25,
        maxAge: 75 + Math.floor(Math.random() * 15), // Morte naturale tra 75 e 90
        health: 100,
        traits: ["Fondatore"]
    },
    spouse: null, // Oggetto { name, age, origin, bonus }
    heirs: []     // Array di oggetti { name, age, gender, traits }
};

let activeSuitorsList = []; // Per tenere traccia dei pretendenti generati

// Memoria della chat pubblica (ultimi 10-15 scambi)
let publicChatHistory = [];

const RESOURCE_KEYS = [
    "wood","stone","iron","copper","gold",
    "herbs","grain","livestock","textiles","luxuries","arcane"
];

const resourceLabels = {
    wood: "Legno",
    stone: "Pietra",
    iron: "Ferro",
    copper: "Rame",
    gold: "Oro",
    herbs: "Erbe",
    grain: "Grano",
    livestock: "Bestiame",
    textiles: "Tessuti",
    luxuries: "Beni di pregio",
    arcane: "Essenza arcana"
};

const SEASON_CYCLE = [
    {
        key: "spring",
        label: "Primavera",
        description: "Il disgelo porta nuova linfa ai campi.",
        production: { grain: 1.15, livestock: 1.05, herbs: 1.1 },
        warCost: 1,
        morale: { peasants: 2 }
    },
    {
        key: "summer",
        label: "Estate",
        description: "I mercati sono colmi e le strade sicure.",
        production: { grain: 1.05, livestock: 1.1, luxuries: 1.05 },
        warCost: 1.05,
        morale: { merchants: 2 }
    },
    {
        key: "autumn",
        label: "Autunno",
        description: "Si raccolgono tributi e si preparano le scorte.",
        production: { grain: 0.85, livestock: 0.9, herbs: 1.05 },
        warCost: 1.1,
        morale: { nobility: 1 }
    },
    {
        key: "winter",
        label: "Inverno",
        description: "La neve blocca i raccolti e le campagne militari sono dispendiose.",
        production: { grain: 0.2, livestock: 0.35, herbs: 0.6 },
        warCost: 1.35,
        morale: { peasants: -3, militia: -2 }
    }
];

function createDefaultWorldTime() {
    return { year: 1325, seasonIndex: 0 };
}

let worldTime = createDefaultWorldTime();

const TAX_CATEGORIES = [
    { key:"nobility", label:"Nobiltà", wealthFactor:6, tolerance:8 },
    { key:"clergy", label:"Clero", wealthFactor:4, tolerance:6 },
    { key:"militia", label:"Milizia", wealthFactor:3, tolerance:5 },
    { key:"peasants", label:"Contadini", wealthFactor:2, tolerance:4 },
    { key:"burghers", label:"Artigiani", wealthFactor:5, tolerance:7 },
    { key:"merchants", label:"Mercanti", wealthFactor:7, tolerance:9 },
    { key:"mystics", label:"Mistici", wealthFactor:3, tolerance:5 },
    { key:"outcasts", label:"Emarginati", wealthFactor:1, tolerance:3 }
];

function createDefaultTaxPolicy() {
    const policy = {};
    TAX_CATEGORIES.forEach(cat => { policy[cat.key] = 5; });
    return policy;
}

let taxPolicy = createDefaultTaxPolicy();
let taxHistory = [];

const BASE_LAW_LIBRARY = [
    {
        key: "grain_subsidy",
        name: "Sussidi Agricoli",
        description: "Finanzia sementi e mulini: +produzione grano ma minori entrate fiscali dai contadini.",
        effects: {
            production: { grain: 1.25 },
            taxes: { peasants: -2 },
            factions: { peasants: 4, nobility: -2 }
        }
    },
    {
        key: "trade_charter",
        name: "Carta dei Mercanti",
        description: "Agevolazioni per i mercanti: aumenta beni di pregio e oro, ma l'artigianato subisce concorrenza.",
        effects: {
            production: { luxuries: 1.2, textiles: 0.95 },
            taxes: { merchants: 2, burghers: -1 },
            factions: { merchants: 5, burghers: -3 }
        }
    },
    {
        key: "conscription_edict",
        name: "Editto di Leva",
        description: "Arruola contadini e artigiani nella milizia. Più sicurezza, ma malcontento tra i campi.",
        effects: {
            production: { grain: 0.9 },
            military: { manpower: 1.15 },
            factions: { militia: 5, peasants: -4, burghers: -2 }
        }
    }
];

let customLaws = [];
let activeLaws = [];
let lastResourceSnapshot = null;
let lastResourceDelta = null;

const RESERVED_SAVE_SLOTS = ["autosave", "quick"];
const DEFAULT_PERSONALITY = { advisorTone:"saggio", courtMood:"prudente", notes:"" };
let personalitySettings = { ...DEFAULT_PERSONALITY };

function createDefaultResources() {
    return {
        wood: 40,
        stone: 20,
        iron: 10,
        copper: 5,
        gold: 50,
        herbs: 25,
        grain: 180,
        livestock: 80,
        textiles: 35,
        luxuries: 20,
        arcane: 15
    };
}

function createDefaultCounty() {
    return {
        desc: "",
        pop: 1200,
        gold: 500,
        food: 50,
        health: 50,
        happy: 50,
        security: 50,
        turn: 1,
        resources: createDefaultResources()
    };
}

let county = createDefaultCounty();
lastResourceSnapshot = cloneResourceBag(county.resources);
lastResourceDelta = createEmptyResourceDelta();
let industrySummary = null;

// Tracciamento transazioni economiche per il rapporto stagionale
let seasonalTransactions = {
    marketPurchases: 0,
    marketSales: 0,
    specialPurchases: 0,
    taxes: 0,
    maintenance: 0
};

/* ===================== TERRITORIO ===================== */
function createDefaultLand() {
    return {
        count: 25,
        nobility: 55,
        clergy: 15,
        commons: 5
    };
}

let landOwnership = createDefaultLand();

const TOTAL_LAND = 100;

/* ===================== POPOLAZIONE ===================== */
function createDefaultPopulation() {
    return {
        nobility: { count: 25, wealth: 500, resources: createEmptyResourceBag() },
        clergy: { count: 15, wealth: 200, resources: createEmptyResourceBag() },
        militia: { count: 60, wealth: 50, resources: createEmptyResourceBag() },
        peasants: { count: 900, wealth: 10, resources: createEmptyResourceBag() },
        burghers: { count: 120, wealth: 100, resources: createEmptyResourceBag() },
        merchants: { count: 80, wealth: 150, resources: createEmptyResourceBag() },
        mystics: { count: 10, wealth: 30, resources: createEmptyResourceBag() },
        outcasts: { count: 40, wealth: 5, resources: createEmptyResourceBag() }
    };
}

let populationGroups = createDefaultPopulation();

function adjustPopulation(group, delta, targetState = null) {
    const groups = targetState ? targetState.populationGroups : populationGroups;
    if (!groups[group]) groups[group] = 0;
    groups[group] = Math.max(0, groups[group] + delta);
    recomputePopulation(targetState);
}

function recomputePopulation(targetState = null) {
    const groups = targetState ? targetState.populationGroups : populationGroups;
    const targetCounty = targetState ? targetState.county : county;
    targetCounty.pop = Object.values(groups).reduce((sum, val) => sum + (val.count || val), 0);
}

/* ===================== SISTEMA DINASTIA ===================== */

// Helper per età leggibile
function getAgeLabel(age) {
    return Math.floor(age);
}

// 1. AVANZAMENTO ETÀ (Da chiamare dentro progressSeason)
/* ===================== CICLO DELLA VITA (EVENTI DINASTICI) ===================== */

// Funzione principale da chiamare dentro progressSeason()
function processLifeEvents() {
    // 1. Invecchiamento e Recupero
    advanceAgeAndRecovery(dynasty.ruler);
    if (dynasty.spouse) advanceAgeAndRecovery(dynasty.spouse);
    
    // Rimuovi eredi morti o processa invecchiamento
    if (dynasty.heirs.length > 0) {
        // Filter crea un nuovo array tenendo solo i vivi
        dynasty.heirs = dynasty.heirs.filter(heir => {
            advanceAgeAndRecovery(heir);
            // Se è morto durante l'invecchiamento (checkDeath chiamato dentro), lo rimuoviamo qui?
            // No, checkDeath gestisce la logica. Qui filtriamo se health <= 0 o flag 'dead'
            return !heir.isDead;
        });
    }

    // 2. Eventi Negativi (Malattia / Incidente)
    // Più bassa è la salute/sicurezza della contea, più alto il rischio
    const illnessRisk = Math.max(0.05, (100 - county.health) / 200); // 5% min, sale se health bassa
    const accidentRisk = Math.max(0.02, (100 - county.security) / 300); // 2% min, sale se security bassa

    // Tenta evento sul Conte
    rollLifeEvent(dynasty.ruler, illnessRisk, accidentRisk);

    // Tenta evento sul Consorte
    if (dynasty.spouse) rollLifeEvent(dynasty.spouse, illnessRisk, accidentRisk);

    // Tenta evento su UN figlio a caso (per non spammare)
    if (dynasty.heirs.length > 0) {
        const randomHeir = dynasty.heirs[Math.floor(Math.random() * dynasty.heirs.length)];
        rollLifeEvent(randomHeir, illnessRisk, accidentRisk);
    }

    // 3. Tentativo di Nascita (solo se c'è consorte)
    if (dynasty.spouse && !dynasty.ruler.isDead && !dynasty.spouse.isDead) {
        checkBirth();
    }

    // 4. Morte (Il Mietitore controlla tutti)
    // Nota: checkDeath viene chiamato dentro advanceAgeAndRecovery per naturale, 
    // ma chiamiamolo qui per eventi traumatici appena accaduti
    checkDeath(dynasty.ruler, "ruler");
    if (dynasty.spouse) checkDeath(dynasty.spouse, "spouse");
    dynasty.heirs.forEach(h => checkDeath(h, "heir"));

    updateDynastyUI();
}

// Gestisce invecchiamento e guarigione naturale
function advanceAgeAndRecovery(person) {
    person.age += 0.25;
    
    // Recupero salute se ha tratti negativi
    if (person.traits.includes("Malato")) {
        // Se la contea ha buona salute o ospedali, guarisce
        const cureChance = county.health > 60 ? 0.4 : 0.1; 
        if (Math.random() < cureChance) {
            removeTrait(person, "Malato");
            addMsg("system", `🌿 <strong>Guarigione:</strong> ${person.name} ha sconfitto la malattia.`);
        }
    }
    
    if (person.traits.includes("Ferito")) {
        const cureChance = 0.5; // Le ferite guariscono più facilmente
        if (Math.random() < cureChance) {
            removeTrait(person, "Ferito");
            addMsg("system", `🩹 <strong>Guarigione:</strong> Le ferite di ${person.name} si sono rimarginate.`);
        }
    }
}

// Tira i dadi per eventi sfortunati
function rollLifeEvent(person, illnessChance, accidentChance) {
    if (person.isDead) return;

    // Malattia
    if (!person.traits.includes("Malato") && Math.random() < illnessChance) {
        addTrait(person, "Malato");
        // Gravità dipende dall'età (bambini e anziani più a rischio)
        const severity = (person.age < 5 || person.age > 50) ? "grave" : "lieve";
        addMsg("system", `🤢 <strong>Malattia:</strong> ${person.name} si è ammalato (${severity}). La salute della contea influisce sulla guarigione.`);
    }

    // Incidente (Caccia, addestramento, gioco)
    else if (!person.traits.includes("Ferito") && Math.random() < accidentChance) {
        addTrait(person, "Ferito");
        let cause = "un incidente a cavallo";
        if (person.age < 10) cause = "una caduta giocando";
        else if (person.age > 60) cause = "una brutta caduta dalle scale";
        
        addMsg("system", `🤕 <strong>Incidente:</strong> ${person.name} ha subito ${cause}.`);
    }
}

// Gestisce la Nascita
function checkBirth() {
    // Età fertile approssimativa
    if (dynasty.ruler.age > 60 || dynasty.spouse.age > 45) return;
    if (dynasty.ruler.age < 16 || dynasty.spouse.age < 16) return;

    let chance = 0.05; // 5% base a stagione
    if (county.happy > 70) chance += 0.05; // Popolo felice = atmosfera migliore?
    if (county.food > 80) chance += 0.02; // Ben nutriti

    if (Math.random() < chance) {
        const isMale = Math.random() > 0.5;
        const name = isMale ? getRandomMaleName() : getRandomFemaleName();
        
        const child = {
            name: name,
            age: 0,
            gender: isMale ? "M" : "F",
            traits: [], // Nasce sano
            health: 100, // Valore salute interno (invisibile, usato per calcoli morte)
            isDead: false,
            maxAge: 70 + Math.floor(Math.random() * 20)
        };
        
        // Possibile complicazione parto (mortalità infantile medievale)
        if (Math.random() < 0.1) {
            addTrait(child, "Debole");
            addMsg("system", `⚠️ Il piccolo ${name} è nato, ma è molto debole.`);
        }

        dynasty.heirs.push(child);
        addMsg("system", `👶 <strong>Lieto Evento:</strong> È nato ${name}! La dinastia cresce.`);
        
        // Bonus felicità
        county.happy = Math.min(100, county.happy + 5);
        updateUI();
    }
}

// Il Tristo Mietitore
function checkDeath(person, role) {
    if (person.isDead) return;

    let deathChance = 0;

    // 1. Fattore Età (Curva esponenziale dopo i 50)
    if (person.age > 50) deathChance += 0.01;
    if (person.age > 60) deathChance += 0.05;
    if (person.age > person.maxAge) deathChance += 0.50; // Il tempo è scaduto

    // 2. Fattore Salute (Traits)
    if (person.traits.includes("Malato")) deathChance += 0.15; // Malattia è pericolosa
    if (person.traits.includes("Ferito")) deathChance += 0.05;
    if (person.traits.includes("Debole")) deathChance += 0.05;

    // 3. Fattore Ambiente
    if (county.food < 10) deathChance += 0.05; // Fame

    // TIRO SALVEZZA
    if (Math.random() < deathChance) {
        person.isDead = true;
        handleDeathEffect(person, role);
    }
}

function handleDeathEffect(person, role) {
    const name = person.name;
    
    // Effetti scenici
    if (role === "ruler") {
        handleSuccession(); // Logica successione esistente
    } 
    else if (role === "spouse") {
        addMsg("system", `⚰️ <strong>Lutto Reale:</strong> Il consorte ${name} è deceduto. La corte è in lutto.`);
        dynasty.spouse = null; // Rimuovi consorte
        county.happy = Math.max(0, county.happy - 15);
    } 
    else if (role === "heir") {
        addMsg("system", `⚰️ <strong>Tragedia:</strong> Il giovane ${name} è morto prematuramente.`);
        // La rimozione dall'array avviene nel filtro all'inizio di processLifeEvents
        county.happy = Math.max(0, county.happy - 10);
    }
    
    updateUI();
}

// Helpers per i tratti
function addTrait(person, trait) {
    if (!person.traits) person.traits = [];
    if (!person.traits.includes(trait)) person.traits.push(trait);
}

function removeTrait(person, trait) {
    if (!person.traits) return;
    person.traits = person.traits.filter(t => t !== trait);
}

// 2. CONTROLLO MORTE
function checkRulerDeath() {
    const r = dynasty.ruler;
    const age = r.age;
    
    // Fattore di rischio base
    let deathChance = 0;

    // Vecchiaia
    if (age > 60) deathChance += 0.02; // 2% a stagione
    if (age > r.maxAge) deathChance += 0.50; // Rischio altissimo sopra maxAge

    // Salute
    if (county.health < 30) deathChance += 0.05;
    if (county.food < 10) deathChance += 0.10;

    if (Math.random() < deathChance) {
        handleSuccession();
    }
}

// 3. SUCCESSIONE O GAME OVER
function handleSuccession() {
    const deadRulerName = dynasty.ruler.name;
    
    // Cerca erede maggiorenne (o il più grande)
    const heir = dynasty.heirs.length > 0 ? dynasty.heirs[0] : null;

    if (heir) {
        // Successione riuscita
        alert(`👑 IL RE È MORTO, LUNGA VITA AL RE!\n\n${deadRulerName} è deceduto. Ora governi come ${heir.name}.`);
        addMsg("system", `💀 <b>LUTTO REALE:</b> ${deadRulerName} è morto. ${heir.name} ascende al trono.`);
        
        // Passaggio di consegne
        dynasty.ruler = {
            name: heir.name,
            age: heir.age,
            maxAge: 70 + Math.floor(Math.random() * 20),
            health: 100,
            traits: heir.traits || ["Erede"],
            isDead: false
        };
        
        // Resetta famiglia (il nuovo conte non è sposato con sua madre/padre!)
        dynasty.spouse = null; 
        dynasty.heirs = []; // I fratelli diventano cortigiani (semplificazione)
        
        updateDynastyUI();
        updateUI(); // Aggiorna nome conte
    } else {
        // GAME OVER
        document.getElementById("gameover-reason").innerText = `${deadRulerName} è morto all'età di ${Math.floor(dynasty.ruler.age)} anni senza lasciare eredi. La casata è estinta.`;
        document.getElementById("modal-gameover").classList.add("active");
    }
}

// 4. MATRIMONIO
function openMarriageMarket() {
    const modal = document.getElementById("modal-marriage");
    const grid = document.getElementById("marriage-candidates");
    grid.innerHTML = "";

    if (!activeSuitorsList || activeSuitorsList.length === 0) {
        activeSuitorsList = generateSuitors(); // Genera solo se non esiste
    }

    activeSuitorsList.forEach((suitor, index) => {
        // Inizializza chat temporanea per questo suitor
        const chatKey = `suitor_${index}`;
        privateChats[chatKey] = []; 

        const div = document.createElement("div");
        div.className = "candidate-card";
        div.innerHTML = `
            <strong>${suitor.name}</strong>
            <span class="candidate-origin">${suitor.originLabel}</span>
            <div>Età: ${suitor.age}</div>
            <div>Rapporto: ${suitor.relation}/100</div>
            <div class="candidate-bonus">${suitor.bonusDesc}</div>
            <div style="display:flex; gap:10px; margin-top:10px;">
                <button class="btn-sec" onclick="openPrivateChat('suitor_${index}')">💬 Parla</button>
                <button class="btn-sec" onclick="giveGiftToSuitor(${index})">🎁 Regala</button>
                <button class="btn-main" onclick="marrySuitorIndex(${index})">💍 Sposa</button>
            </div>
        `;
        grid.appendChild(div);
    });

    modal.classList.add("active");
}

function generateSuitors() {
    const suitors = [];
    // Candidato Nobile Locale
    suitors.push({
        name: "Lady Elara di Montferrand",
        age: 18 + Math.floor(Math.random()*10),
        origin: "nobility",
        originLabel: "Nobiltà Locale",
        bonusDesc: "+15 Lealtà Nobiltà, +100 Oro",
        effects: { faction: "nobility", gold: 100 },
        relation: 50
    });
    // Candidato Estero (Auvrey)
    if (neighboringCounties.find(c=>c.key==='auvrey').relations > 30) {
        suitors.push({
            name: "Contessina Isabella d'Auvrey",
            age: 20 + Math.floor(Math.random()*8),
            origin: "auvrey",
            originLabel: "Contea di Auvrey",
            bonusDesc: "Alleanza con Auvrey, Prezzi Mercato ridotti",
            effects: { relation: "auvrey", trade: true },
            relation: 50
        });
    }
    // Candidato Mercante
    suitors.push({
        name: "Ginevra la Ricca",
        age: 25 + Math.floor(Math.random()*15),
        origin: "merchants",
        originLabel: "Gilda Mercanti",
        bonusDesc: "+300 Oro immediato",
        effects: { gold: 300, faction: "merchants" },
        relation: 50
    });

    return suitors;
}

function marrySuitorIndex(index) {
    const suitor = activeSuitorsList[index];
    if(!suitor) return;
    
    if (suitor.relation < 90) {
        addMsg("system", `💔 Il rapporto con ${suitor.name} non è abbastanza alto (${suitor.relation}/100). Continua a parlare e regalare per migliorare il legame.`);
        return;
    }
    
    // Trasferisci la chat del suitor nella chat dello spouse (per mantenere lo storico!)
    const oldChatKey = `suitor_${index}`;
    if (privateChats[oldChatKey]) {
        privateChats['spouse'] = [...privateChats[oldChatKey]];
        // Aggiungi messaggio di sistema
        privateChats['spouse'].push({from:'system', text:'Il matrimonio è stato celebrato.'});
    }

    marrySuitor(suitor); // Chiama la funzione logica originale
}

function marrySuitor(suitor) {
    dynasty.spouse = suitor;
    dynasty.spouse.maxAge = 70 + Math.floor(Math.random() * 20);
    dynasty.spouse.traits = dynasty.spouse.traits || [];
    dynasty.spouse.isDead = false;
    closeMarriageModal();
    
    // Applica effetti
    if (suitor.effects.gold) county.gold += suitor.effects.gold;
    if (suitor.effects.faction) factions[suitor.effects.faction] += 15;
    if (suitor.effects.relation) {
        const n = neighboringCounties.find(c=>c.key === suitor.effects.relation);
        if(n) { n.relations += 30; n.tradeAgreement = true; }
    }

    addMsg("system", `💍 <b>MATRIMONIO REALE:</b> Il Conte ha sposato ${suitor.name}!`);
    updateDynastyUI();
    updateUI();
}

function closeMarriageModal() {
    document.getElementById("modal-marriage").classList.remove("active");
}

function giveGiftToSuitor(index) {
    const suitor = activeSuitorsList[index];
    if (!suitor) return;
    
    const giftCost = 50;
    if (county.gold < giftCost) {
        addMsg("system", "Non hai abbastanza oro per un regalo adeguato.");
        return;
    }
    
    county.gold -= giftCost;
    const relationGain = 10 + Math.floor(Math.random() * 11); // 10-20
    suitor.relation = Math.min(100, suitor.relation + relationGain);
    
    addMsg("system", `🎁 Hai regalato un dono prezioso a ${suitor.name}. Rapporto aumentato di ${relationGain} punti!`);
    updateUI();
    // Rileggi il modal per aggiornare il rapporto
    openMarriageMarket();
}

// 5. NASCITE
function checkBirth() {
    if (!dynasty.spouse) return;
    
    // Probabilità: più alta se entrambi giovani
    let chance = 0.08; // 8% a stagione base
    if (dynasty.ruler.age < 40 && dynasty.spouse.age < 35) chance += 0.10;
    
    if (Math.random() < chance) {
        const isMale = Math.random() > 0.5;
        const name = isMale ? getRandomMaleName() : getRandomFemaleName();
        
        const child = {
            name: name,
            age: 0,
            gender: isMale ? "M" : "F",
            traits: []
        };
        
        dynasty.heirs.push(child);
        addMsg("system", `👶 <b>LIETO EVENTO:</b> È nato un erede! Benvenuto al piccolo ${name}.`);
        
        // Se è il primo figlio, aumenta stabilità
        if (dynasty.heirs.length === 1) {
            addMsg("system", "La linea di successione è assicurata. Stabilità +10.");
        }
        
        updateDynastyUI();
    }
}

function getRandomMaleName() {
    const names = ["Edward", "William", "Henry", "Richard", "Baldwin", "Godfrey", "Charles"];
    return names[Math.floor(Math.random() * names.length)];
}

function getRandomFemaleName() {
    const names = ["Eleanor", "Matilda", "Isabella", "Adela", "Margaret", "Beatrice"];
    return names[Math.floor(Math.random() * names.length)];
}

// 6. INTERFACCIA UTENTE DINASTIA
function updateDynastyUI() {
    // Ruler
    const r = dynasty.ruler;
    let rulerStatus = "";
    if (r.traits.includes("Malato")) rulerStatus += "🤢 ";
    if (r.traits.includes("Ferito")) rulerStatus += "🤕 ";
    
    document.getElementById("dynasty-ruler-name").innerHTML = `${rulerStatus} ${r.name || heroName}`;
    document.getElementById("dynasty-ruler-age").innerText = Math.floor(r.age);
    document.getElementById("dynasty-ruler-health").innerText = county.health > 70 ? "Eccellente" : county.health > 40 ? "Buona" : "Cagionevole";
    
    // Spouse
    const spouseContainer = document.getElementById("spouse-container");
    if (dynasty.spouse) {
        let sStatus = "";
        if (dynasty.spouse.traits && dynasty.spouse.traits.includes("Malato")) sStatus += "🤢 ";
        
        spouseContainer.innerHTML = `
            <div class="person-card-ui spouse">
                <strong>${sStatus}${dynasty.spouse.name}</strong>
                <div>Età: ${Math.floor(dynasty.spouse.age)}</div>
                <div style="font-size:0.8em; color:#aaa;">${dynasty.spouse.originLabel}</div>
                <div style="font-size:0.8em; color:#ff7c7c;">${dynasty.spouse.traits ? dynasty.spouse.traits.join(", ") : ""}</div>
            </div>
        `;
    } else {
        spouseContainer.innerHTML = `
            <div class="dynasty-empty-slot">
                <p>Nessun consorte.</p>
                <button class="btn-main" onclick="openMarriageMarket()">Cerca Pretendenti</button>
            </div>
        `;
    }

    // Heirs
    const heirsList = document.getElementById("heirs-list");
    heirsList.innerHTML = "";
    if (dynasty.heirs.length === 0) {
        heirsList.innerHTML = `<p class="text-soft" style="grid-column: 1/-1; text-align:center;">Nessun erede.</p>`;
    } else {
        dynasty.heirs.forEach(h => {
            let hStatus = "";
            if (h.traits.includes("Malato")) hStatus += "🤢 ";
            if (h.traits.includes("Ferito")) hStatus += "🤕 ";
            if (h.traits.includes("Debole")) hStatus += "🍃 ";

            const div = document.createElement("div");
            div.className = "person-card-ui heir";
            div.innerHTML = `
                <strong>${hStatus}${h.name}</strong>
                <div>Età: ${Math.floor(h.age)}</div>
                <div style="font-size:0.8em;">${h.traits.join(", ") || "Sano"}</div>
            `;
            heirsList.appendChild(div);
        });
    }

    // --- AGGIORNAMENTO BOTTONI CHAT FAMIGLIA ---
    const familySection = document.getElementById("family-chat-buttons");
    const familySelector = document.getElementById("family-selector");
    
    if (!familySection || !familySelector) return;

    let hasFamily = false;
    let html = "";

    // Bottone Coniuge
    if (dynasty.spouse) {
        hasFamily = true;
        // Crea un ID univoco per la chat, es. 'spouse'
        html += `<button class="btn-sec" style="border-color:#d4af37" onclick="openPrivateChat('spouse')">❤️ ${dynasty.spouse.name} (Consorte)</button>`;
        
        // Assicura che esista l'array della chat in memoria
        if (!privateChats['spouse']) privateChats['spouse'] = [];
    }

    // Bottoni Eredi
    dynasty.heirs.forEach((heir, index) => {
        hasFamily = true;
        const chatKey = `heir_${index}`;
        html += `<button class="btn-sec" style="border-color:#6ada91" onclick="openPrivateChat('${chatKey}')">👶 ${heir.name} (Erede)</button>`;
        
        // Inizializza chat memoria
        if (!privateChats[chatKey]) privateChats[chatKey] = [];
    });

    familySelector.innerHTML = html;
    familySection.style.display = hasFamily ? "block" : "none";
}

// 7. EVENTI BAMBINI (Educazione)
function triggerChildEvent(child) {
    // Semplice scelta tramite prompt o modale (qui uso alert/prompt per semplicità, 
    // meglio sarebbe integrarlo nella chat azioni)
    
    // Per integrazione pulita, lo mandiamo come messaggio in chat azioni
    addMsg("system", `🎓 L'erede ${child.name} ha raggiunto i ${child.age} anni. È tempo di scegliere la sua educazione.`);
    
    // Aggiungiamo trait casuale per ora, in futuro collegare a bottoni azione
    const newTrait = Math.random() > 0.5 ? "Guerriero" : "Erudito";
    child.traits.push(newTrait);
}

/* ===================== FAZIONI ===================== */
const factionOrder = [
    "nobility","clergy","militia","peasants",
    "burghers","merchants","mystics","outcasts"
];

function createDefaultFactions() {
    return {
        nobility: 50,
        clergy: 50,
        militia: 50,
        peasants: 50,
        burghers: 50,
        merchants: 50,
        mystics: 50,
        outcasts: 50
    };
}

let factions = createDefaultFactions();

/* ===================== CONTEE VICINE ===================== */
function createDefaultNeighbors() {
    return [
        { 
            key:"auvrey", 
            name:"Contea di Auvrey", 
            power:65, 
            wealth:50, 
            relations:40, 
            aggression:20, 
            land:30,
            description: "Una contea ambiziosa guidata dal giovane Conte Emeric, che cerca di espandere i suoi confini attraverso alleanze e conquiste.",
            goals: ["Espandere territorio", "Formare alleanze matrimoniali", "Controllare rotte commerciali"],
            personality: "Ambizioso e calcolatore, ma impulsivo in battaglia.",
            specialResource: "textiles",
            events: []
        },
        { 
            key:"falken", 
            name:"Baronia di Falken", 
            power:40, 
            wealth:30, 
            relations:70, 
            aggression:10, 
            land:18,
            description: "Una baronia montuosa difesa dal Barone Lothar, noto per le sue miniere e la sua neutralità.",
            goals: ["Mantenere indipendenza", "Sviluppare miniere", "Proteggere confini"],
            personality: "Difensivo e pragmatico, preferisce la diplomazia alla guerra.",
            specialResource: "iron",
            events: []
        }
    ];
}

let neighboringCounties = createDefaultNeighbors();

/* ===================== CONSIGLIERE ===================== */
let advisor = { name:"", personality:"" };

/* ===================== CHAT PRIVATE ===================== */
let activePrivateChat = null;
function createDefaultPrivateChats() {
    return {
        nobility:[], clergy:[], militia:[], peasants:[],
        burghers:[], merchants:[], mystics:[], outcasts:[],
        auvrey:[], falken:[]
    };
}

let privateChats = createDefaultPrivateChats();

function ensureWorldSystems(targetState = null) {
    if (targetState) {
        if (!targetState.worldTime) targetState.worldTime = createDefaultWorldTime();
        if (!targetState.taxPolicy) targetState.taxPolicy = createDefaultTaxPolicy();
        if (!Array.isArray(targetState.activeLaws)) targetState.activeLaws = [];
        if (!Array.isArray(targetState.taxHistory)) targetState.taxHistory = [];
        if (!targetState.lastResourceSnapshot) targetState.lastResourceSnapshot = captureResourceSnapshot(targetState);
        if (!targetState.lastResourceDelta) targetState.lastResourceDelta = createEmptyResourceDelta();
        if (!Array.isArray(targetState.customLaws)) targetState.customLaws = [];
        if (!targetState.industrySummary) targetState.industrySummary = summarizeIndustry(targetState.structures, targetState.settlements);
        if (targetState.county && targetState.county.security === undefined) targetState.county.security = 50;
        return;
    }

    if (!worldTime) worldTime = createDefaultWorldTime();
    if (!taxPolicy) taxPolicy = createDefaultTaxPolicy();
    if (!Array.isArray(activeLaws)) activeLaws = [];
    if (!Array.isArray(taxHistory)) taxHistory = [];
    if (!lastResourceSnapshot) lastResourceSnapshot = captureResourceSnapshot();
    if (!lastResourceDelta) lastResourceDelta = createEmptyResourceDelta();
    if (!Array.isArray(customLaws)) customLaws = [];
    if (!industrySummary) industrySummary = summarizeIndustry(structures, settlements);
    if (county && county.security === undefined) county.security = 50;
}

const FACTION_EFFECT_DESCRIPTIONS = {
    nobility: { bonus:"Sostengono opere e portano oro extra.", malus:"Pretendono privilegi, drenano le casse." },
    clergy: { bonus:"Intercedono per la salute pubblica.", malus:"Condannano il conte, calano devozione." },
    militia: { bonus:"Sorvegliano le strade, meno disordini.", malus:"Disertano e pretendono paga." },
    peasants: { bonus:"Coltivano con zelo, raccolti floridi.", malus:"Scioperano nei campi, raccolti scarsi." },
    burghers: { bonus:"Tessuti di qualità, stabilità urbana.", malus:"Artigiani in protesta, produzione lenta." },
    merchants: { bonus:"Più lussi e oro nei mercati.", malus:"Fuggono i capitali, calano gli scambi." },
    mystics: { bonus:"Rinforzano l'arcano e curano.", malus:"Diffondono superstizioni destabilizzanti." },
    outcasts: { bonus:"Meno crimini e più informatori.", malus:"Disordini e sabotaggi frequenti." }
};

const RESOURCE_FACTION_MAP = {
    grain: { faction:"peasants", scale:0.3 },
    livestock: { faction:"peasants", scale:0.25 },
    textiles: { faction:"burghers", scale:0.25 },
    luxuries: { faction:"merchants", scale:0.3 },
    arcane: { faction:"mystics", scale:0.35 },
    herbs: { faction:"clergy", scale:0.2 }
};

const ASSET_RULES = [
    {
        key:"housing_poor",
        label:"Case Povere",
        getCount: summary => (summary.housing && summary.housing.poor) || 0,
        consume:{ grain:4, wood:0.4 }
    },
    {
        key:"housing_middle",
        label:"Case Medie",
        getCount: summary => (summary.housing && summary.housing.middle) || 0,
        consume:{ grain:3, livestock:0.8, textiles:0.5 },
        gold:1.5
    },
    {
        key:"housing_noble",
        label:"Residenze Nobili",
        getCount: summary => (summary.housing && summary.housing.noble) || 0,
        consume:{ grain:2, livestock:1.5, luxuries:1.2 },
        gold:3
    },
    {
        key:"farms",
        label:"Campi Coltivati",
        getCount: summary => summary.farms || 0,
        produce:{ grain:32 },
        consume:{ wood:0.6 }
    },
    {
        key:"ranches",
        label:"Allevamenti",
        getCount: summary => summary.ranches || 0,
        produce:{ livestock:11 },
        consume:{ grain:7, herbs:0.5 }
    },
    {
        key:"shops",
        label:"Botteghe",
        getCount: summary => summary.shops || 0,
        produce:{ textiles:6, luxuries:1.5 },
        consume:{ grain:1.8, iron:0.6, copper:0.4 },
        gold:4
    },
    {
        key:"churches",
        label:"Chiese",
        getCount: summary => summary.churches || 0,
        produce:{ herbs:2 },
        consume:{ grain:0.8 },
        gold:2
    }
];

function getSeason(timeRef = worldTime) {
    const ref = timeRef || worldTime;
    if (!ref) return SEASON_CYCLE[0];
    return SEASON_CYCLE[(ref.seasonIndex || 0) % SEASON_CYCLE.length];
}

function advanceSeason(targetState = null, options = {}) {
    const timeRef = targetState ? targetState.worldTime : worldTime;
    if (!timeRef) return;
    timeRef.seasonIndex = ((timeRef.seasonIndex || 0) + 1) % SEASON_CYCLE.length;
    if (timeRef.seasonIndex === 0) timeRef.year = (timeRef.year || 1325) + 1;
    applySeasonalMorale(timeRef, targetState);
    
    // Sistema di popolazione dinamica
    if (!targetState) {
        processDemographicEvents();
        processCrimeAndStability();
        processEmigration();
        processSocialMobility();
        updateCategoryWealth();
        
        // Aggiorna domanda/offerta mercato
        const marketDynamics = calculateMarketDemand();
        // Qui possiamo usare marketDynamics per influenzare i prezzi
    }
    
    if (!targetState && !options.silent) {
        const season = getSeason(timeRef);
        addMsg("system", `⏳ Inizia ${season.label}. ${season.description}`);
        updateSeasonUI();
    }
}

function applySeasonalMorale(timeRef, targetState = null) {
    const season = getSeason(timeRef);
    if (!season.morale) return;
    const factionsRef = targetState ? targetState.factions : factions;
    Object.entries(season.morale).forEach(([key, delta]) => {
        factionsRef[key] = clamp((factionsRef[key] || 50) + delta);
    });
}

function updateSeasonUI() {
    const season = getSeason();
    const yearEl = document.getElementById("season-year");
    const nameEl = document.getElementById("season-name");
    const textEl = document.getElementById("season-effects-text");
    if (yearEl) yearEl.innerText = worldTime.year;
    if (nameEl) nameEl.innerText = season.label;
    if (textEl) textEl.innerText = season.description;
}

function getLawLibrary() {
    return [...BASE_LAW_LIBRARY, ...customLaws];
}

function getActiveLawKeys(targetState = null) {
    if (targetState && Array.isArray(targetState.activeLaws)) return targetState.activeLaws;
    return activeLaws;
}

function isLawActive(key, targetState = null) {
    return getActiveLawKeys(targetState).includes(key);
}

function getLawDefinition(key) {
    return getLawLibrary().find(l => l.key === key);
}

function toggleLaw(key) {
    const idx = activeLaws.indexOf(key);
    if (idx >= 0) {
        activeLaws.splice(idx, 1);
        const def = getLawDefinition(key);
        if (def) applyLawFactionShift(def, -1);
    } else {
        activeLaws.push(key);
        const def = getLawDefinition(key);
        if (def) applyLawFactionShift(def, 1);
    }
    renderLawList();
    updateUI();
}

function applyLawFactionShift(law, direction = 1, targetState = null) {
    if (!law.effects || !law.effects.factions) return;
    const factionsRef = targetState ? targetState.factions : factions;
    Object.entries(law.effects.factions).forEach(([key, delta]) => {
        factionsRef[key] = clamp((factionsRef[key] || 50) + delta * direction);
    });
}

function renderLawList() {
    const list = document.getElementById("law-list");
    if (!list) return;
    list.innerHTML = "";
    const library = getLawLibrary();
    library.forEach(law => {
        const card = document.createElement("div");
        card.className = "law-card";
        const title = document.createElement("h4");
        title.innerText = law.name;
        const desc = document.createElement("p");
        desc.innerText = law.description;
        const active = activeLaws.includes(law.key);
        const btn = document.createElement("button");
        btn.className = active ? "btn-main" : "btn-sec";
        btn.innerText = active ? "Abroga" : "Promulga";
        btn.addEventListener("click", () => toggleLaw(law.key));
        card.append(title, desc, btn);
        list.appendChild(card);
    });
    if (!library.length) {
        list.innerHTML = '<div class="law-card">Nessuna legge disponibile.</div>';
    }
}

function ownedStructures(list = [], owner = "count") {
    if (!Array.isArray(list)) return [];
    return list.filter(item => (item.owner || "count") === owner);
}

function summarizeIndustry(structuresRef = structures, settlementsRef = settlements, stateRef = null) {
    const landRef = stateRef ? stateRef.landOwnership : landOwnership;
    const popRef = stateRef ? stateRef.populationGroups : populationGroups;
    const summary = {
        housing: {
            poor: Math.max(0, Math.floor((((popRef.peasants || 0) + (popRef.outcasts || 0)) / 80))),
            middle: Math.max(0, Math.floor((((popRef.burghers || 0) + (popRef.merchants || 0)) / 120))),
            noble: Math.max(0, Math.floor(((popRef.nobility || 0) / 60)))
        },
        shops: Math.max(0, Math.floor((((popRef.burghers || 0) + (popRef.merchants || 0)) / 90))),
        churches: Math.max(0, Math.floor((((popRef.clergy || 0) + (popRef.mystics || 0)) / 30))),
        farms: Math.max(0, Math.floor(((landRef.count || 0) / 4))),
        ranches: Math.max(0, Math.floor(((landRef.count || 0) / 7))),
        mines: ownedStructures(structuresRef?.mines).length,
        sawmills: ownedStructures(structuresRef?.sawmills).length,
        quarries: ownedStructures(structuresRef?.quarries).length,
        monasteries: ownedStructures(structuresRef?.monasteries).length,
        settlements: (settlementsRef || []).length
    };
    return summary;
}

function updateIndustrySummary(targetState = null) {
    if (targetState) {
        targetState.industrySummary = summarizeIndustry(targetState.structures, targetState.settlements, targetState);
        if (targetState._cachedAssetFlows) delete targetState._cachedAssetFlows;
        return targetState.industrySummary;
    }
    industrySummary = summarizeIndustry();
    latestAssetFlows = null;
    return industrySummary;
}

function getIndustrySummary(targetState = null) {
    if (targetState) {
        if (!targetState.industrySummary) return updateIndustrySummary(targetState);
        return targetState.industrySummary;
    }
    if (!industrySummary) return updateIndustrySummary();
    return industrySummary;
}

function calculateAssetFlows(summary, stateRef = null) {
    const flows = { production:{}, consumption:{}, goldCost:0, detail:[] };
    if (!summary) return flows;
    ASSET_RULES.forEach(rule => {
        const count = Math.max(0, Math.round(rule.getCount(summary)));
        if (!count) return;
        const entry = { key:rule.key, label:rule.label, count, production:{}, consumption:{}, gold:0 };
        if (rule.produce) {
            Object.entries(rule.produce).forEach(([res, value]) => {
                const amount = Math.max(0, Math.round(value * count));
                if (!amount) return;
                entry.production[res] = amount;
                flows.production[res] = (flows.production[res] || 0) + amount;
            });
        }
        if (rule.consume) {
            Object.entries(rule.consume).forEach(([res, value]) => {
                const amount = Math.max(0, Math.round(value * count));
                if (!amount) return;
                entry.consumption[res] = amount;
                flows.consumption[res] = (flows.consumption[res] || 0) + amount;
            });
        }
        if (rule.gold) {
            entry.gold = Math.max(0, Math.round(rule.gold * count));
            flows.goldCost += entry.gold;
        }
        flows.detail.push(entry);
    });
    if (stateRef) {
        stateRef._cachedAssetFlows = flows;
    } else {
        latestAssetFlows = flows;
    }
    return flows;
}

function getCachedAssetFlows(stateRef = null) {
    if (stateRef && stateRef._cachedAssetFlows) return stateRef._cachedAssetFlows;
    return latestAssetFlows;
}

function formatFlowMap(map) {
    const entries = Object.entries(map || {}).filter(([, val]) => val && val !== 0);
    if (!entries.length) return "—";
    return entries.map(([key, val]) => `${resourceLabels[key] || key}:${val > 0 ? '+' : ''}${val}`).join(", ");
}

function summarizeStructureOutput(list = []) {
    const totals = {};
    list.forEach(item => {
        Object.entries(item.production || {}).forEach(([key, value]) => {
            const actual = Math.max(0, Math.floor(value * (item.condition || 100) / 100));
            totals[key] = (totals[key] || 0) + actual;
        });
    });
    return totals;
}

function updateAssetSummaryUI(summaryRef = null) {
    const container = document.getElementById("asset-summary");
    if (!container) return;
    const summary = summaryRef || getIndustrySummary();
    if (!summary) {
        container.innerHTML = '<div class="asset-card">Dati non disponibili.</div>';
        return;
    }
    const flows = getCachedAssetFlows() || calculateAssetFlows(summary);
    const cards = [];
    (flows.detail || []).forEach(entry => {
        cards.push(`
            <div class="asset-card">
                <h4>${entry.label}</h4>
                <div>Strutture controllate: ${entry.count}</div>
                <div class="asset-flow">Produzione: ${formatFlowMap(entry.production)}</div>
                <div class="asset-flow">Consumi: ${formatFlowMap(entry.consumption)}</div>
                ${entry.gold ? `<div class="asset-flow">Oro necessario: ${entry.gold}</div>` : ""}
            </div>
        `);
    });

    const structuralSets = [
        { key:"mines", label:"Miniere", list: ownedStructures(structures.mines) },
        { key:"sawmills", label:"Segherie", list: ownedStructures(structures.sawmills) },
        { key:"quarries", label:"Cave", list: ownedStructures(structures.quarries) },
        { key:"monasteries", label:"Monasteri", list: ownedStructures(structures.monasteries) }
    ];

    structuralSets.forEach(item => {
        const count = item.list.length;
        if (!count) return;
        const output = summarizeStructureOutput(item.list);
        cards.push(`
            <div class="asset-card">
                <h4>${item.label}</h4>
                <div>Impianti attivi: ${count}</div>
                <div class="asset-flow">Produzione attesa: ${formatFlowMap(output)}</div>
                <div class="asset-flow">Consumi: richieste di personale e manutenzione</div>
            </div>
        `);
    });

    if (!cards.length) {
        container.innerHTML = '<div class="asset-card">Nessun asset controllato al momento.</div>';
    } else {
        container.innerHTML = cards.join("");
    }
}

function calculateLogisticNeeds(stateRef = null) {
    const needs = [];
    const popRef = stateRef ? stateRef.populationGroups : populationGroups;
    const militia = (popRef && popRef.militia) ? popRef.militia : 0;
    if (militia > 0) {
        needs.push({ resource:"iron", amount: Math.ceil(militia * 0.08), tag:"military" });
        needs.push({ resource:"wood", amount: Math.ceil(militia * 0.04), tag:"military" });
        needs.push({ resource:"textiles", amount: Math.ceil(militia * 0.02), tag:"military" });
    }

    const buildingList = stateRef ? (stateRef.buildings || []) : buildings;
    if (Array.isArray(buildingList)) {
        const activeSites = buildingList.filter(b => b.stage === "building").length;
        if (activeSites > 0) {
            needs.push({ resource:"wood", amount: activeSites * 2, tag:"construction" });
            needs.push({ resource:"stone", amount: activeSites * 2, tag:"construction" });
            needs.push({ resource:"iron", amount: activeSites, tag:"construction" });
        }
    }

    return needs;
}

function delayConstructionProjects(targetState = null, extraTurns = 1) {
    const list = targetState ? (targetState.buildings || []) : buildings;
    if (!Array.isArray(list) || !extraTurns) return;
    list.forEach(site => {
        if (site.stage === "building") site.turns_left += extraTurns;
    });
}

function applyLogisticConsequences(needs, deficits, stateRef = null) {
    const impact = { military:false, construction:false };
    if (!needs || !needs.length) return impact;
    const tags = new Set();
    needs.forEach(entry => {
        if (deficits[entry.resource]) tags.add(entry.tag);
    });

    const factionsRef = stateRef ? stateRef.factions : factions;
    const countyRef = stateRef ? stateRef.county : county;

    if (tags.has("military")) {
        impact.military = true;
        factionsRef.militia = clamp((factionsRef.militia || 50) - 4);
        factionsRef.nobility = clamp((factionsRef.nobility || 50) - 1);
        countyRef.health = clamp(countyRef.health - 1);
    }

    if (tags.has("construction")) {
        impact.construction = true;
        delayConstructionProjects(stateRef, 1);
    }

    return impact;
}

const DEFICIT_FACTION_MAP = {
    grain: ["peasants"],
    livestock: ["peasants"],
    wood: ["burghers", "peasants"],
    stone: ["burghers"],
    iron: ["militia", "burghers"],
    copper: ["militia", "burghers"],
    textiles: ["burghers"],
    luxuries: ["nobility", "merchants"],
    herbs: ["clergy", "mystics"],
    arcane: ["mystics", "clergy"],
    gold: ["merchants", "nobility"]
};

function buildFactionDeficitMessage(factionKey, resourceKey, amount) {
    const label = resourceLabels[resourceKey] || resourceKey;
    switch(factionKey) {
        case "peasants":
            return `I villaggi non vedono abbastanza ${label}. Senza scorte rischiamo rivolte nei campi.`;
        case "burghers":
            return `Le botteghe restano inattive: servono ${label} per lavorare e pagare le tasse.`;
        case "militia":
            return `Gli arsenali sono vuoti di ${label}; come possiamo difendere la contea?`;
        case "merchants":
            return `I mercati perdono credito senza ${label}. Dobbiamo riaprire i traffici.`;
        case "nobility":
            return `Le casate considerano offensivo il deficit di ${label}. Pretendono attenzione immediata.`;
        case "clergy":
            return `I riti richiedono ${label}; il popolo ha bisogno della nostra guida spirituale.`;
        case "mystics":
            return `Le nostre arti languono senza ${label}. Il regno perderà protezione arcana.`;
        default:
            return `${factionLabel(factionKey)} avverte la mancanza di ${label}.`;
    }
}

function triggerFactionInterjections(context = {}) {
    const messages = [];
    const deficits = context.economy?.deficits || {};
    Object.entries(deficits).forEach(([resourceKey, amount]) => {
        const factionTargets = DEFICIT_FACTION_MAP[resourceKey];
        if (!factionTargets) return;
        factionTargets.forEach(key => {
            const text = buildFactionDeficitMessage(key, resourceKey, amount);
            if (text) messages.push({ key, text, priority: 3 });
        });
    });

    if (context.economy?.logisticImpact?.military) {
        messages.push({
            key: "militia",
            text: "Senza ferrivecchi e razioni la guardia non può reggere un assedio.",
            priority: 4
        });
    }
    if (context.economy?.logisticImpact?.construction) {
        messages.push({
            key: "burghers",
            text: "I cantieri languono: spedite legname e pietra o le maestranze sciopereranno.",
            priority: 3
        });
    }

    if (context.maxAggression !== undefined && context.maxAggression >= 80) {
        messages.push({
            key: "militia",
            text: "Le frontiere ribollono di stendardi stranieri. Occorre prepararci ora, non quando sarà tardi.",
            priority: 2
        });
    }

    factionOrder.forEach(key => {
        const mood = factions[key] || 50;
        if (mood <= 28 && Math.random() < 0.5) {
            messages.push({ key, text: getFactionChatLine(key, mood), priority: 1 });
        } else if (mood >= 75 && Math.random() < 0.25 && !messages.length) {
            messages.push({ key, text: getFactionChatLine(key, mood), priority: 0 });
        }
    });

    if (!messages.length) return;

    messages.sort((a, b) => (b.priority || 0) - (a.priority || 0));
    const used = new Set();
    const selected = [];
    messages.forEach(msg => {
        if (selected.length >= 3) return;
        if (used.has(msg.key)) return;
        selected.push(msg);
        used.add(msg.key);
    });

    selected.forEach(msg => {
        addMsg("ai", `<strong>${factionLabel(msg.key)}</strong>: ${msg.text}`);
    });
}

// Mappa Emoji/Icone per Fazioni
const FACTION_ICONS = {
    nobility: "🦁", clergy: "✝️", peasants: "🌾", militia: "⚔️",
    burghers: "🔨", merchants: "⚖️", mystics: "🔮", outcasts: "🐀"
};

const COURT_RELATIONSHIPS = {
    nobility: { friends: ['clergy'], enemies: ['peasants', 'burghers'] },
    clergy: { friends: ['nobility', 'mystics'], enemies: ['merchants', 'outcasts'] },
    militia: { friends: ['nobility'], enemies: ['outcasts', 'peasants'] },
    peasants: { friends: ['outcasts'], enemies: ['nobility', 'militia'] },
    burghers: { friends: ['merchants'], enemies: ['nobility'] },
    merchants: { friends: ['burghers'], enemies: ['clergy'] },
    mystics: { friends: ['clergy'], enemies: ['burghers'] },
    outcasts: { friends: ['peasants'], enemies: ['militia'] }
};

function triggerCourtEvent(context) {
    const deficits = context.deficits || {};
    // ... (Logica selezione attori esistente rimane uguale) ...
    
    // Esempio di selezione (copia dal tuo codice o usa logica semplificata)
    let mainActor = 'peasants'; // Fallback
    let antagonist = 'nobility'; // Fallback
    let topic = "la fame";

    // ... (Tua logica di selezione attore/antagonista) ...

    // Prompt Migliorato per Realismo
    const actorName = getChatName(mainActor).split(" ")[0]; // Solo nome (es. Odric)
    const antagName = getChatName(antagonist).split(" ")[0]; // Solo nome (es. Lord Emeric)
    const actorTitle = factionLabel(mainActor);
    const antagTitle = factionLabel(antagonist);

    // Definisci la tensione della scena basata sui dati reali
    const tensionLevel = factions[mainActor] < 40 || factions[antagonist] < 40 ? "ALTA TENSIONE" : "DIBATTITO CIVILE";

    const prompt = `
    Sei il Regista della Sala del Trono.
    
    ATTORI:
    1. ${actorName} (${actorTitle}) - Lealtà verso il Conte: ${factions[mainActor]}/100.
    2. ${antagName} (${antagTitle}) - Lealtà verso il Conte: ${factions[antagonist]}/100.
    
    RELAZIONE TRA FAZIONI: ${COURT_RELATIONSHIPS[mainActor]?.enemies.includes(antagonist) ? 'NEMICI NATURALI' : 'NEUTRALI/ALLEATI'}.
    
    SITUAZIONE: ${tensionLevel}. Si discute di: "${topic}".
    
    COMPITO:
    Scrivi UNA breve scena (max 4 righe totali) di dialogo diretto.
    - Se sono NEMICI o la lealtà è bassa: Devono esserci frecciate, accuse o sarcasmo.
    - Se sono ALLEATI: Devono concordare o cercare una soluzione comune.
    - Il Conte è presente ma ascolta in silenzio.
    
    FORMATO (Usa ESATTAMENTE questo):
    SCENA: [Una frase descrittiva dell'atmosfera, es. "Odric si fa avanti stringendo il cappello tra le mani..."]
    ${actorName}: "[Battuta coerente con la sua classe sociale]"
    ${antagName}: "[Risposta coerente con la sua classe sociale]"
    
    Non aggiungere saluti formali inutili. Vai dritto al conflitto/problema.
    `;

    callGroq(prompt, "debate");
}







function togglePanel(id) {
    const panel = document.getElementById(id);
    if (!panel) return;
    panel.classList.toggle("collapsed");
}

function refreshLawTargetOptions() {
    const typeSelect = document.getElementById("law-custom-type");
    const targetSelect = document.getElementById("law-custom-target");
    if (!typeSelect || !targetSelect) return;
    const type = typeSelect.value;
    const options = [];
    if (type === "production") {
        RESOURCE_KEYS.forEach(key => options.push({ value: key, label: resourceLabels[key] || key }));
    } else if (type === "taxes") {
        TAX_CATEGORIES.forEach(cat => options.push({ value: cat.key, label: cat.label }));
    } else {
        factionOrder.forEach(key => options.push({ value: key, label: factionLabel(key) }));
    }
    targetSelect.innerHTML = options.map(opt => `<option value="${opt.value}">${opt.label}</option>`).join("");
}

function setupLawCreator() {
    const typeSelect = document.getElementById("law-custom-type");
    if (!typeSelect) return;
    typeSelect.addEventListener("change", refreshLawTargetOptions);
    refreshLawTargetOptions();
}

function createCustomLaw() {
    const nameInput = document.getElementById("law-custom-name");
    const descInput = document.getElementById("law-custom-desc");
    const typeSelect = document.getElementById("law-custom-type");
    const targetSelect = document.getElementById("law-custom-target");
    const valueInput = document.getElementById("law-custom-value");
    if (!nameInput || !descInput || !typeSelect || !targetSelect || !valueInput) return;

    const name = nameInput.value.trim();
    const desc = descInput.value.trim() || "Senza descrizione";
    const type = typeSelect.value;
    const target = targetSelect.value;
    const rawValue = parseFloat(valueInput.value);

    if (!name || !target || Number.isNaN(rawValue)) {
        addMsg("system", "⚠️ Compila nome, valore e scegli un bersaglio per la legge.");
        return;
    }

    const effects = {};
    if (type === "production") {
        const multiplier = 1 + rawValue / 100;
        if (!effects.production) effects.production = {};
        effects.production[target] = multiplier;
    } else if (type === "taxes") {
        if (!effects.taxes) effects.taxes = {};
        effects.taxes[target] = rawValue;
    } else if (type === "factions") {
        if (!effects.factions) effects.factions = {};
        effects.factions[target] = rawValue;
    }

    const key = slugify(`${name}_${Date.now()}`);
    customLaws.push({ key: `custom_${key}`, name, description: desc, effects, custom:true });
    renderLawList();
    nameInput.value = "";
    descInput.value = "";
    valueInput.value = "";
}

function getFactionProductionMultiplier(resourceKey, targetState = null) {
    const map = RESOURCE_FACTION_MAP[resourceKey];
    if (!map) return 1;
    const factionsRef = targetState ? targetState.factions : factions;
    const mood = (factionsRef[map.faction] || 50) - 50;
    return Math.max(0.5, 1 + (mood / 100) * map.scale);
}

function getProductionMultiplier(resourceKey, targetState = null) {
    const season = getSeason(targetState ? targetState.worldTime : worldTime);
    let mult = 1;
    if (season.production && season.production[resourceKey]) {
        mult *= season.production[resourceKey];
    }
    getActiveLawKeys(targetState).forEach(key => {
        const law = getLawDefinition(key);
        if (law && law.effects && law.effects.production && law.effects.production[resourceKey]) {
            mult *= law.effects.production[resourceKey];
        }
    });
    mult *= getFactionProductionMultiplier(resourceKey, targetState);
    return mult;
}

function renderTaxGrid(force = false) {
    const grid = document.getElementById("tax-grid");
    if (!grid) return;
    if (force) {
        delete grid.dataset.rendered;
    }
    if (grid.dataset.rendered === "1") {
        syncTaxGridValues();
        return;
    }
    grid.innerHTML = "";
    TAX_CATEGORIES.forEach(cat => {
        const card = document.createElement("div");
        card.className = "tax-card";
        const label = document.createElement("label");
        label.innerHTML = `<span>${cat.label}</span><span id="tax-rate-${cat.key}">${taxPolicy[cat.key]}%</span>`;
        const input = document.createElement("input");
        input.type = "range";
        input.id = `tax-slider-${cat.key}`;
        input.min = 0;
        input.max = 30;
        input.step = 1;
        input.value = taxPolicy[cat.key];
        input.addEventListener("input", (ev) => setTaxRate(cat.key, Number(ev.target.value)));
        card.append(label, input);
        grid.appendChild(card);
    });
    grid.dataset.rendered = "1";
    updateTaxSummary();
}

function syncTaxGridValues() {
    TAX_CATEGORIES.forEach(cat => {
        const slider = document.getElementById(`tax-slider-${cat.key}`);
        if (slider) slider.value = taxPolicy[cat.key];
        const label = document.getElementById(`tax-rate-${cat.key}`);
        if (label) label.innerText = `${taxPolicy[cat.key]}%`;
    });
    updateTaxSummary();
}

function setTaxRate(key, value) {
    taxPolicy[key] = Number(value);
    const label = document.getElementById(`tax-rate-${key}`);
    if (label) label.innerText = `${value}%`;
    updateTaxSummary();
}

function getLawTaxModifier(categoryKey, targetState = null) {
    let delta = 0;
    getActiveLawKeys(targetState).forEach(key => {
        const law = getLawDefinition(key);
        if (law && law.effects && law.effects.taxes && law.effects.taxes[categoryKey]) {
            delta += law.effects.taxes[categoryKey];
        }
    });
    return delta;
}

function ensureTaxPolicy(targetState) {
    if (targetState) {
        if (!targetState.taxPolicy) targetState.taxPolicy = createDefaultTaxPolicy();
        return targetState.taxPolicy;
    }
    return taxPolicy;
}

function collectTaxes(targetState = null, options = {}) {
    const statePop = targetState ? targetState.populationGroups : populationGroups;
    const stateCounty = targetState ? targetState.county : county;
    const stateFactions = targetState ? targetState.factions : factions;
    const policy = ensureTaxPolicy(targetState);
    let total = 0;
    TAX_CATEGORIES.forEach(cat => {
    const pop = statePop[cat.key]?.count || 0;  // ✅ Prende il numero di persone
    const baseWealth = pop * cat.wealthFactor;  // ✅ Ora funziona!
        const lawDelta = getLawTaxModifier(cat.key, targetState);
        const effectivePercent = Math.max(0, (policy[cat.key] || 0) + lawDelta);
        const income = Math.floor(baseWealth * (effectivePercent / 100));
        total += income;
        const tolerance = cat.tolerance;
        if (effectivePercent > tolerance) {
            const penalty = Math.round((effectivePercent - tolerance) / 2);
            stateFactions[cat.key] = clamp((stateFactions[cat.key] || 50) - penalty);
        } else if (effectivePercent < tolerance - 3) {
            stateFactions[cat.key] = clamp((stateFactions[cat.key] || 50) + 1);
        }
    });
    total = Math.max(0, total);
    stateCounty.gold += total;
    if (!targetState) {
        recordTaxHistory(total);
        if (!options.silent) addMsg("system", `💰 Entrate fiscali: ${total} oro.`);
        updateTaxSummary();
    }
    return total;
}

function recordTaxHistory(amount) {
    taxHistory.push(amount);
    if (taxHistory.length > 8) taxHistory.shift();
}

function updateTaxSummary() {
    const lastEl = document.getElementById("tax-last");
    const trendEl = document.getElementById("tax-trend");
    const last = taxHistory[taxHistory.length - 1] || 0;
    const prev = taxHistory[taxHistory.length - 2] || last;
    if (lastEl) lastEl.innerText = last;
    if (trendEl) {
        if (taxHistory.length < 2 || last === prev) trendEl.innerText = "stabile";
        else trendEl.innerText = last > prev ? `↑ +${last - prev}` : `↓ ${last - prev}`;
    }
}

function applySeasonalUpkeep(targetState = null, options = {}) {
    const timeRef = targetState ? targetState.worldTime : worldTime;
    const season = getSeason(timeRef);
    const stateCounty = targetState ? targetState.county : county;
    const popRef = targetState ? targetState.populationGroups : populationGroups;
    const militia = popRef.militia || 0;
    const upkeep = Math.floor(militia * 0.2 * season.warCost);
    if (!upkeep) return;
    stateCounty.gold = Math.max(0, stateCounty.gold - upkeep);
    if (!targetState && !options.silent) {
        addMsg("system", `🛡️ Costi stagionali delle truppe: -${upkeep} oro.`);
    }
}

function factionLabel(key) {
    return key.charAt(0).toUpperCase() + key.slice(1);
}

function getFactionEffectText(key, value) {
    const ref = FACTION_EFFECT_DESCRIPTIONS[key] || {};
    if (value >= 65) return ref.bonus || "Sono soddisfatti.";
    if (value <= 35) return ref.malus || "Sono inquieti.";
    return "Equilibrati.";
}

function getFactionChatLine(key, mood) {
    const ref = FACTION_EFFECT_DESCRIPTIONS[key] || {};
    if (mood >= 70) return ref.bonus || "Vi onoriamo, Conte.";
    if (mood <= 30) return ref.malus || "La nostra pazienza è agli sgoccioli.";
    return "Attendiamo che le promesse diventino fatti.";
}

function handleFactionChipClick(key) {
    ensureWorldSystems();
    const mood = factions[key] || 50;
    const line = getFactionChatLine(key, mood);
    addMsg("ai", `<strong>${factionLabel(key)}</strong>: ${line}`);
}

function renderFactionChips() {
    const container = document.getElementById("chat-faction-chips");
    if (!container) return;
    container.innerHTML = "";
    factionOrder.forEach(key => {
        const btn = document.createElement("button");
        btn.className = "faction-chip";
        const mood = factions[key] || 50;
        if (mood <= 35) btn.classList.add("low");
        else if (mood >= 65) btn.classList.add("high");
        btn.innerText = factionLabel(key);
        btn.title = `Lealtà: ${mood}`;
        btn.addEventListener("click", () => handleFactionChipClick(key));
        container.appendChild(btn);
    });
}

function updateFactionImpactUI(targetState = null) {
    const container = document.getElementById("faction-impact-list");
    if (!container) return;
    container.innerHTML = "";
    const factionsRef = targetState ? targetState.factions : factions;
    factionOrder.forEach(key => {
        const val = factionsRef[key] || 50;
        const card = document.createElement("div");
        card.className = "faction-effect-card";
        card.innerHTML = `<strong>${factionLabel(key)}</strong><div>Loyalty: ${val}</div><div>${getFactionEffectText(key, val)}</div>`;
        container.appendChild(card);
    });
}

/* ============================================================
   ============ MENU INIZIALE, SALVATAGGI E IMPOSTAZIONI ======
   ============================================================ */

function initStartScreen() {
    ensureWorldSystems();
    loadStoredApiKey();
    loadPersonalitySettings();
    renderSaveCollection("save-list", { closeOnLoad:true });
    updateSaveStatusFromStorage();
    activateScreen("screen-start");
}

function activateScreen(id) {
    document.querySelectorAll(".screen").forEach(s => s.classList.remove("active"));
    const target = document.getElementById(id);
    if (target) target.classList.add("active");
    if (id !== "screen-start") closeLoadModal();
}

function goToEditorScreen() {
    activateScreen("screen-editor");
    syncEditorDefaults();
}

function openLoginScreen() {
    syncApiKeyInputs(apiKey || safeStorageGet("conte_api_key") || "");
    activateScreen("screen-login");
}

function syncEditorDefaults() {
    const advSelect = document.getElementById("adv-pers");
    if (advSelect && personalitySettings && personalitySettings.advisorTone) {
        advSelect.value = personalitySettings.advisorTone;
    }
}

function saveApiKeyFromStart() {
    const startInput = document.getElementById("api-key-start");
    const key = startInput ? startInput.value.trim() : "";
    if (!key) {
        updateApiKeyStatus("Inserisci una chiave valida.", false);
        return;
    }
    setApiKey(key);
    updateApiKeyStatus("Chiave salvata in locale.");
}

function clearStoredApiKey() {
    apiKey = "";
    safeStorageRemove("conte_api_key");
    syncApiKeyInputs("");
    updateApiKeyStatus("Chiave rimossa.");
}

function setApiKey(key) {
    apiKey = key ? key.trim() : "";
    if (apiKey) safeStorageSet("conte_api_key", apiKey);
    syncApiKeyInputs(apiKey);
}

function ensureApiKey() {
    if (apiKey) return apiKey;
    const stored = safeStorageGet("conte_api_key");
    if (stored) {
        apiKey = stored;
        syncApiKeyInputs(apiKey);
        updateApiKeyStatus("Chiave caricata automaticamente.");
    }
    return apiKey;
}

function syncApiKeyInputs(value) {
    const loginInput = document.getElementById("api-key-input");
    const startInput = document.getElementById("api-key-start");
    if (loginInput) loginInput.value = value || "";
    if (startInput) startInput.value = value || "";
}

function updateApiKeyStatus(text, positive = true) {
    const status = document.getElementById("api-key-status");
    if (status) {
        status.innerText = text;
        status.style.color = positive ? "var(--text-soft)" : "#ff6b6b";
    }
}

function loadStoredApiKey() {
    const stored = safeStorageGet("conte_api_key");
    if (stored) {
        apiKey = stored;
        syncApiKeyInputs(apiKey);
        updateApiKeyStatus("Chiave ricordata.");
    }
}

function savePersonalitySettingsForm() {
    const toneInput = document.getElementById("personality-tone");
    const moodInput = document.getElementById("personality-mood");
    const notesInput = document.getElementById("personality-notes");
    personalitySettings = {
        advisorTone: (toneInput && toneInput.value) || DEFAULT_PERSONALITY.advisorTone,
        courtMood: (moodInput && moodInput.value) || DEFAULT_PERSONALITY.courtMood,
        notes: notesInput ? notesInput.value.trim() : ""
    };
    safeStorageSet("conte_personality_settings", JSON.stringify(personalitySettings));
}

function loadPersonalitySettings() {
    try {
        const raw = safeStorageGet("conte_personality_settings");
        if (raw) personalitySettings = JSON.parse(raw);
    } catch(e) {
        personalitySettings = { ...DEFAULT_PERSONALITY };
    }
    syncPersonalityForm(personalitySettings);
}

function syncPersonalityForm(settings) {
    const tone = document.getElementById("personality-tone");
    const mood = document.getElementById("personality-mood");
    const notes = document.getElementById("personality-notes");
    if (tone && settings && settings.advisorTone) tone.value = settings.advisorTone;
    if (mood && settings && settings.courtMood) mood.value = settings.courtMood;
    if (notes) notes.value = (settings && settings.notes) ? settings.notes : "";
}

function openLoadModal() {
    renderSaveCollection("modal-save-list", { showDelete:true });
    const modal = document.getElementById("load-modal");
    if (modal) modal.classList.add("active");
}

function closeLoadModal() {
    const modal = document.getElementById("load-modal");
    if (modal) modal.classList.remove("active");
}

function manualSaveFromModal() {
    const input = document.getElementById("save-slot-name");
    const name = input ? input.value.trim() : "";
    const slotKey = name ? slugify(name) : `manuale_${Date.now()}`;
    const label = name || "Salvataggio manuale";
    saveGame(slotKey, { label });
    if (input) input.value = "";
    renderSaveCollection("modal-save-list", { showDelete:true });
}

function quickSaveGame() {
    saveGame("quick", { label:"Salvataggio rapido", skipSlug:true });
}

function autoSaveGame() {
    saveGame("autosave", { label:"Autosave", silent:true, skipSlug:true });
}

function saveGame(slotKey = "manuale", options = {}) {
    const { label = slotKey, silent = false, skipSlug = false } = options;
    if (typeof localStorage === "undefined") return;

    let finalKey = slotKey || "slot";
    if (!skipSlug && !RESERVED_SAVE_SLOTS.includes(finalKey)) {
        finalKey = slugify(finalKey) || `slot_${Date.now()}`;
    }

    const payload = {
        meta: {
            slot: finalKey,
            label,
            timestamp: Date.now(),
            heroName,
            turn: county.turn
        },
        state: captureGameState()
    };

    safeStorageSet(`conte_save_${finalKey}`, JSON.stringify(payload));
    const statusText = `${label} – Turno ${county.turn}`;
    safeStorageSet("conte_last_save_label", statusText);
    updateSaveStatus(statusText);
    updateSaveCollections();

    if (!silent) {
        addMsg("system", `💾 Salvataggio completato (${label}).`);
    }
}

function loadGame(slotKey) {
    if (!slotKey) return;
    const raw = safeStorageGet(`conte_save_${slotKey}`);
    if (!raw) {
        addMsg("system", "❌ Salvataggio non trovato.");
        return;
    }

    try {
        const data = JSON.parse(raw);
        restoreGameState(data.state || data);
        updateUI();
        drawCountyMap();
        drawRegionMap();
        activateScreen("screen-game");
        const loadedLabel = data.meta && data.meta.label ? data.meta.label : slotKey;
        addMsg("system", `📂 Caricata la partita ${loadedLabel} (Turno ${county.turn}).`);
        closeLoadModal();
        updateSaveCollections();
    } catch(e) {
        addMsg("system", "⚠️ Impossibile caricare il salvataggio.");
    }
}

function deleteSave(slotKey) {
    safeStorageRemove(`conte_save_${slotKey}`);
    updateSaveCollections();
}

function updateSaveCollections() {
    renderSaveCollection("save-list", { closeOnLoad:true });
    const loadModal = document.getElementById("load-modal");
    if (loadModal && loadModal.classList.contains("active")) {
        renderSaveCollection("modal-save-list", { showDelete:true });
    }
}

function renderSaveCollection(containerId, options = {}) {
    const container = document.getElementById(containerId);
    if (!container) return;
    const slots = getSaveSlots();

    if (!slots.length) {
        container.innerHTML = '<p class="save-empty">Nessun salvataggio disponibile.</p>';
        return;
    }

    container.innerHTML = "";
    slots.forEach(slot => {
        const row = document.createElement("div");
        row.className = "save-entry";

        const details = document.createElement("div");
        details.className = "save-entry-details";
        const title = document.createElement("strong");
        title.innerText = slot.meta.label || slot.slot;
        const subtitle = document.createElement("span");
        subtitle.innerText = `${slot.meta.heroName || "Conte"} — Turno ${slot.meta.turn || 1}`;
        const time = document.createElement("small");
        time.innerText = new Date(slot.meta.timestamp || Date.now()).toLocaleString("it-IT");
        details.append(title, subtitle, time);

        const actions = document.createElement("div");
        actions.className = "save-entry-actions";
        const loadBtn = document.createElement("button");
        loadBtn.className = "btn-sec";
        loadBtn.innerText = "Carica";
        loadBtn.addEventListener("click", () => loadGame(slot.slot));
        actions.appendChild(loadBtn);

        if (options.showDelete) {
            const delBtn = document.createElement("button");
            delBtn.className = "btn-sec";
            delBtn.innerText = "Elimina";
            delBtn.addEventListener("click", () => {
                if (confirm(`Eliminare ${slot.meta.label || slot.slot}?`)) {
                    deleteSave(slot.slot);
                    renderSaveCollection(containerId, options);
                }
            });
            actions.appendChild(delBtn);
        }

        row.append(details, actions);
        container.appendChild(row);
    });
}

function getSaveSlots() {
    if (typeof localStorage === "undefined") return [];
    const slots = [];
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (!key || !key.startsWith("conte_save_")) continue;
        try {
            const payload = JSON.parse(localStorage.getItem(key));
            slots.push({
                slot: key.replace("conte_save_", ""),
                meta: payload.meta || { timestamp: Date.now(), label: key }
            });
        } catch(e) {
            continue;
        }
    }
    return slots.sort((a,b) => (b.meta.timestamp || 0) - (a.meta.timestamp || 0));
}

function captureGameState() {
    ensureWorldSystems();
    const snapshot = JSON.parse(JSON.stringify({
        heroName,
        advisor,
        county,
        landOwnership,
        populationGroups,
        factions,
        neighboringCounties,
        structures,
        buildings,
        settlements,
        worldMap,
        privateChats,
        publicChatHistory,
        personalitySettings,
        worldTime,
        taxPolicy,
        taxHistory,
        activeLaws,
        lastResourceSnapshot,
        lastResourceDelta,
        industrySummary,
        customLaws,
        dynasty
    }));
    snapshot.county.resources = normalizeResourceBag(snapshot.county.resources);
    return snapshot;
}

function restoreGameState(state) {
    county = state.county ? JSON.parse(JSON.stringify(state.county)) : createDefaultCounty();
    const sourceResources = (state.county && state.county.resources) ? state.county.resources : {};
    county.resources = normalizeResourceBag(sourceResources);
    landOwnership = state.landOwnership ? JSON.parse(JSON.stringify(state.landOwnership)) : createDefaultLand();
    populationGroups = state.populationGroups ? JSON.parse(JSON.stringify(state.populationGroups)) : createDefaultPopulation();
    // Migra vecchi salvataggi alla nuova struttura
    populationGroups = migratePopulationGroups(populationGroups);
    factions = state.factions ? JSON.parse(JSON.stringify(state.factions)) : createDefaultFactions();
    neighboringCounties = state.neighboringCounties ? JSON.parse(JSON.stringify(state.neighboringCounties)) : createDefaultNeighbors();
    structures = state.structures ? JSON.parse(JSON.stringify(state.structures)) : createEmptyStructures();
    buildings = state.buildings ? JSON.parse(JSON.stringify(state.buildings)) : [];
    settlements = state.settlements ? JSON.parse(JSON.stringify(state.settlements)) : [];
    worldMap = state.worldMap ? JSON.parse(JSON.stringify(state.worldMap)) : worldMap;
    privateChats = state.privateChats ? JSON.parse(JSON.stringify(state.privateChats)) : createDefaultPrivateChats();
    personalitySettings = state.personalitySettings || personalitySettings;
    heroName = state.heroName || heroName;
    worldTime = state.worldTime ? JSON.parse(JSON.stringify(state.worldTime)) : createDefaultWorldTime();
    taxPolicy = state.taxPolicy ? JSON.parse(JSON.stringify(state.taxPolicy)) : createDefaultTaxPolicy();
    taxHistory = Array.isArray(state.taxHistory) ? [...state.taxHistory] : [];
    activeLaws = Array.isArray(state.activeLaws) ? [...state.activeLaws] : [];
    lastResourceSnapshot = state.lastResourceSnapshot ? JSON.parse(JSON.stringify(state.lastResourceSnapshot)) : captureResourceSnapshot();
    lastResourceDelta = state.lastResourceDelta ? JSON.parse(JSON.stringify(state.lastResourceDelta)) : createEmptyResourceDelta();
    industrySummary = state.industrySummary ? JSON.parse(JSON.stringify(state.industrySummary)) : null;
    customLaws = Array.isArray(state.customLaws) ? JSON.parse(JSON.stringify(state.customLaws)) : [];
    publicChatHistory = state.publicChatHistory || [];
    dynasty = state.dynasty ? JSON.parse(JSON.stringify(state.dynasty)) : dynasty;
    
    // Aggiorna UI dinastia al caricamento
    updateDynastyUI();
    
    ensureWorldSystems();
    recomputePopulation();
}

function normalizeResourceBag(source = {}) {
    const bag = {};
    RESOURCE_KEYS.forEach(key => bag[key] = Number(source[key] ?? 0));
    return bag;
}

function cloneResourceBag(source = {}) {
    return JSON.parse(JSON.stringify(normalizeResourceBag(source)));
}

function createEmptyResourceDelta() {
    const bag = {};
    RESOURCE_KEYS.forEach(key => bag[key] = 0);
    return bag;
}

function createEmptyResourceBag() {
    return createEmptyResourceDelta();
}

function migratePopulationGroups(groups) {
    const defaultGroups = createDefaultPopulation();
    
    // Se è già nella nuova struttura, restituisci come è
    if (groups.nobility && typeof groups.nobility === 'object' && 'count' in groups.nobility) {
        return groups;
    }
    
    // Altrimenti, migra dalla vecchia struttura
    const migrated = {};
    Object.keys(defaultGroups).forEach(key => {
        if (typeof groups[key] === 'number') {
            // Vecchio formato: nobility: 25
            migrated[key] = {
                count: groups[key],
                wealth: defaultGroups[key].wealth,
                resources: createEmptyResourceBag()
            };
        } else if (groups[key] && typeof groups[key] === 'object') {
            // Nuovo formato o parzialmente migrato
            migrated[key] = {
                count: groups[key].count || defaultGroups[key].count,
                wealth: groups[key].wealth || defaultGroups[key].wealth,
                resources: groups[key].resources || createEmptyResourceBag()
            };
        } else {
            // Usa default
            migrated[key] = defaultGroups[key];
        }
    });
    
    return migrated;
}

function captureResourceSnapshot(targetState = null) {
    if (targetState && targetState.county && targetState.county.resources) {
        return cloneResourceBag(targetState.county.resources);
    }
    if (county && county.resources) return cloneResourceBag(county.resources);
    return createEmptyResourceDelta();
}

function computeResourceDelta(startSnapshot, endSnapshot) {
    const delta = {};
    RESOURCE_KEYS.forEach(key => {
        const startVal = startSnapshot && startSnapshot[key] !== undefined ? startSnapshot[key] : 0;
        const endVal = endSnapshot && endSnapshot[key] !== undefined ? endSnapshot[key] : 0;
        delta[key] = endVal - startVal;
    });
    return delta;
}

function resetResourceTracking(targetState = null) {
    if (targetState) {
        targetState.lastResourceSnapshot = captureResourceSnapshot(targetState);
        targetState.lastResourceDelta = createEmptyResourceDelta();
        return;
    }
    lastResourceSnapshot = captureResourceSnapshot();
    lastResourceDelta = createEmptyResourceDelta();
}

function resetGameState() {
    county = createDefaultCounty();
    landOwnership = createDefaultLand();
    populationGroups = createDefaultPopulation();
    factions = createDefaultFactions();
    neighboringCounties = createDefaultNeighbors();
    structures = createEmptyStructures();
    buildings = [];
    settlements = [];
    worldMap.tiles = [];
    privateChats = createDefaultPrivateChats();
    publicChatHistory = []; // <--- AGGIUNTO
    activePrivateChat = null;
    county.turn = 1;
    worldTime = createDefaultWorldTime();
    taxPolicy = createDefaultTaxPolicy();
    taxHistory = [];
    activeLaws = [];
    dynasty = {
        ruler: {
            name: "Conte", // Sarà sovrascritto da heroName
            age: 25,
            maxAge: 75 + Math.floor(Math.random() * 15), // Morte naturale tra 75 e 90
            health: 100,
            traits: ["Fondatore"],
            isDead: false
        },
        spouse: null, // Oggetto { name, age, origin, bonus }
        heirs: []     // Array di oggetti { name, age, gender, traits }
    };
    resetResourceTracking();
    ensureWorldSystems();
    clearInterfaceLogs();
}

function updateSaveStatus(text) {
    const el = document.getElementById("save-status");
    if (el) el.innerText = text || "Nessun salvataggio registrato.";
}

function updateSaveStatusFromStorage() {
    const stored = safeStorageGet("conte_last_save_label");
    if (stored) updateSaveStatus(stored);
}

function slugify(str) {
    return str.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/(^-|-$)/g, "");
}

function safeStorageGet(key) {
    try { return localStorage.getItem(key); } catch(e) { return null; }
}

function safeStorageSet(key, value) {
    try { localStorage.setItem(key, value); } catch(e) {}
}

function safeStorageRemove(key) {
    try { localStorage.removeItem(key); } catch(e) {}
}

/* ============================================================
   =================== GENERAZIONE MAPPA =======================
   ============================================================ */

let worldMap = {
    width: 20,
    height: 20,
    tiles: []
};

let settlements = [];

/* ---- FUNZIONE PRINCIPALE ---- */
function generateWorldMap() {
    worldMap.tiles = [];

    for (let y = 0; y < worldMap.height; y++) {
        for (let x = 0; x < worldMap.width; x++) {

            const terrain = randomTerrain();
            const fertility = baseFertility(terrain) + rand(-10,10);
            const resources = generateResources(terrain);
            const owner = assignOwner(x, y);

            worldMap.tiles.push({
                x, y,
                terrain,
                fertility: clamp(fertility),
                resources,
                owner
            });
        }
    }
}

function getTile(x, y) {
    if (x < 0 || y < 0 || x >= worldMap.width || y >= worldMap.height) return null;
    return worldMap.tiles[y * worldMap.width + x];
}

/* ---- TIPO DI TERRENO ---- */
function randomTerrain() {
    const r = Math.random();
    if (r < 0.30) return "plains";
    if (r < 0.50) return "forest";
    if (r < 0.70) return "hills";
    if (r < 0.82) return "mountain";
    if (r < 0.92) return "swamp";
    return "lake";
}

/* ---- FERTILITÀ BASE ---- */
function baseFertility(t) {
    switch(t){
        case "plains": return 70;
        case "forest": return 50;
        case "hills": return 40;
        case "mountain": return 20;
        case "swamp": return 25;
        case "lake": return 60;
    }
}

/* ---- GENERAZIONE RISORSE ---- */
function generateResources(terrain) {
    let r = {
        wood:0, stone:0, iron:0, copper:0, gold:0, herbs:0,
        gems:0, silver:0, mystic_crystals:0
    };

    if (terrain === "forest") r.wood = rand(50,100);
    if (terrain === "hills") { r.stone = rand(40,80); r.copper = rand(20,50); }
    if (terrain === "mountain") { r.iron = rand(40,100); }

    if (terrain === "swamp") r.herbs = rand(30,60);

    // RARI
    if (Math.random() < 0.03) r.gold = rand(10,30);
    if (Math.random() < 0.03) r.gems = rand(5,20);
    if (Math.random() < 0.03) r.silver = rand(10,30);
    if (Math.random() < 0.02) r.mystic_crystals = rand(5,15);

    return r;
}

/* ---- ASSEGNAZIONE TERRITORIO ---- */
function assignOwner(x, y) {
    if (x > 7 && x < 12 && y > 7 && y < 12) return "count";
    if (y < 4) return "auvrey";
    if (x > 13 && y > 13) return "falken";

    const r = Math.random();
    if (r < 0.33) return "nobility";
    if (r < 0.66) return "clergy";
    return "commons";
}

function generateSettlements() {
    settlements = worldMap.tiles
        .filter(t => t.owner === "count" && t.fertility > 50)
        .sort(() => 0.5 - Math.random())
        .slice(0, 10)
        .map(t => ({ x: t.x, y: t.y }));
}

function assignInitialStructures() {
    updateIndustrySummary();
}

/* ---- UTILS ---- */
function rand(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function clamp(v){ return Math.max(0, Math.min(100,v)); }

/* ============================================================
/* ============================================================
// Colori e stili medievali
const MAP_STYLES = {
    water: "#a3c6d4",
    waterDeep: "#8ab0c0",
    grass: "#d6e4aa",
    forest: "#8fb376",
    forestDark: "#6d9158",
    mountain: "#cfcfc4",
    mountainShadow: "#a0a0a0",
    swamp: "#8d9678",
    hills: "#e0d8a6",
    paper: "#f4ecd8",
    ink: "#3e2723"
};

function drawCountyMap() {
    const canvas = document.getElementById("county-map");
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    const tileSize = canvas.width / worldMap.width;

    // Sfondo base (Pergamena)
    ctx.fillStyle = MAP_STYLES.paper;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Disegna ogni casella (Tile)
    for (let y = 0; y < worldMap.height; y++) {
        for (let x = 0; x < worldMap.width; x++) {
            const tile = getTile(x, y);
            if (!tile) continue;
            drawTileVisuals(ctx, x * tileSize, y * tileSize, tileSize, tile);
        }
    }

    // Disegna bordi di proprietà terriera
    drawOwnershipBorders(ctx, tileSize);

    // Disegna griglia leggera (opzionale, per chiarezza)
    ctx.strokeStyle = "rgba(0,0,0,0.05)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let i = 0; i <= worldMap.width; i++) {
        ctx.moveTo(i * tileSize, 0); ctx.lineTo(i * tileSize, canvas.height);
        ctx.moveTo(0, i * tileSize); ctx.lineTo(canvas.width, i * tileSize);
    }
    ctx.stroke();

    // Disegna Insediamenti e Strutture
    drawSettlements(ctx, tileSize);
    drawStructureMarkers(ctx, tileSize);
    drawStructureLabels(ctx, tileSize);
    
    // Effetto vignettatura (ombra ai bordi)
    drawVignette(ctx, canvas.width, canvas.height);
}

function drawOwnershipBorders(ctx, size) {
    const ownershipColors = {
        count: "rgba(212, 175, 55, 0.8)",  // Oro
        nobility: "rgba(150, 50, 50, 0.8)", // Rosso scuro
        clergy: "rgba(100, 100, 200, 0.8)", // Blu
        commons: "rgba(100, 150, 100, 0.8)" // Verde
    };

    for (let y = 0; y < worldMap.height; y++) {
        for (let x = 0; x < worldMap.width; x++) {
            const tile = getTile(x, y);
            if (!tile || !tile.owner || tile.owner === 'wild') continue;

            const px = x * size;
            const py = y * size;

            // Controlla se i vicini hanno proprietari diversi
            const neighbors = [
                {dx: 0, dy: -1}, {dx: 1, dy: 0}, {dx: 0, dy: 1}, {dx: -1, dy: 0}
            ];

            neighbors.forEach(n => {
                const nx = x + n.dx;
                const ny = y + n.dy;
                const nTile = getTile(nx, ny);
                if (nTile && nTile.owner !== tile.owner) {
                    ctx.strokeStyle = ownershipColors[tile.owner] || "rgba(0,0,0,0.5)";
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    if (n.dx === 0 && n.dy === -1) { // Sopra
                        ctx.moveTo(px, py); ctx.lineTo(px + size, py);
                    } else if (n.dx === 1 && n.dy === 0) { // Destra
                        ctx.moveTo(px + size, py); ctx.lineTo(px + size, py + size);
                    } else if (n.dx === 0 && n.dy === 1) { // Sotto
                        ctx.moveTo(px, py + size); ctx.lineTo(px + size, py + size);
                    } else if (n.dx === -1 && n.dy === 0) { // Sinistra
                        ctx.moveTo(px, py); ctx.lineTo(px, py + size);
                    }
                    ctx.stroke();
                }
            });
        }
    }
}

function drawStructureLabels(ctx, size) {
    structures.mines.forEach(s => drawLabel(ctx, s, size, "Miniera", "#555"));
    structures.sawmills.forEach(s => drawLabel(ctx, s, size, "Segheria", "#4caf50"));
    structures.quarries.forEach(s => drawLabel(ctx, s, size, "Cava", "#795548"));
    structures.monasteries.forEach(s => drawLabel(ctx, s, size, "Monastero", "#9c27b0"));
    
    buildings.forEach(b => {
        if (b.stage === 'complete') {
            const label = buildingData[b.type]?.name || b.type;
            drawLabel(ctx, b, size, label, "#2196f3");
        }
    });
}

function drawLabel(ctx, s, size, label, color) {
    const x = s.x * size + size / 2;
    const y = s.y * size + size / 2 - 15; // Sopra l'icona

    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillRect(x - 20, y - 10, 40, 15);
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    ctx.strokeRect(x - 20, y - 10, 40, 15);

    ctx.fillStyle = "#fff";
    ctx.font = "8px Arial";
    ctx.textAlign = "center";
    ctx.fillText(label, x, y + 2);
}



function drawRegionMap() {
    const canvas = document.getElementById("region-map");
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    const size = canvas.width / 8;

    // Sfondo carta antica
    ctx.fillStyle = "#e3d5b8"; 
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Disegna territori
    for (let y = 0; y < 8; y++) {
        for (let x = 0; x < 8; x++) {
            let owner = "wild";
            // Logica semplice per proprietari (uguale a prima ma con colori nuovi)
            if (y < 2) owner = "auvrey";
            else if (x > 5 && y > 5) owner = "falken";
            else if (rand(0,10) > 4) owner = "count";

            const px = x * size;
            const py = y * size;

            // Disegna solo bordi colorati e leggero riempimento per effetto mappa politica
            ctx.fillStyle = getRegionColor(owner, 0.3);
            ctx.fillRect(px, py, size, size);
            
            ctx.strokeStyle = getRegionColor(owner, 0.8);
            ctx.lineWidth = 1;
            ctx.strokeRect(px, py, size, size);
            
            // Disegna un simbolo per il proprietario
            if (Math.random() > 0.7 && owner !== 'wild') {
                ctx.font = "16px serif";
                ctx.textAlign = "center";
                ctx.fillStyle = "rgba(0,0,0,0.3)";
                const symbol = owner === 'count' ? '⚜️' : (owner === 'auvrey' ? '🦁' : '🦅');
                ctx.fillText(symbol, px + size/2, py + size/2 + 5);
            }
        }
    }
    
    drawNeighborPins(ctx);
    drawVignette(ctx, canvas.width, canvas.height);
}

function getRegionColor(owner, alpha) {
    const map = {
        count: `rgba(212, 175, 55, ${alpha})`,  // Oro
        auvrey: `rgba(180, 40, 40, ${alpha})`,  // Rosso scuro
        falken: `rgba(20, 60, 120, ${alpha})`,  // Blu scuro
        wild: `rgba(100, 100, 100, ${alpha})`   // Grigio neutro
    };
    return map[owner] || map.wild;
}

function drawNeighborPins(ctx) {
    const canvas = ctx.canvas;
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const radius = canvas.width * 0.35;

    neighboringCounties.forEach((c, idx) => {
        const angle = (idx / neighboringCounties.length) * Math.PI * 2;
        const x = centerX + Math.cos(angle) * radius;
        const y = centerY + Math.sin(angle) * radius;

        ctx.beginPath();
        ctx.fillStyle = getRegionColor(c.key, 1);
        ctx.arc(x, y, 12, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "#3e2723";
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.fillStyle = "#fff";
        ctx.font = "10px Georgia";
        ctx.textAlign = "center";
        ctx.fillText(c.name.split(" ")[0], x, y + 3);
    });
}

// Riusa drawNeighborPins esistente ma migliora lo stile dei pin se vuoi
// ... (Il resto delle funzioni ausiliarie come rand() rimane invariato)

/* ============================================================
   ===================== STRUTTURE DI BASE =====================
   ============================================================ */

function createEmptyStructures() {
    return {
        mines: [],
        sawmills: [],
        quarries: [],
        monasteries: []
    };
}

let structures = createEmptyStructures();
let latestAssetFlows = null;

/* ---- GENERAZIONE AUTOMATICA ---- */
function autogenerateStructures() {
    worldMap.tiles.forEach(t => {

        // Miniera
        if (t.terrain === "mountain" && Math.random() < 0.15) {
            structures.mines.push({
                x:t.x, y:t.y, owner:t.owner,
                type:"mine", condition:100,
                workers:rand(5,15),
                production:t.resources
            });
        }

        // Segheria
        if (t.terrain === "forest" && Math.random() < 0.10) {
            structures.sawmills.push({
                x:t.x, y:t.y, owner:t.owner,
                type:"sawmill", condition:100,
                workers:rand(5,12),
                production:{ wood: rand(20,50) }
            });
        }

        // Cava
        if (t.terrain === "hills" && Math.random() < 0.08) {
            structures.quarries.push({
                x:t.x, y:t.y, owner:t.owner,
                type:"quarry", condition:100,
                workers:rand(8,20),
                production:{ stone: rand(15,40) }
            });
        }

        // Monastero
        if ((t.terrain === "plains" || t.terrain === "forest") && Math.random() < 0.05) {
            structures.monasteries.push({
                x:t.x, y:t.y, owner:"clergy",
                type:"monastery", condition:100,
                workers:rand(6,14),
                production:{ herbs: rand(5,15) }
            });
        }
    });
    assignInitialStructures();
}

/* ============================================================
   =================== EDIFICI AVANZATI ========================
   ============================================================ */

let buildings = [];  // Lista edifici in costruzione

const buildingData = {
    // --- SOPRAVVIVENZA & AGRICOLTURA ---
    village_well: {
        name: "Pozzo del Villaggio",
        desc: "Acqua pulita per prevenire malattie nei quartieri poveri.",
        effect: "Salute +, Contadini +",
        cost: { gold: 30, stone: 20 },
        time: 2,
        upkeep: 1
    },
    wheat_field: {
        name: "Campi di Grano Estesi",
        desc: "Bonifica terre per nuove coltivazioni intensive.",
        effect: "Grano (produzione auto), Cibo ++",
        cost: { gold: 50, wood: 10 },
        time: 3,
        upkeep: 2
    },
    dairy_farm: {
        name: "Fattoria e Caseificio",
        desc: "Allevamento bovino per carne e formaggi.",
        effect: "Bestiame (produzione auto), Cibo +",
        cost: { gold: 80, wood: 40 },
        time: 3,
        upkeep: 3
    },
    granary: {
        name: "Granaio Fortificato",
        desc: "Protegge i raccolti da parassiti e ladri.",
        effect: "Sicurezza +, Riserve Cibo protette",
        cost: { gold: 100, wood: 80, stone: 40 },
        time: 4,
        upkeep: 5
    },

    // --- ECONOMIA & INDUSTRIA ---
    market: {
        name: "Mercato Cittadino",
        desc: "Il cuore del commercio locale.",
        effect: "Felicità ++, Oro +, Mercanti ++",
        cost: { gold: 100, wood: 50 },
        time: 3,
        upkeep: 8
    },
    harbor: {
        name: "Porto Commerciale",
        desc: "Apre rotte marittime per l'export.",
        effect: "Oro ++, Mercanti +++, Nobiltà +",
        cost: { gold: 300, wood: 60, stone: 80 },
        time: 6,
        upkeep: 25
    },
    sawmill: {
        name: "Segheria Reale",
        desc: "Impianto idraulico per il taglio del legname.",
        effect: "Legno (produzione auto)",
        cost: { gold: 90, wood: 60, stone: 30 },
        time: 4,
        upkeep: 5,
        isStructure: true
    },
    stone_quarry: {
        name: "Cava di Pietra",
        desc: "Estrazione intensiva di materiali da costruzione.",
        effect: "Pietra (produzione auto)",
        cost: { gold: 85, wood: 40, stone: 40 },
        time: 5,
        upkeep: 8,
        isStructure: true
    },
    iron_mine: {
        name: "Miniera di Ferro",
        desc: "Tunnel profondi per l'estrazione di metalli.",
        effect: "Ferro (produzione auto)",
        cost: { gold: 140, wood: 40, stone: 80, iron: 20 },
        time: 6,
        upkeep: 15,
        isStructure: true
    },
    mint: {
        name: "Zecca Ducale",
        desc: "Conia moneta sovrana.",
        effect: "Oro (rendita fissa), Mercanti +",
        cost: { gold: 100, stone: 60, iron: 15 },
        time: 5,
        upkeep: 20
    },

    // --- MILITARE & SICUREZZA ---
    watchtower: {
        name: "Torre di Guardia",
        desc: "Avvista nemici e banditi da lontano.",
        effect: "Sicurezza ++, Aggressività Vicini --",
        cost: { gold: 120, stone: 70, wood: 20 },
        time: 4,
        upkeep: 10
    },
    barracks: {
        name: "Caserma della Guardia",
        desc: "Alloggi permanenti per la milizia cittadina.",
        effect: "Sicurezza +++, Milizia ++",
        cost: { gold: 120, wood: 50, stone: 70, iron: 15 },
        time: 5,
        upkeep: 30
    },
    mercenary_camp: {
        name: "Accampamento Mercenario",
        desc: "Soldati di ventura a pagamento.",
        effect: "Milizia ++, Clero --, Oro - (mantenimento)",
        cost: { gold: 150, wood: 40, stone: 20 },
        time: 3,
        upkeep: 50
    },
    forge: {
        name: "Forgia Reale",
        desc: "Armi e attrezzi di qualità superiore.",
        effect: "Sicurezza +, Artigiani ++, Milizia +",
        cost: { gold: 200, wood: 80, stone: 120, iron: 40 },
        time: 5,
        upkeep: 10
    },
    stone_walls: {
        name: "Mura di Cinta",
        desc: "Una possente difesa contro gli eserciti invasori.",
        effect: "Sicurezza ++++, Nobiltà +, Prestigio",
        cost: { gold: 500, stone: 400, wood: 50 },
        time: 8,
        upkeep: 15
    },

    // --- FEDE & CULTURA ---
    chapel: {
        name: "Cappella Votiva",
        desc: "Un piccolo luogo di preghiera per il popolo.",
        effect: "Clero +, Felicità +",
        cost: { gold: 60, stone: 20, wood: 30 },
        time: 3,
        upkeep: 5
    },
    church: {
        name: "Chiesa Parrocchiale",
        desc: "Il centro della vita spirituale della comunità.",
        effect: "Clero ++, Felicità ++, Salute +",
        cost: { gold: 250, stone: 150, wood: 60, luxuries: 10 },
        time: 6,
        upkeep: 5
    },
    grand_cathedral: {
        name: "Grande Cattedrale",
        desc: "Un'opera monumentale che attira pellegrini.",
        effect: "Clero ++++, Prestigio Reale, Oro (offerte)",
        cost: { gold: 1200, stone: 800, wood: 200, iron: 50, luxuries: 50 },
        time: 12,
        upkeep: 60
    },
    monk_clinic: {
        name: "Clinica dei Monaci",
        desc: "Erbe e cure per i malati.",
        effect: "Salute +++, Clero ++",
        cost: { gold: 80, wood: 30, herbs: 10 },
        time: 3,
        upkeep: 5
    },

    // --- ISTRUZIONE & PRESTIGIO ---
    school: {
        name: "Scuola degli Scribi",
        desc: "Insegna a leggere e far di conto ai figli dei borghesi.",
        effect: "Artigiani ++, Mistici +, Efficienza tasse",
        cost: { gold: 180, wood: 100, stone: 20 },
        time: 5,
        upkeep: 10
    },
    library: {
        name: "Biblioteca del Conte",
        desc: "Raccoglie sapere antico e mappe rare.",
        effect: "Mistici +++, Consigli migliori",
        cost: { gold: 400, stone: 100, wood: 100, arcane: 10 },
        time: 7,
        upkeep: 20
    },
    theater: {
        name: "Teatro all'Aperto",
        desc: "Svago e cultura per tutte le classi sociali.",
        effect: "Felicità +++, Nobiltà +, Popolo +",
        cost: { gold: 250, wood: 150, stone: 50 },
        time: 5,
        upkeep: 15
    },

    // --- ABITAZIONI & ESPANSIONE ---
    cottage: {
        name: "Casupola",
        desc: "Alloggio base per contadini e lavoratori.",
        effect: "Capacità +50, Contadini +",
        housing: 50, // Nuova proprietà: posti letto
        cost: { gold: 20, wood: 25 },
        time: 2,
        upkeep: 2
    },
    tenement: {
        name: "Palazzina Urbana",
        desc: "Alloggi densi per la borghesia e artigiani.",
        effect: "Capacità +150, Rischio malattie leggero",
        housing: 150,
        cost: { gold: 80, wood: 60, stone: 30 },
        time: 4,
        upkeep: 5
    },
    noble_estate: {
        name: "Tenuta Nobile",
        desc: "Lussuose dimore per attirare l'aristocrazia.",
        effect: "Capacità +20 (Nobili), Nobiltà ++, Prestigio",
        housing: 20,
        cost: { gold: 300, stone: 100, luxuries: 20 },
        time: 6,
        upkeep: 0
    }
};

const STRUCTURE_UPKEEP = { structures: 0, military: 0 };

function calculateSeasonalBudget() {
    const season = getSeason();

    // Usare uno stato simulato per calcolare entrate/spese senza mutare lo stato reale
    const simState = captureGameState();
    ensureWorldSystems(simState);

    // Entrate: calcoliamo le tasse usando la funzione esistente su simState
    let taxes = 0;
    try {
        taxes = collectTaxes(simState, { silent: true }) || 0;
    } catch (e) {
        taxes = 0;
    }

    // Produzione in oro (valore approssimativo): per ora 0 (potremmo estenderlo in futuro)
    const production = 0;

    const income = {
        taxes: Number.isFinite(taxes) ? Math.floor(taxes) : 0,
        production: Number.isFinite(production) ? Math.floor(production) : 0
    };
    income.total = income.taxes + income.production;

    // Spese: militare e manutenzione strutture (sul simulato)
    const expenses = {
        structures: 0,
        military: Math.floor((simState.populationGroups && simState.populationGroups.militia ? simState.populationGroups.militia.count || simState.populationGroups.militia : 0) * 0.2 * season.warCost)
    };

    (simState.buildings || []).forEach(b => {
        if (b.stage === 'complete') {
            const data = buildingData[b.type];
            if (data && data.upkeep) {
                expenses.structures += Number(data.upkeep) || 0;
            }
        }
    });

    expenses.total = expenses.structures + expenses.military;

    const net = (income.total || 0) - (expenses.total || 0);
    return {
        income,
        expenses,
        net: Number.isFinite(net) ? net : 0
    };
}

function buildingName(type){
    return buildingData[type].name;
}

</script>
<script>

/* ============================================================
   ====================== PRODUZIONE PER TURNO =================
   ============================================================ */

function applyProduction(targetState = null, options = {}) {
    const { silent = false, skipUI = false } = options;
    const stateStruct = targetState ? targetState.structures : structures;
    const stateCounty = targetState ? targetState.county : county;
    stateCounty.resources = normalizeResourceBag(stateCounty.resources);
    const notifyStructures = !targetState && !silent;

    const total = {
        wood:0, stone:0, iron:0, copper:0, gold:0, herbs:0,
        grain:0, livestock:0, textiles:0, luxuries:0, arcane:0
    };

    const mines = ownedStructures(stateStruct && stateStruct.mines ? stateStruct.mines : []);
    mines.forEach(m => {
        for (let k in m.production) {
            const amount = Math.floor(m.production[k] * (m.condition / 100));
            if (k === "gems" || k === "silver") {
                total.luxuries += amount;
            } else if (k === "mystic_crystals") {
                total.arcane += amount;
            } else {
                total[k] = (total[k] || 0) + amount;
            }
        }
        degradeStructure(m, { notify: notifyStructures });
    });

    const sawmills = ownedStructures(stateStruct && stateStruct.sawmills ? stateStruct.sawmills : []);
    sawmills.forEach(s => {
        const amount = Math.floor(s.production.wood * (s.condition / 100));
        total.wood += amount;
        degradeStructure(s, { notify: notifyStructures });
    });

    const quarries = ownedStructures(stateStruct && stateStruct.quarries ? stateStruct.quarries : []);
    quarries.forEach(q => {
        const amount = Math.floor(q.production.stone * (q.condition / 100));
        total.stone += amount;
        degradeStructure(q, { notify: notifyStructures });
    });

    const monasteries = ownedStructures(stateStruct && stateStruct.monasteries ? stateStruct.monasteries : []);
    monasteries.forEach(m => {
        const amount = Math.floor(m.production.herbs * (m.condition / 100));
        total.herbs += amount;
        degradeStructure(m, { notify: notifyStructures });
    });

    Object.keys(total).forEach(k => {
        stateCounty.resources[k] = (stateCounty.resources[k] || 0) + total[k];
    });

    if (!targetState && !silent) {
        addMsg("system", `⛏️ Produzione del turno: ${formatResourceReport(total)}`);
        if (!skipUI) updateResourceUI();
    }

    return total;
}

function degradeStructure(s, options = {}) {
    const notify = options.notify !== false;
    s.condition -= rand(0, 2);
    if (notify && s.condition < 35 && Math.random() < 0.12) {
        addMsg("ai", `⚠️ La struttura (${s.type}) in ${s.x},${s.y} è in pessime condizioni.`);
    }
}

function updateResourceUI() {
    const bag = county.resources || {};
    RESOURCE_KEYS.forEach(key => {
        const valEl = document.getElementById(`res-${key}`);
        if (valEl) valEl.innerText = bag[key] || 0;
        const deltaEl = document.getElementById(`res-${key}-delta`);
        if (!deltaEl) return;
        const deltaValue = lastResourceDelta ? (lastResourceDelta[key] || 0) : 0;
        deltaEl.innerText = formatDeltaValue(deltaValue);
        deltaEl.classList.remove("positive", "negative");
        if (deltaValue > 0) deltaEl.classList.add("positive");
        else if (deltaValue < 0) deltaEl.classList.add("negative");
    });
}

function formatDeltaValue(value) {
    if (!value) return "—";
    return value > 0 ? `+${value}` : `${value}`;
}

function calculateHousingCapacity() {
    // FIX: Aumentata capacità base da 100 a 150 per abitante per evitare senzatetto al turno 1
    let capacity = (settlements.length || 0) * 150; 

    // Capacità aggiunta dagli edifici costruiti
    buildings.forEach(b => {
        if (b.stage === 'complete') {
            const data = buildingData[b.type];
            if (data && data.housing) {
                capacity += data.housing;
            }
            // Bonus extra specifici
            if (b.type === 'barracks') capacity += 50; 
            if (b.type === 'grand_cathedral') capacity += 50; // Aumentato rifugio
        }
    });
    return capacity;
}

function processVillageEconomy(targetState = null, options = {}) {
    const { silent = false, skipUI = false } = options;
    const stateRef = targetState || null;
    const summary = updateIndustrySummary(stateRef);
    const flows = calculateAssetFlows(summary, stateRef);
    const production = calculateVillageProduction(stateRef);
    const consumption = calculateVillageConsumption(stateRef);
    const logisticNeeds = calculateLogisticNeeds(stateRef);
    logisticNeeds.forEach(need => {
        consumption[need.resource] = (consumption[need.resource] || 0) + need.amount;
    });
    const deficits = {};
    const stateCounty = stateRef ? stateRef.county : county;
    stateCounty.resources = normalizeResourceBag(stateCounty.resources);
    const resourceBag = stateCounty.resources;

    if (flows.goldCost) {
        const need = flows.goldCost;
        const available = stateCounty.gold || 0;
        if (available >= need) {
            stateCounty.gold = available - need;
        } else {
            const paidRatio = available / need;
            stateCounty.gold = 0;
            Object.keys(production).forEach(key => {
                production[key] = Math.floor(production[key] * paidRatio);
            });
            Object.keys(consumption).forEach(key => {
                consumption[key] = Math.floor((consumption[key] || 0) * paidRatio);
            });
            deficits.gold = Math.ceil(need - available);
        }
    }

    Object.keys(production).forEach(key => {
        resourceBag[key] = (resourceBag[key] || 0) + production[key];
    });

    Object.keys(consumption).forEach(key => {
        const available = resourceBag[key] || 0;
        const finalAmount = available - consumption[key];
        if (finalAmount < 0) {
            deficits[key] = Math.abs(finalAmount);
            resourceBag[key] = 0;
        } else {
            resourceBag[key] = finalAmount;
        }
    });

    applyEconomicEffects(production, consumption, deficits, stateRef);
    const logisticImpact = applyLogisticConsequences(logisticNeeds, deficits, stateRef);

    if (!targetState && !silent) {
        const upkeepNote = flows.goldCost ? ` | Manutenzione: ${flows.goldCost} oro` : "";
        addMsg("system", `⚖️ Economia locale — Prodotti: ${formatResourceReport(production)} | Consumi: ${formatResourceReport(consumption)}${upkeepNote}`);
        if (Object.keys(deficits).length) {
            addMsg("system", `⚠️ Carenze critiche: ${formatResourceReport(deficits)}`);
        }
        if (logisticImpact.military) {
            addMsg("system", "⚔️ Le forniture militari sono insufficienti: la disciplina cala e la salute pubblica ne risente.");
        }
        if (logisticImpact.construction) {
            addMsg("system", "🏗️ I cantieri rallentano per mancanza di materiali: alcuni lavori slittano.");
        }
        if (!skipUI) updateUI();
    }

    return { production, consumption, deficits, logisticImpact, logisticNeeds };
}

function calculateVillageProduction(stateRef = null) {
    const summary = getIndustrySummary(stateRef);
    const flows = getCachedAssetFlows(stateRef) || calculateAssetFlows(summary, stateRef);
    const production = { ...flows.production };
    Object.keys(production).forEach(key => {
        const mult = getProductionMultiplier(key, stateRef);
        production[key] = Math.max(0, Math.floor(production[key] * mult));
    });
    return production;
}

function calculateVillageConsumption(stateRef = null) {
    const popRef = stateRef ? stateRef.populationGroups : populationGroups;
    const flows = getCachedAssetFlows(stateRef) || calculateAssetFlows(getIndustrySummary(stateRef), stateRef);
    const consumption = { ...flows.consumption };
    const grainExtra = Math.floor(((popRef.militia || 0) + (popRef.peasants || 0)) * 0.05);
    const livestockExtra = Math.floor((popRef.nobility || 0) * 0.02);
    const textilesExtra = Math.floor((popRef.burghers || 0) * 0.02);
    const herbsExtra = Math.floor((popRef.mystics || 0) * 0.05);
    if (grainExtra) consumption.grain = (consumption.grain || 0) + grainExtra;
    if (livestockExtra) consumption.livestock = (consumption.livestock || 0) + livestockExtra;
    if (textilesExtra) consumption.textiles = (consumption.textiles || 0) + textilesExtra;
    if (herbsExtra) consumption.herbs = (consumption.herbs || 0) + herbsExtra;
    return consumption;
}

function applyEconomicEffects(production, consumption, deficits, stateRef = null) {
    const countyRef = stateRef ? stateRef.county : county;
    const factionsRef = stateRef ? stateRef.factions : factions;

    // --- NUOVA LOGICA ABITATIVA ---
    const totalPop = countyRef.pop;
    const capacity = calculateHousingCapacity();
    const homeless = Math.max(0, totalPop - capacity);
    const vacancy = Math.max(0, capacity - totalPop);

    // Effetti dei Senzatetto (Deficit Abitativo)
    if (homeless > 0) {
        // Più gente senza casa = Più infelicità e malattie
        const severity = Math.ceil(homeless / 50); // Ogni 50 senzatetto, 1 punto malus
        
        countyRef.happy = clamp(countyRef.happy - severity);
        countyRef.health = clamp(countyRef.health - Math.ceil(severity / 2));
        
        // Le fazioni popolari si arrabbiano
        factionsRef.peasants -= 2;
        factionsRef.outcasts += 2; // Aumenta il crimine/emarginati
        
        // Messaggio di allarme (solo se non è una simulazione silenziosa)
        if (!stateRef && Math.random() < 0.2) {
            addMsg("ai", `🏚️ <b>Emergenza Abitativa:</b> ${homeless} sudditi dormono all'aperto! La plebe mormora.`);
        }
    } 
    // Effetti dello Spazio Libero (Incentivo alla crescita)
    else if (vacancy > 50) {
        // Se ci sono case libere e cibo, la gente arriva
        if (countyRef.food > 30 && countyRef.happy > 50) {
            // Immigrazione bonus
            const immigration = Math.floor(vacancy * 0.05); // Riempi il 5% dei posti liberi
            adjustPopulation("peasants", immigration, stateRef);
            if (!stateRef && Math.random() < 0.1) {
                addMsg("system", `🏘️ Le case vuote attirano ${immigration} nuovi coloni.`);
            }
        }
    }
    // --- FINE NUOVA LOGICA ---

    const prodGrain = production.grain || 0;
    const consGrain = consumption.grain || 0;
    const prodLivestock = production.livestock || 0;
    const consLivestock = consumption.livestock || 0;
    const prodTextiles = production.textiles || 0;
    const consTextiles = consumption.textiles || 0;
    const prodLuxuries = production.luxuries || 0;
    const consLuxuries = consumption.luxuries || 0;
    const prodArcane = production.arcane || 0;
    const consArcane = consumption.arcane || 0;
    const foodShortage = deficits.grain || deficits.livestock;
    const textileShortage = deficits.textiles;
    const luxuryShortage = deficits.luxuries;
    const arcaneShortage = deficits.arcane || deficits.herbs;
    const goldShortage = deficits.gold;

    if (foodShortage) {
        countyRef.food = clamp(countyRef.food - 6);
        countyRef.happy = clamp(countyRef.happy - 4);
        factionsRef.peasants -= 4;
        factionsRef.militia -= 2;
        const loss = Math.max(1, Math.floor(((deficits.grain || 0) + (deficits.livestock || 0)) / 120));
        adjustPopulation("peasants", -loss, stateRef);
    } else if (prodGrain > consGrain) {
        countyRef.food = clamp(countyRef.food + 3);
        factionsRef.peasants += 1;
    }

    if (textileShortage) {
        factionsRef.burghers -= 3;
        countyRef.happy = clamp(countyRef.happy - 2);
    } else if (prodTextiles > consTextiles) {
        factionsRef.burghers += 1;
    }

    if (luxuryShortage) {
        factionsRef.nobility -= 3;
        factionsRef.merchants -= 2;
        countyRef.happy = clamp(countyRef.happy - 3);
    } else if (prodLuxuries > consLuxuries) {
        factionsRef.nobility += 1;
        factionsRef.merchants += 1;
        const delta = Math.max(0, Math.floor((prodLuxuries - consLuxuries) / 200));
        if (delta) adjustPopulation("merchants", delta, stateRef);
    }

    if (arcaneShortage) {
        factionsRef.mystics -= 3;
        factionsRef.clergy -= 1;
        countyRef.health = clamp(countyRef.health - 4);
    } else if (prodArcane > consArcane) {
        factionsRef.mystics += 1;
        countyRef.health = clamp(countyRef.health + 2);
    }

    if (goldShortage) {
        countyRef.happy = clamp(countyRef.happy - 2);
        factionsRef.merchants -= 3;
        factionsRef.burghers -= 2;
    }

    factionOrder.forEach(f => factionsRef[f] = clamp(factionsRef[f]));
}

function formatResourceReport(obj) {
    const entries = Object.entries(obj)
        .filter(([, value]) => value && value !== 0)
        .map(([key, value]) => `${resourceLabels[key] || key}:${value}`);
    return entries.length ? entries.join(", ") : "nessuno";
}

function diffResources(start, end) {
    const result = {};
    RESOURCE_KEYS.forEach(key => {
        const endVal = (end && end[key] !== undefined) ? end[key] : 0;
        const startVal = (start && start[key] !== undefined) ? start[key] : 0;
        result[key] = endVal - startVal;
    });
    return result;
}

function diffFactions(start, end) {
    const result = {};
    const keys = new Set([...(Object.keys(start || {})), ...(Object.keys(end || {}))]);
    keys.forEach(key => {
        const endVal = (end && end[key] !== undefined) ? end[key] : 0;
        const startVal = (start && start[key] !== undefined) ? start[key] : 0;
        result[key] = endVal - startVal;
    });
    return result;
}

function formatResourceDelta(delta) {
    const entries = Object.entries(delta)
        .filter(([, val]) => val !== 0)
        .map(([key, val]) => `${resourceLabels[key] || key}:${val > 0 ? "+" + val : val}`);
    return entries.length ? entries.join(", ") : "nessuna variazione";
}

function formatFactionDelta(delta) {
    const entries = Object.entries(delta)
        .filter(([, val]) => val !== 0)
        .map(([key, val]) => `${key}:${val > 0 ? "+" + val : val}`);
    return entries.length ? entries.join(", ") : "stabili";
}

function simulateEconomyTurns(turns = 5) {
    const simState = captureGameState();
    ensureWorldSystems(simState);
    const startResources = cloneResourceBag(simState.county.resources);
    const startFactions = JSON.parse(JSON.stringify(simState.factions));

    for (let i = 0; i < turns; i++) {
        advanceSeason(simState, { silent:true });
        applyProduction(simState, { silent:true });
        processVillageEconomy(simState, { silent:true });
        collectTaxes(simState, { silent:true });
        applySeasonalUpkeep(simState, { silent:true });
    }

    const resourceDelta = diffResources(startResources, simState.county.resources);
    const factionDelta = diffFactions(startFactions, simState.factions);

    addMsg("system", `📊 Simulazione ${turns} turni — Risorse: ${formatResourceDelta(resourceDelta)} | Fazioni: ${formatFactionDelta(factionDelta)}`);
}


/* ============================================================
   ======================= COSTRUZIONI =========================
   ============================================================ */

// Chiamata da parte dell’IA (parte 6 la utilizzerà)
function startBuilding(data) {
    const type = data.type;
    const name = buildingData[type].name;

    // COSTI
    const cost = data.cost;
    if (!hasResources(cost)) {
        addMsg("ai", `❌ Mancano le risorse per costruire ${name}.`);
        return;
    }

    payResources(cost);

    buildings.push({
        id: crypto.randomUUID(),
        type: type,
        x: data.x,
        y: data.y,
        owner: "count",
        turns_left: data.turns,
        condition: 100,
        stage: "building",
        resources_needed: cost
    });

    addMsg("ai", `🏗️ Avviata la costruzione di <b>${name}</b> in (${data.x}, ${data.y}). Sarà completata in ${data.turns} turni.`);
}

function hasResources(cost) {
    for (let k in cost) {
        // Controllo Valuta
        if (k === 'gold' || k === 'oro') {
            if ((county.gold || 0) < cost[k]) return false;
        } 
        // Controllo Materiali
        else {
            if ((county.resources[k] || 0) < cost[k]) return false;
        }
    }
    return true;
}

function payResources(cost) {
    for (let k in cost) {
        // 1. GESTIONE DELL'ORO (assumendo sia la chiave 'gold' o 'oro' e sia in county.gold)
        if (k === 'gold' || k === 'oro') {
            if (county.gold !== undefined) {
                county.gold -= cost[k]; // Sottrae dal Tesoro separato
            }
        } 
        // 2. GESTIONE DELLE ALTRE RISORSE (legno, pietra, etc.)
        else if (county.resources[k] !== undefined) {
            county.resources[k] -= cost[k]; // Sottrae dal contenitore generico
        }
    }
}


function registerNewStructure(collectionKey, production, sourceBuilding, typeLabel = null) {
    if (!structures[collectionKey]) structures[collectionKey] = [];
    const entry = {
        x: sourceBuilding.x,
        y: sourceBuilding.y,
        owner: sourceBuilding.owner || "count",
        type: typeLabel || collectionKey,
        condition: 100,
        workers: rand(6, 14),
        production: production
    };
    structures[collectionKey].push(entry);
    updateIndustrySummary();
}

function processBuildings() {
    buildings.forEach(b => {
        if (b.stage === "building") {

            b.turns_left--;

            if (b.turns_left <= 0) {
                b.stage = "complete";
                addMsg("ai", `🏰 L'edificio <b>${buildingName(b.type)}</b> è stato completato!`);
                applyBuildingEffects(b);
            } else {
                maybeConstructionEvent(b);
            }
        }
    });
}


/* ============================================================
   ================== EVENTI DURANTE COSTRUZIONI ===============
   ============================================================ */

function maybeConstructionEvent(b) {
    if (Math.random() < 0.15) {
        const txt = constructionEventText(b.type);
        addMsg("ai", txt);
        b.turns_left += rand(1, 2); // ritardo lavori
    }
}

function constructionEventText(type) {
    switch(type) {
        case "forge": return "⛓️ Un apprendista si è ferito: la Forgia subirà un ritardo.";
        case "harbor": return "🌊 Una tempesta ha danneggiato i lavori del Porto.";
        case "watchtower": return "🏚️ Una sezione della Torre di Guardia è crollata.";
        case "mercenary_camp": return "⚔️ I mercenari hanno iniziato una rissa, lavori sospesi.";
        case "market": return "💰 Dispute tra mercanti hanno rallentato la costruzione del Mercato.";
        case "monk_clinic": return "🙏 I monaci attendono nuove erbe: lavori rallentati.";
        case "sawmill": return "🌲 Le inondazioni hanno bloccato il cantiere della segheria.";
        case "stone_quarry": return "🪨 Cedimenti nel terreno rallentano lo scavo della cava.";
        case "iron_mine": return "⛏️ Falda instabile: servono puntelli aggiuntivi.";
        case "mint": return "💰 Difetti negli stampi delle monete hanno fermato la zecca.";
        case "barracks": return "⚔️ Reclute indisciplinate rallentano l'addestramento.";
    }
}


/* ============================================================
   ================== EFFETTI EDIFICI COMPLETATI ===============
   ============================================================ */

function applyBuildingEffects(b) {
    // --- Helper per registrare strutture produttive ---
    const addStructure = (listKey, production, label) => {
        registerNewStructure(listKey, production, b, label);
        addMsg("system", `⚙️ Produzione avviata: una nuova ${b.name} è operativa.`);
    };

    switch(b.type) {
        // --- AGRICOLTURA & SOPRAVVIVENZA ---
        case "village_well":
            county.health = clamp(county.health + 8);
            factions.peasants += 5;
            break;
        case "wheat_field":
            // Aggiungiamo una "farm" generica alla lista delle strutture
            // Nota: usiamo 'farms' se hai una lista generica, o creiamo un hook
            // Se non hai una lista 'farms' in 'structures', modifichiamo direttamente le risorse base
            // Per semplicità qui aumentiamo la produzione base del territorio se non c'è una struttura specifica
            county.food = clamp(county.food + 10); 
            factions.peasants += 5;
            addMsg("system", "🌾 I nuovi campi aumentano la sicurezza alimentare.");
            break;
        case "dairy_farm":
            county.food = clamp(county.food + 5);
            factions.peasants += 3;
            // Simuliamo produzione aggiuntiva
            if(!county.resources.livestock) county.resources.livestock = 0;
            break;
        case "granary":
            county.security = clamp(county.security + 2);
            // Logica custom: protegge dalla carestia invernale (gestito narrativamente o in eventi futuri)
            factions.peasants += 4;
            break;

        // --- ECONOMIA ---
        case "market":
            county.happy = clamp(county.happy + 8);
            factions.merchants += 8;
            county.gold += 15; // Bonus immediato commercio
            break;
        case "harbor":
            factions.merchants += 10;
            factions.nobility += 2;
            county.gold += 50;
            break;
        case "mint":
            county.gold += 100; // Riserva immediata
            factions.merchants += 5;
            factions.nobility += 2;
            break;
        
        // --- PRODUZIONE RISORSE (STRUTTURE REALI) ---
        case "sawmill":
            addStructure("sawmills", { wood: rand(30, 60) }, "Segheria");
            break;
        case "stone_quarry":
            addStructure("quarries", { stone: rand(25, 50) }, "Cava");
            break;
        case "iron_mine":
            addStructure("mines", { iron: rand(30, 60), copper: rand(10, 20) }, "Miniera");
            break;

        // --- MILITARE ---
        case "watchtower":
            factions.militia += 5;
            county.security = clamp(county.security + 5);
            neighboringCounties.forEach(c => c.aggression = Math.max(0, c.aggression - 8));
            break;
        case "barracks":
            factions.militia += 8;
            adjustPopulation("militia", 10); // Più reclute
            county.security = clamp(county.security + 10);
            break;
        case "mercenary_camp":
            factions.militia += 5;
            factions.clergy -= 5;
            county.security = clamp(county.security + 15); // Molto sicuri ma costosi
            break;
        case "forge":
            factions.burghers += 6;
            factions.militia += 4;
            break;
        case "stone_walls":
            county.security = 100; // Massima sicurezza
            factions.nobility += 10;
            factions.burghers += 5;
            neighboringCounties.forEach(c => c.aggression = Math.max(0, c.aggression - 20));
            addMsg("system", "🛡️ Le mura sono completate! La contea è ora una fortezza.");
            break;

        // --- FEDE ---
        case "chapel":
            factions.clergy += 5;
            county.happy = clamp(county.happy + 3);
            break;
        case "church":
            factions.clergy += 10;
            county.happy = clamp(county.happy + 6);
            county.health = clamp(county.health + 2);
            addStructure("monasteries", { herbs: rand(2,5) }, "Chiesa"); // Produce piccola quantità fede/erbe
            break;
        case "grand_cathedral":
            factions.clergy = 100; // Estasi religiosa
            factions.nobility += 15;
            county.happy = clamp(county.happy + 15);
            addMsg("system", "🔔 Le campane della Cattedrale suonano per la prima volta. Un giorno storico!");
            break;
        case "monk_clinic":
            county.health = clamp(county.health + 15);
            factions.clergy += 8;
            break;

        // --- ISTRUZIONE & SOCIALE ---
        case "school":
            factions.burghers += 10;
            factions.mystics += 5;
            // Simuliamo efficienza: riduce sprechi
            county.gold += 20; 
            break;
        case "library":
            factions.mystics += 15;
            factions.clergy -= 2; // Rivalità sul sapere
            addMsg("system", "📚 La biblioteca attira saggi da ogni dove.");
            break;
        case "theater":
            county.happy = clamp(county.happy + 12);
            factions.nobility += 5;
            factions.peasants += 5;
            break;

        // --- ABITAZIONI ---
        case "cottage":
            adjustPopulation("peasants", 50);
            factions.peasants += 5;
            break;
        case "tenement":
            adjustPopulation("burghers", 150);
            factions.burghers += 10;
            county.health = clamp(county.health - 5);
            break;
        case "noble_estate":
            adjustPopulation("nobility", 20);
            factions.nobility += 10;
            county.happy = clamp(county.happy + 10);
            break;
            
        default:
            addMsg("system", `Costruzione di ${b.type} completata.`);
    }

    // Aggiornamento finale UI e Fazioni
    factionOrder.forEach(f => factions[f] = clamp(factions[f]));
    updateUI();
}


/* ============================================================
   ========== STRUTTURE EVENTI RANDOM (MINIERE, ECC.) ==========
   ============================================================ */

function triggerStructureEvents(options = {}) {
    const { skipUI = false } = options;

    // Crollo miniere
    structures.mines.forEach(m => {
        if (Math.random() < 0.02) {
            m.condition -= 30;
            addMsg("ai", `💥 Crollo nella miniera (${m.x},${m.y}): feriti e produzione ridotta.`);
            county.pop -= rand(1,4);
        }
    });

    // Incendio Segherie
    structures.sawmills.forEach(s => {
        if (Math.random() < 0.015) {
            s.condition -= 40;
            addMsg("ai", `🔥 Incendio nella segheria (${s.x},${s.y}): perdita di legno.`);
            county.resources.wood = Math.max(0, county.resources.wood - rand(20,60));
        }
    });

    // Frane Cave
    structures.quarries.forEach(q => {
        if (Math.random() < 0.01) {
            q.condition -= 20;
            addMsg("ai", `🪨 Frana nella cava (${q.x},${q.y}): lavori sospesi.`);
        }
    });

    // Miracoli Monasteri
    structures.monasteries.forEach(m => {
        if (Math.random() < 0.02) {
            addMsg("ai", `✨ I monaci di (${m.x},${m.y}) hanno guarito dei malati.`);
            county.health = clamp(county.health + 5);
        }
    });

    if (!skipUI) updateUI();
}


/* ============================================================
   =================== EFFETTI SULLE FAZIONI ===================
   ============================================================ */

function structureFactionEffect() {

    structures.mines.forEach(() => {
        factions.nobility += 1;
        factions.militia += 1;
        factions.peasants -= 1;
    });

    structures.sawmills.forEach(() => {
        factions.merchants += 1;
        factions.commons += 1;
        factions.mystics -= 1;
    });

    structures.quarries.forEach(() => {
        factions.burghers += 1;
        factions.nobility -= 1;
    });

    structures.monasteries.forEach(() => {
        factions.clergy += 1;
        factions.merchants -= 1;
    });

    factionOrder.forEach(f => factions[f] = clamp(factions[f]));
}


/* ============================================================
   ==================== CHAT PRIVATA ===========================
   ============================================================ */

function openPrivateChat(key) {
    activePrivateChat = key;
    document.getElementById("private-chat-box").style.display = "block";
    document.getElementById("private-chat-title").innerText =
        "Colloquio con " + getChatName(key);

    loadPrivateChat();
    
    // Se aperto dal modal matrimonio, chiudi il modal e vai alla tab private
    if (document.getElementById("modal-marriage").classList.contains("active")) {
        closeMarriageModal();
        const privateBtn = document.querySelector('.nav-btn[onclick*="tab-private"]');
        switchTab('tab-private', privateBtn);
    }
}

function closePrivateChat() {
    const key = activePrivateChat;
    const factionName = getChatName(key);

    // Nascondi UI
    activePrivateChat = null;
    document.getElementById("private-chat-box").style.display = "none";

    addMsg("system", `Il colloquio con ${factionName} è terminato. Il Conte riflette sulle richieste...`);

    // PROMPT SPECIFICO PER GENERARE AZIONI DI GIOCO
    // Chiediamo all'IA di tradurre la chiacchierata in meccaniche di gioco (Costruzioni, Leggi, ecc.)
    const promptAction = `
    Ho appena finito un colloquio privato con ${factionName} (${factionLabel(key)}).
    
    Basandoti sulla logica del gioco (dove posso costruire edifici come Mercati, Mura, Chiese o promulgare Leggi):
    1. Riassumi in una frase cosa voleva la fazione.
    2. Proponi 3 azioni di gioco concrete che posso fare ora per accontentarli o punirli.
    
    USA IL FORMATO AZIONI STANDARD:
    - **[Nome Azione]**: [Descrizione effetto]
    `;

    callGroq(promptAction, "action");
}

function getChatName(key) {
    const map = {
        nobility:"Lord Emeric (Nobiltà)",
        clergy:"Vescovo Aldebrando (Clero)",
        militia:"Capitano Ronan (Milizia)",
        peasants:"Odric (Contadini)",
        burghers:"Maestro Bernard (Artigiani)",
        merchants:"Ser Lothar (Mercanti)",
        mystics:"Madre Elowen (Mistici)",
        outcasts:"Rasko (Emarginati)",
        auvrey:"Messo di Auvrey",
        falken:"Ambasciatrice di Falken"
    };
    return map[key] || key;
}

function loadPrivateChat() {
    const log = document.getElementById("private-chat-log");
    log.innerHTML = "";
    privateChats[activePrivateChat].forEach(m => addPrivateMsg(m.from, m.text));
}

function addPrivateMsg(type, text) {
    const log = document.getElementById("private-chat-log");
    const div = document.createElement("div");
    div.className = `msg msg-${type}`;
    const time = timestamp();
    div.innerHTML = `<div class="msg-text">${text}</div><div class="msg-meta">${time}</div>`;
    log.appendChild(div);
    log.scrollTop = log.scrollHeight;
}

function sendPrivate() {
    const input = document.getElementById("private-input");
    const text = input.value.trim();
    if (!text) return;
    input.value = "";

    privateChats[activePrivateChat].push({ from:"user", text:text });
    addPrivateMsg("user", text);

    // Call IA (parte 6 gestisce privateDialog)
    callGroqPrivate(activePrivateChat, text);
}


/* ============================================================
   ==================== AGGIORNAMENTO UI =======================
   ============================================================ */

function clearInterfaceLogs() {
    const chatLog = document.getElementById("chat-log");
    if (chatLog) chatLog.innerHTML = "";

    const eventFeed = document.getElementById("event-feed");
    if (eventFeed) eventFeed.innerHTML = '<p class="event-empty">Nessun evento registrato.</p>';

    const adviceFeed = document.getElementById("advice-feed");
    if (adviceFeed) adviceFeed.innerHTML = '<p class="advice-empty">Nessun consiglio registrato.</p>';

    const actionList = document.getElementById("action-list");
    if (actionList) actionList.innerHTML = '<p class="action-empty">Nessuna proposta al momento.</p>';

    const actionPrompt = document.getElementById("action-prompt");
    if (actionPrompt) actionPrompt.innerText = "In attesa di nuovi suggerimenti dalla corte.";
}

function updateUI() {
    ensureWorldSystems();
    const summary = updateIndustrySummary();
    document.getElementById("visual-desc").innerText = `"${county.desc}"`;

    // Dentro updateUI()...
    
    const capacity = calculateHousingCapacity();
    const popColor = county.pop > capacity ? "#ff7c7c" : "#fff"; // Rosso se sovraffollato
    
    // Aggiorna il testo della popolazione indicando anche la capacità
    document.getElementById("val-pop").innerHTML = `
        <span style="color:${popColor}">${county.pop}</span> 
        <span style="font-size:0.6em; color:#888;">/ ${capacity} cap.</span>
    `;
    
    // ... resto della funzione

    document.getElementById("val-gold").innerText = county.gold;

    updateBar("food", county.food);
    updateBar("health", county.health);
    updateBar("happy", county.happy);
    updateBar("stability", calculateStability());

    document.getElementById("land-count").innerText = landOwnership.count;
    document.getElementById("land-nobility").innerText = landOwnership.nobility;
    document.getElementById("land-clergy").innerText = landOwnership.clergy;
    document.getElementById("land-commons").innerText = landOwnership.commons;

    // Aggiorna classi sociali con ricchezza
    if (document.getElementById("nobility-count") && populationGroups) {
        document.getElementById("nobility-count").innerText = populationGroups.nobility?.count || 0;
        document.getElementById("nobility-wealth").innerText = (populationGroups.nobility?.wealth || 0) + "💰";
        document.getElementById("clergy-count").innerText = populationGroups.clergy?.count || 0;
        document.getElementById("clergy-wealth").innerText = (populationGroups.clergy?.wealth || 0) + "💰";
        document.getElementById("militia-count").innerText = populationGroups.militia?.count || 0;
        document.getElementById("militia-wealth").innerText = (populationGroups.militia?.wealth || 0) + "💰";
        document.getElementById("burghers-count").innerText = populationGroups.burghers?.count || 0;
        document.getElementById("burghers-wealth").innerText = (populationGroups.burghers?.wealth || 0) + "💰";
        document.getElementById("peasants-count").innerText = populationGroups.peasants?.count || 0;
        document.getElementById("peasants-wealth").innerText = (populationGroups.peasants?.wealth || 0) + "💰";
        document.getElementById("mystics-count").innerText = populationGroups.mystics?.count || 0;
        document.getElementById("mystics-wealth").innerText = (populationGroups.mystics?.wealth || 0) + "💰";
        document.getElementById("outcasts-count").innerText = populationGroups.outcasts?.count || 0;
        document.getElementById("outcasts-wealth").innerText = (populationGroups.outcasts?.wealth || 0) + "💰";
        document.getElementById("merchants-count").innerText = populationGroups.merchants?.count || 0;
        document.getElementById("merchants-wealth").innerText = (populationGroups.merchants?.wealth || 0) + "💰";
    }

    updateResourceUI();
    updateDiplomacyUI();
    updateFactionImpactUI();
    renderFactionChips();
    updateAssetSummaryUI(summary);
    renderTaxGrid();
    renderLawList();
    updateTaxSummary();
    updateSeasonUI();

    // Update HUD stats
    const season = getSeason();
    document.getElementById('hud-season').textContent = `${season.label} ${worldTime.year}`;
    document.getElementById('hud-gold').textContent = county.gold;
    document.getElementById('hud-pop').textContent = `${county.pop} / ${capacity}`;
    document.getElementById('hud-happy').textContent = county.happy;
    document.getElementById('hud-security').textContent = county.security;

    const turnTag = document.getElementById("chat-turn");
    if (turnTag) turnTag.innerText = `Turno ${county.turn}`;

    updateConstructionUI();
    renderResourceStats();
    renderMarket();
}

function updateDiplomacyUI() {
    neighboringCounties.forEach(c => {
        document.getElementById(`rel-${c.key}`).innerText = c.relations;
        document.getElementById(`pow-${c.key}`).innerText = c.power;
        document.getElementById(`agg-${c.key}`).innerText = c.aggression;
        document.getElementById(`land-${c.key}`).innerText = c.land;
    });
}

function requestTradeMeeting(neighborKey) {
    const neighbor = neighboringCounties.find(c => c.key === neighborKey);
    if (!neighbor) return;

    // Costo diplomatico: oro e possibile calo relazioni se rifiuto
    const cost = 20;
    if (county.gold < cost) {
        addMsg("system", "Non hai abbastanza oro per organizzare un incontro diplomatico.");
        return;
    }

    county.gold -= cost;
    addMsg("system", `Hai inviato un emissario alla ${neighbor.name} per discutere accordi commerciali. Costo: ${cost} oro.`);

    // Simula risposta basata su relazioni
    const successChance = Math.min(90, neighbor.relations + 20); // Base 20% + relazioni
    const success = rand(1, 100) <= successChance;

    setTimeout(() => {
        if (success) {
            neighbor.tradeAgreement = true;
            neighbor.relations = Math.min(100, neighbor.relations + rand(5, 15));
            addMsg("system", `🎉 Successo! La ${neighbor.name} accetta l'accordo commerciale. I prezzi nel mercato sono ora ridotti e puoi accedere alle loro merci speciali.`);
        } else {
            neighbor.relations = Math.max(0, neighbor.relations - rand(5, 10));
            addMsg("system", `❌ La ${neighbor.name} rifiuta l'incontro. Le relazioni si deteriorano leggermente.`);
        }
        updateUI();
        renderMarket();
    }, 2000); // Ritardo per simulare il tempo dell'incontro
}

// Sistema di domanda/offerta basato sulle categorie sociali
function calculateMarketDemand() {
    const demand = createEmptyResourceBag();
    const supply = createEmptyResourceBag();
    
    // Nobiltà: domanda lusso, offerta poco
    demand.luxuries += populationGroups.nobility.count * 2;
    demand.arcane += populationGroups.nobility.count * 1;
    
    // Clero: domanda cibo e beni sacri, offerta spirituale
    demand.grain += populationGroups.clergy.count * 3;
    demand.textiles += populationGroups.clergy.count * 1;
    
    // Militia: domanda armi e cibo, offerta protezione
    demand.iron += populationGroups.militia.count * 2;
    demand.grain += populationGroups.militia.count * 4;
    
    // Peasants: offerta cibo e materie prime, domanda beni essenziali
    supply.grain += populationGroups.peasants.count * 1;
    supply.wood += populationGroups.peasants.count * 0.5;
    supply.stone += populationGroups.peasants.count * 0.3;
    demand.textiles += populationGroups.peasants.count * 0.5;
    
    // Burghers: domanda lusso moderato, offerta artigianato
    demand.luxuries += populationGroups.burghers.count * 1;
    supply.textiles += populationGroups.burghers.count * 2;
    supply.iron += populationGroups.burghers.count * 1;
    
    // Merchants: domanda tutto, offerta commercio
    Object.keys(demand).forEach(key => {
        demand[key] += populationGroups.merchants.count * 0.5;
    });
    
    // Mystics: domanda arcane, offerta mistica
    demand.arcane += populationGroups.mystics.count * 3;
    
    // Outcasts: offerta lavoro, domanda sopravvivenza
    supply.wood += populationGroups.outcasts.count * 0.5;
    demand.grain += populationGroups.outcasts.count * 2;
    
    return { demand, supply };
}

// Mobilità sociale
function processSocialMobility() {
    // Borghesi che diventano ricchi -> nobili
    if (populationGroups.burghers.wealth > 200 && populationGroups.burghers.count > 10) {
        const promotions = Math.min(2, Math.floor(populationGroups.burghers.count / 20));
        populationGroups.burghers.count -= promotions;
        populationGroups.nobility.count += promotions;
        populationGroups.nobility.wealth += promotions * 100;
        addMsg("system", `📈 ${promotions} borghesi sono diventati nobili grazie alla loro ricchezza!`);
    }
    
    // Nobili che cadono in disgrazia -> borghesi o outcasts
    if (populationGroups.nobility.wealth < 100 && populationGroups.nobility.count > 5) {
        const demotions = Math.min(1, Math.floor(populationGroups.nobility.count / 10));
        populationGroups.nobility.count -= demotions;
        populationGroups.burghers.count += demotions;
        populationGroups.burghers.wealth += demotions * 50;
        addMsg("system", `📉 ${demotions} nobili sono caduti in disgrazia e sono diventati borghesi.`);
    }
}

/* ===================== FIX DEMOGRAFIA SICURA ===================== */

// Helper per modificare la popolazione senza andare sotto zero o rompere i dati
function safeAdjustPop(groupKey, amount) {
    if (!populationGroups[groupKey]) return 0;
    
    const current = populationGroups[groupKey].count;
    
    // Se stiamo sottraendo (morte/emigrazione)
    if (amount < 0) {
        // Non uccidere mai gli ultimi 10 sopravvissuti (Safeguard anti-estinzione)
        const safeMinimum = 10; 
        const maxLoss = Math.max(0, current - safeMinimum);
        // Applica la perdita ma non oltre il massimo possibile
        const actualLoss = Math.min(Math.abs(amount), maxLoss);
        populationGroups[groupKey].count -= actualLoss;
        return -actualLoss; // Ritorna la variazione reale
    } 
    // Se stiamo aggiungendo (nascita)
    else {
        populationGroups[groupKey].count += amount;
        return amount;
    }
}

// Eventi demografici
function processDemographicEvents() {
    const events = [];
    let totalDeaths = 0;
    let totalBirths = 0;

    // 1. NASCITE (Basate su felicità e cibo)
    // Solo se c'è cibo a sufficienza
    if (county.food > county.pop * 0.8) { 
        const fertilePop = (populationGroups.peasants.count || 0) + (populationGroups.burghers.count || 0);
        // Tasso di natalità moderato (1% - 3%)
        const birthRate = Math.max(0.01, Math.min(0.03, county.happy / 100 * 0.03)); 
        const births = Math.floor(fertilePop * birthRate);
        
        if (births > 0) {
            safeAdjustPop("peasants", births);
            totalBirths += births;
            events.push(`👶 ${births} nuove nascite.`);
        }
    }

    // 2. MORTI (Fame, Malattie, Vecchiaia)
    // Fame: Se il cibo è sotto il 40% del fabbisogno
    if (county.food < county.pop * 0.4) {
        const severity = 1 - (county.food / (county.pop * 0.4)); // 0.0 a 1.0
        // Max 10% di morti per fame per turno (per evitare estinzione istantanea)
        const deathRate = severity * 0.10; 
        
        const peasantDeaths = Math.floor(populationGroups.peasants.count * deathRate);
        const outcastDeaths = Math.floor(populationGroups.outcasts.count * deathRate);
        
        const d1 = safeAdjustPop("peasants", -peasantDeaths);
        const d2 = safeAdjustPop("outcasts", -outcastDeaths);
        
        if ((d1 + d2) < 0) events.push(`💀 Carestia: ${Math.abs(d1+d2)} morti di fame.`);
        totalDeaths += Math.abs(d1+d2);
    }

    // Malattie (Randomico + Salute)
    if (Math.random() < 0.15 && county.health < 50) {
        const plagueSeverity = (50 - county.health) / 200; // Max 25%
        const deaths = Math.floor(county.pop * plagueSeverity);
        
        // Distribuisci le morti (colpisce più i poveri)
        const d1 = safeAdjustPop("peasants", -Math.floor(deaths * 0.6));
        const d2 = safeAdjustPop("outcasts", -Math.floor(deaths * 0.2));
        const d3 = safeAdjustPop("burghers", -Math.floor(deaths * 0.1));
        const d4 = safeAdjustPop("militia", -Math.floor(deaths * 0.1));

        const actualDeaths = Math.abs(d1+d2+d3+d4);
        if (actualDeaths > 0) events.push(`🦠 Epidemia: ${actualDeaths} vittime.`);
        totalDeaths += actualDeaths;
    }

    // Vecchiaia naturale (Tasso fisso basso 0.5%)
    const naturalRate = 0.005;
    Object.keys(populationGroups).forEach(key => {
        const deaths = Math.floor(populationGroups[key].count * naturalRate);
        safeAdjustPop(key, -deaths);
    });

    // Aggiorna il totale "county.pop" sommando i gruppi reali
    // Questo impedisce al sistema di "perdere il conto"
    recomputePopulation();

    // Mostra eventi solo se significativi
    events.forEach(e => addMsg("system", e));
}

// Sistema di delinquenza basato sulla soddisfazione
function processCrimeAndStability() {
    const events = [];
    
    // Calcola livello di delinquenza basato su felicità, cibo e salute
    const happinessFactor = (100 - county.happy) / 100; // Più felice = meno crimine
    const foodFactor = Math.max(0, (county.pop * 0.5 - county.food) / (county.pop * 0.5)); // Più fame = più crimine
    const healthFactor = (100 - county.health) / 100; // Più malattie = più crimine
    
    const crimeLevel = (happinessFactor + foodFactor + healthFactor) / 3; // Media dei fattori
    const crimeRate = Math.min(0.15, crimeLevel * 0.1); // Max 15% di crimine
    
    if (crimeRate > 0.05) { // Solo se crimine significativo
        // Effetti del crimine
        const crimeIncidents = Math.floor(county.pop * crimeRate);
        const goldLost = Math.floor(crimeIncidents * 2); // Ogni crimine costa ~2 oro
        const stabilityLoss = Math.floor(crimeLevel * 10); // Perdita stabilità
        
        county.gold = Math.max(0, county.gold - goldLost);
        county.happy = Math.max(0, county.happy - stabilityLoss);
        
        events.push(`🚔 ${crimeIncidents} incidenti criminali! Perdita di ${goldLost}💰 e stabilità ridotta.`);
    }
    
    // Mostra eventi criminali
    events.forEach(event => addMsg("system", event));
}

// Sistema di emigrazione
function processEmigration() {
    // Calcolo rischio emigrazione
    const happinessFactor = (100 - county.happy) / 100;
    const foodFactor = Math.max(0, (county.pop * 0.5 - county.food) / (county.pop * 0.5));
    
    // Rischio medio
    const risk = (happinessFactor + foodFactor) / 2;
    
    // Emigrano solo se il rischio è alto (>40%)
    if (risk > 0.4) {
        const rate = Math.min(0.05, risk * 0.1); // Max 5% della pop
        const totalEmigrants = Math.floor(county.pop * rate);
        
        if (totalEmigrants > 0) {
            const e1 = safeAdjustPop("peasants", -Math.floor(totalEmigrants * 0.6));
            const e2 = safeAdjustPop("burghers", -Math.floor(totalEmigrants * 0.3));
            const e3 = safeAdjustPop("outcasts", -Math.floor(totalEmigrants * 0.1));
            
            const actualEmigrants = Math.abs(e1+e2+e3);
            
            if (actualEmigrants > 0) {
                addMsg("system", `🏃 ${actualEmigrants} abitanti hanno abbandonato la contea.`);
                recomputePopulation(); // Ricalcola subito
            }
        }
    }
}

// Calcola livello di stabilità sociale
function calculateStability() {
    // La stabilità è inversamente proporzionale alla delinquenza
    const happinessFactor = county.happy / 100; // Più felice = più stabile
    const foodFactor = Math.min(1, county.food / (county.pop * 0.5)); // Più cibo = più stabile
    const healthFactor = county.health / 100; // Più salute = più stabile
    const housingFactor = Math.min(1, calculateHousingCapacity() / county.pop); // Più spazio = più stabile
    
    const stability = (happinessFactor + foodFactor + healthFactor + housingFactor) / 4;
    return Math.floor(stability * 100);
}

// Aggiorna ricchezze delle categorie
function updateCategoryWealth() {
    // Nobiltà: guadagna da tasse e proprietà
    populationGroups.nobility.wealth += Math.floor(county.gold * 0.1);
    
    // Clero: guadagna da donazioni e decime
    populationGroups.clergy.wealth += Math.floor(county.gold * 0.05);
    
    // Merchants: guadagnano dal commercio
    populationGroups.merchants.wealth += seasonalTransactions.marketSales * 0.1;
    
    // Peasants: guadagnano dalla produzione agricola
    const grainProduction = county.resources.grain || 0;
    populationGroups.peasants.wealth += Math.floor(grainProduction * 0.01);
    
    // Militia: stipendio fisso
    populationGroups.militia.wealth += populationGroups.militia.count * 2;
    
    // Previeni ricchezze negative
    Object.keys(populationGroups).forEach(key => {
        populationGroups[key].wealth = Math.max(0, populationGroups[key].wealth);
    });
}

function ensureNeighborResources(countyRef) {
    if (!countyRef.resources) {
        countyRef.resources = {
            grain: rand(80, 160),
            wood: rand(60, 120),
            stone: rand(50, 110),
            iron: rand(30, 80),
            gold: rand(40, 120),
            textiles: rand(20, 60)
        };
    }
    return countyRef.resources;
}

function simulateNeighborEconomy(countyRef, options = {}) {
    const { silent = false } = options;
    ensureNeighborResources(countyRef);
    const production = {
        grain: Math.max(20, Math.floor(countyRef.land * 1.2 + rand(5, 20))),
        wood: Math.max(10, Math.floor(countyRef.land * 0.8 + rand(4, 12))),
        stone: Math.max(6, Math.floor(countyRef.land * 0.5 + rand(2, 8))),
        iron: Math.max(4, Math.floor(countyRef.power * 0.4 + rand(1, 6))),
        textiles: Math.max(3, Math.floor(countyRef.wealth * 0.25 + rand(1, 4)))
    };
    const consumption = {
        grain: Math.max(25, Math.floor(countyRef.power * 0.6 + rand(5, 15))),
        wood: Math.max(12, Math.floor(countyRef.land * 0.6 + rand(3, 10))),
        stone: Math.max(8, Math.floor(countyRef.land * 0.4 + rand(1, 6))),
        iron: Math.max(6, Math.floor(countyRef.power * 0.25 + rand(0, 4))),
        gold: Math.max(10, Math.floor(countyRef.wealth * 0.3 + rand(2, 8))),
        textiles: Math.max(4, Math.floor(countyRef.wealth * 0.2 + rand(1, 4)))
    };

    Object.entries(production).forEach(([key, value]) => {
        countyRef.resources[key] = (countyRef.resources[key] || 0) + value;
    });

    const deficits = [];
    Object.entries(consumption).forEach(([key, value]) => {
        const current = countyRef.resources[key] || 0;
        const final = current - value;
        if (final < 0) {
            deficits.push(key);
            countyRef.resources[key] = 0;
        } else {
            countyRef.resources[key] = final;
        }
    });

    if (deficits.length) {
        countyRef.wealth = clamp((countyRef.wealth || 50) - deficits.length * 2);
        countyRef.relations = Math.max(0, countyRef.relations - deficits.length * 2);
        countyRef.aggression = Math.min(100, countyRef.aggression + deficits.length * 3);
        if (!silent) {
            addMsg("system", `🌫️ ${countyRef.name} è in crisi (${deficits.join(", ")}). Le relazioni peggiorano.`);
        }
    } else {
        countyRef.wealth = clamp((countyRef.wealth || 50) + 1);
        countyRef.relations = Math.min(100, countyRef.relations + 1);
        countyRef.aggression = Math.max(0, countyRef.aggression - 1);
        if (!silent && Math.random() < 0.15) {
            addMsg("system", `${countyRef.name} registra un avanzo commerciale e potrebbe cercare accordi.`);
        }
    }

    if (countyRef.aggression > 80 && !silent) {
        addMsg("system", `⚠️ ${countyRef.name} accumula truppe al confine: l'economia li spinge alla guerra.`);
    }

    countyRef.lastEconomy = { production, consumption, deficits };
}

function processNeighborEconomies(options = {}) {
    const { silent = false } = options;
    neighboringCounties.forEach(neigh => simulateNeighborEconomy(neigh, { silent }));
}

function updateBar(id,val){
    const bar = document.getElementById(`bar-${id}`);
    const txt = document.getElementById(`txt-${id}`);
    bar.style.width = val + "%";
    txt.innerText = val + "%";
}


/* ============================================================
   ==================== INVIO MESSAGGI PUBBLICI =================
   ============================================================ */

function progressSeason(options = {}) {
    const { silent = false } = options;
    ensureWorldSystems();
    county.turn++;
    
    const turnTag = document.getElementById("chat-turn");
    if (turnTag) turnTag.innerText = `Anno ${worldTime.year} - ${getSeason().label}`;

    // Snapshot Iniziale
    const startSnapshot = captureResourceSnapshot();
    const startGold = county.gold;
    const startHappy = county.happy;
    const budget = calculateSeasonalBudget();

    // Reset transazioni stagionali
    seasonalTransactions = {
        marketPurchases: 0,
        marketSales: 0,
        specialPurchases: 0,
        taxes: 0,
        maintenance: 0
    };

    // --- ELABORAZIONE TURNO ---
    advanceSeason(null, { silent: true }); // Stagione avanza silenziosamente
    
    processLifeEvents(); // <--- AGGIUNGI QUESTA RIGA QUI!
    
    applyProduction(null, { skipUI: true, silent: true }); // Produzione silenziosa
    
    // Calcolo Economia Villaggio
    const economyReport = processVillageEconomy(null, { skipUI: true, silent: true });
    
    // Tasse e Manutenzione
    const taxesCollected = collectTaxes(null, { silent: true });
    seasonalTransactions.taxes += taxesCollected;
    applySeasonalUpkeep(null, { silent: true });
    const maintenanceCost = budget.expenses.structures;
    seasonalTransactions.maintenance += maintenanceCost;
    county.gold = Math.max(0, county.gold - maintenanceCost);
    if (county.gold === 0 && budget.expenses.structures > 0) {
        addMsg("system", "⚠️ Mancanza di fondi per la manutenzione delle strutture! Alcuni edifici potrebbero deteriorarsi.");
    }
    
    // Eventi vari
    processBuildings();
    triggerStructureEvents({ skipUI: true });
    structureFactionEffect();
    processNeighborEconomies({ silent: true });

    // Snapshot Finale & Delta
    const endSnapshot = captureResourceSnapshot();
    lastResourceDelta = computeResourceDelta(startSnapshot, endSnapshot);
    lastResourceSnapshot = cloneResourceBag(endSnapshot);
    const goldDelta = county.gold - startGold;
    const happyDelta = county.happy - startHappy;

    updateUI();
    autoSaveGame();

    if (!silent) {
        // 1. RAPPOSTO DEL CIAMBELLANO (Messaggio unico di sistema pulito)
        let reportHTML = `<strong>📅 Rapporto Stagionale:</strong><br>`;
        
        // Risorse principali cambiate
        const significantChanges = Object.entries(lastResourceDelta)
            .filter(([k,v]) => Math.abs(v) > 0)
            .map(([k,v]) => `${resourceLabels[k] || k}: ${v>0?'+':''}${v}`)
            .join(", ");
            
        reportHTML += `<span style="opacity:0.8">${significantChanges || "Nessuna variazione di risorse."}</span><br>`;
        reportHTML += `💰 Tesoreria: <strong>${county.gold}</strong> (${goldDelta > 0 ? '+'+goldDelta : goldDelta})`;
        
        // Breakdown dettagliato delle entrate/uscite
        const totalIncome = seasonalTransactions.taxes;
        const totalExpenses = seasonalTransactions.maintenance + seasonalTransactions.marketPurchases + seasonalTransactions.specialPurchases;
        const netMarket = seasonalTransactions.marketSales - seasonalTransactions.marketPurchases - seasonalTransactions.specialPurchases;
        
        reportHTML += `<br><small style="opacity:0.7">`;
        reportHTML += `Entrate: Tasse +${seasonalTransactions.taxes}`;
        reportHTML += ` | Uscite: Manutenzione -${seasonalTransactions.maintenance}`;
        if (seasonalTransactions.marketPurchases > 0) reportHTML += `, Acquisti -${seasonalTransactions.marketPurchases}`;
        if (seasonalTransactions.specialPurchases > 0) reportHTML += `, Merci speciali -${seasonalTransactions.specialPurchases}`;
        if (seasonalTransactions.marketSales > 0) reportHTML += `, Vendite +${seasonalTransactions.marketSales}`;
        reportHTML += `</small>`;
        
        // Aggiungi deficit critici se ci sono
        const deficitKeys = Object.keys(economyReport.deficits || {});
        if (deficitKeys.length > 0) {
            reportHTML += `<br><span style="color:#ff7c7c">⚠️ CARENZE CRITICHE: ${deficitKeys.map(k=>resourceLabels[k]).join(", ")}</span>`;
        }

        addMsg("system", reportHTML);

        // 2. LA CORTE SI RIUNISCE (Interazione Fazioni)
        // Invece di messaggi casuali, l'IA o il sistema scelgono UN evento principale
        triggerCourtEvent({ 
            economy: economyReport, 
            goldDelta, 
            happyDelta, 
            deficits: economyReport.deficits 
        });

        // 3. NOTIZIE DAL MONDO ESTERNO
        const worldNarration = generateWorldNarration();
        if (worldNarration) {
            addMsg("system", worldNarration);
        }
    }
}

// =======================================
// CREA IL BLOCCO AZIONI IN CHAT
// =======================================
function appendActionsBlock(actions) {
    const chatLog = document.getElementById("chat-log");
    const box = document.createElement("div");
    box.classList.add("msg-actions");

    const header = document.createElement("div");
    header.classList.add("action-header");
    header.textContent = "Azioni possibili";
    box.appendChild(header);

    actions.forEach(a => {
        const btn = document.createElement("button");
        btn.classList.add("action-card");
        btn.innerHTML = a.label;
        btn.onclick = () => executeAction(a.code);
        box.appendChild(btn);
    });

    chatLog.appendChild(box);
    chatLog.scrollTop = chatLog.scrollHeight;
}

// =======================================
// ESEGUI L'AZIONE SCELTA
// =======================================
function executeAction(action) {
    console.log("Azione selezionata:", action);
    let userMessage = "";

    if (action.startsWith("build_")) {
        const type = action.split("_")[1];
        orderBuilding(type);
        const b = buildingData[type];
        userMessage = `Ho ordinato la costruzione di ${b.name}.`;
    } else if (action === "emergency_tax_merchants") {
        county.gold += 50;
        factions.burghers = Math.max(0, factions.burghers - 10);
        addMsg("system", "💰 Tassa straordinaria imposta ai mercanti: +50 oro, ma la loro lealtà cala.");
        updateUI();
        userMessage = "Ho imposto una tassa straordinaria ai mercanti per riempire le casse.";
    } else if (action === "emergency_tax_church") {
        county.gold += 30;
        factions.clergy = Math.max(0, factions.clergy - 15);
        addMsg("system", "⛪ Beni requisiti alla Chiesa: +30 oro, ma i religiosi sono infuriati.");
        updateUI();
        userMessage = "Ho requisito beni alla Chiesa per finanziare il regno.";
    } else if (action === "open_law_modal") {
        document.getElementById("modal-law-creator").classList.add("active");
        userMessage = "Voglio creare una nuova legge per il regno.";
    } else if (action === "recruit_militia") {
        county.militia = (county.militia || 0) + 10;
        county.gold -= 20;
        addMsg("system", "🎖️ Reclutati 10 uomini per la milizia: -20 oro.");
        updateUI();
        userMessage = "Ho reclutato nuovi uomini per la milizia.";
    } else {
        userMessage = action; // Fallback
    }

    // Dopo l'azione, fai reagire l'IA
    if (userMessage) {
        addMsg("user", userMessage);
        callGroq(userMessage, "action");
    }
}

function generateWorldNarration() {
    let narration = `<strong>🌍 Notizie dal Mondo Esterno:</strong><br>`;

    neighboringCounties.forEach(c => {
        const relationLevel = c.relations > 70 ? "alleate" : c.relations > 40 ? "neutra" : "ostile";
        const activity = c.aggression > 50 ? "prepara incursioni" : c.power > county.power * 1.2 ? "rafforza le difese" : "commercia pacificamente";

        narration += `${c.name} (${relationLevel}): ${c.description.split('.')[0]}. Attualmente ${activity}.<br>`;
    });

    // Aggiungi eventi casuali mondiali
    if (rand(0, 10) > 7) {
        const events = [
            "Banditi infestano le strade tra le contee, rallentando i commerci.",
            "Una carestia colpisce regioni lontane, aumentando la domanda di grano.",
            "Alleanze matrimoniali si formano tra nobili delle contee vicine."
        ];
        narration += `<em>${events[Math.floor(Math.random() * events.length)]}</em>`;
    }

    return narration;
}

function advanceSeasonManually() {
    addMsg("system", "➡️ Il Conte ordina di passare alla stagione successiva.");
    progressSeason({ silent:false });
}

function send() {
    ensureWorldSystems();
    const input = document.getElementById("u-input");
    const text = input.value.trim();
    if (!text) return;

    input.value = "";
    if (text === "/avanza") {
        advanceSeasonManually();
        return;
    }

    addMsg("user", text);

    // Ora IA (parte 6)
    callGroq(text, "action");
}

function timestamp() {
    return new Date().toLocaleTimeString("it-IT", {
        hour: "2-digit",
        minute: "2-digit"
    });
}

function addMsg(type, text) {
    const log = document.getElementById("chat-log");
    const div = document.createElement("div");

    // Gestione speciale per i messaggi delle fazioni (Riconosciuti dal nome in grassetto all'inizio)
    // L'IA tende a rispondere "Lord Emeric: ..." -> Lo intercettiamo
    if (type === 'ai' && text.includes(':')) {
        const parts = text.split(':');
        const possibleName = parts[0].trim().replace(/\*/g, ''); // Rimuovi bold markdown
        
        // Cerca se il nome corrisponde a una fazione
        let foundFaction = null;
        const factionNamesMap = {
            "Lord Emeric": "nobility", "Vescovo Aldebrando": "clergy", 
            "Capitano Ronan": "militia", "Odric": "peasants", 
            "Maestro Bernard": "burghers", "Ser Lothar": "merchants",
            "Madre Elowen": "mystics", "Rasko": "outcasts"
        };
        
        // Match parziale del nome
        for(let name in factionNamesMap) {
            if (possibleName.includes(name) || possibleName.includes(name.split(" ")[1])) {
                foundFaction = factionNamesMap[name];
                break;
            }
        }

        if (foundFaction) {
            // Renderizza come Card Fazione
            div.className = `msg-faction ${foundFaction}`;
            div.innerHTML = `
                <div class="faction-avatar">${FACTION_ICONS[foundFaction] || '👤'}</div>
                <span class="faction-title">${possibleName}</span>
                <div class="msg-text">${parts.slice(1).join(':').trim()}</div>
            `;
            log.appendChild(div);
            log.scrollTop = log.scrollHeight;
            return;
        }
    }

    // Fallback standard
    if (type === "system") {
        div.className = "msg-system";
        div.innerHTML = text; // Permetti HTML per il report
    } else {
        div.className = `msg msg-${type}`;
        div.innerHTML = `<div class="msg-text">${text}</div><div class="msg-meta">${timestamp()}</div>`;
    }
    
    log.appendChild(div);
    log.scrollTop = log.scrollHeight;
}

function addEventCard(text) {
    if (!text) return;
    const feed = document.getElementById("event-feed");
    if (!feed) return;

    const emptyState = feed.querySelector(".event-empty");
    if (emptyState) emptyState.remove();

    const card = document.createElement("div");
    card.className = "event-card";
    card.innerHTML = `
        <div class="event-time">${timestamp()}</div>
        <div class="msg-text">${text}</div>
    `;

    feed.prepend(card);

    const cards = feed.querySelectorAll(".event-card");
    if (cards.length > 8) {
        feed.removeChild(feed.lastElementChild);
    }
}

function addAdviceCard(text) {
    if (!text) return;
    const feed = document.getElementById("advice-feed");
    if (!feed) return;

    const emptyState = feed.querySelector(".advice-empty");
    if (emptyState) emptyState.remove();

    const card = document.createElement("div");
    card.className = "event-card";
    card.innerHTML = `
        <div class="event-time">${timestamp()}</div>
        <div class="msg-text">${text}</div>
    `;

    feed.prepend(card);

    const cards = feed.querySelectorAll(".event-card");
    if (cards.length > 6) {
        feed.removeChild(feed.lastElementChild);
    }
}

function renderActionSuggestions(actions, promptText = "Scegli un'azione proposta dalla corte.") {
    const list = document.getElementById("action-list");
    const promptEl = document.getElementById("action-prompt");
    if (!list || !promptEl) return;

    promptEl.innerText = promptText || "Scegli un'azione proposta dalla corte.";
    list.innerHTML = "";

    if (!actions.length) {
        promptEl.innerText = "In attesa di nuovi suggerimenti dalla corte.";
        list.innerHTML = '<p class="action-empty">Nessuna proposta al momento.</p>';
        return;
    }

    actions.forEach(action => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "action-card";
        btn.innerHTML = `<strong>${action.title}</strong><span>${action.desc}</span>`;
        btn.addEventListener("click", () => {
            const input = document.getElementById("u-input");
            if (!input) return;
            input.value = action.command || action.title;
            input.focus();
        });
        list.appendChild(btn);
    });
}

function extractActionsFromText(text) {
    const lower = text.toLowerCase();
    const idx = lower.indexOf("ecco le azioni");
    if (idx === -1) {
        return { remainingText: text, actions: [], prompt: "" };
    }

    const actionBlock = text.slice(idx).trim();
    const promptLineMatch = actionBlock.match(/^[^\n]+/);
    let prompt = promptLineMatch ? promptLineMatch[0].trim() : "Scegli un'azione proposta dalla corte.";
    const questionMatch = actionBlock.match(/Quale azione[^\n]*/i);
    if (questionMatch) prompt = questionMatch[0].trim();

    const listText = actionBlock.replace(/^[^\n]+\n?/, "").trim();
    const regex = /- \*\*(.+?)\*\*:([\s\S]*?)(?=\n- \*\*|$)/g;
    const actions = [];
    let match;
    while ((match = regex.exec(listText)) !== null) {
        actions.push({
            title: match[1].trim(),
            desc: match[2].replace(/\s+/g, " ").trim(),
            command: match[1].trim()
        });
    }

    return {
        remainingText: text.slice(0, idx).trim(),
        actions,
        prompt
    };
}

function askAdvisor() {
    // 1. Feedback visivo immediato nella chat principale
    addMsg("system", "🧠 Il Conte ha convocato Ser Dorian per un consulto privato...");

    // 2. Costruzione contesto
    let problems = [];
    if (county.gold < 100) problems.push("siamo poveri");
    if (county.food < 50) problems.push("c'è poca cibo");
    if (county.security < 40) problems.push("i confini sono deboli");
    
    const context = problems.length 
        ? `Mio signore, ${problems.join(", ")}. Dobbiamo agire.` 
        : "La situazione è stabile, ma possiamo sempre migliorare.";

    // 3. Chiamata API con modalità 'advice'
    // Nota: usiamo un prompt specifico per evitare conflitti con la chat
    const prompt = `
    ${context}
    Analizza la situazione attuale (Anno ${worldTime.year}, ${getSeason().label}) e dammi 2 consigli strategici brevi e diretti.
    `;
    
    callGroq(prompt, "advice");
}

function openBudgetModal() {
    const modal = document.getElementById("modal-budget");
    if (modal) {
        renderBudget();
        modal.classList.add("active");
    }
}

function closeBudgetModal() {
    const modal = document.getElementById("modal-budget");
    if (modal) modal.classList.remove("active");
}

function renderBudget() {
    const budget = calculateSeasonalBudget();
    const container = document.getElementById("budget-content");
    if (!container) return;

    const s = (v) => (Number.isFinite(v) ? Math.round(v) : 0);
    const taxes = s(budget.income && budget.income.taxes);
    const production = s(budget.income && budget.income.production);
    const incomeTotal = s(budget.income && budget.income.total);
    const structuresCost = s(budget.expenses && budget.expenses.structures);
    const militaryCost = s(budget.expenses && budget.expenses.military);
    const expensesTotal = s(budget.expenses && budget.expenses.total);
    const net = s(budget.net);

    container.innerHTML = `
        <div class="budget-section">
            <h3>Entrate</h3>
            <div class="budget-row money-plus">
                <span>Tasse: +${taxes} oro</span>
            </div>
            <div class="budget-row money-plus">
                <span>Produzione: +${production} oro</span>
            </div>
            <div class="budget-total money-plus">
                Totale Entrate: ${incomeTotal} oro
            </div>
        </div>
        <div class="budget-section">
            <h3>Uscite</h3>
            <div class="budget-row money-minus">
                <span>Strutture: -${structuresCost} oro</span>
            </div>
            <div class="budget-row money-minus">
                <span>Militare: -${militaryCost} oro</span>
            </div>
            <div class="budget-total money-minus">
                Totale Uscite: ${expensesTotal} oro
            </div>
        </div>
        <div class="budget-net ${net >= 0 ? 'money-plus' : 'money-minus'}">
            <strong>Netto: ${net >= 0 ? '+'+net : net} oro</strong>
        </div>
    `;
}

</script>
<script>

/* ============================================================
   ========================= GROQ ENGINE ========================
   ============================================================ */

async function callGroq(userText, mode="action") {

    if (!ensureApiKey()) {
        addMsg("system", "🔐 Inserisci una chiave API.");
        activateScreen("screen-login");
        return;
    }

    // 1. Costruiamo il prompt di sistema aggiornato con le statistiche attuali
    const promptData = buildPrompt(userText, mode);

    // 2. Aggiorniamo la storia della chat
    // Aggiungiamo il messaggio dell'utente alla memoria
    publicChatHistory.push({ role: "user", content: userText });

    // Manteniamo la memoria pulita (ultimi 12 messaggi per non consumare troppi token)
    if (publicChatHistory.length > 12) {
        publicChatHistory = publicChatHistory.slice(-12);
    }

    // 3. Prepariamo il pacchetto completo per l'IA
    // [ISTRUZIONI SISTEMA] + [STORICO CONVERSAZIONE]
    const apiMessages = [
        { role: "system", content: promptData.system },
        ...publicChatHistory
    ];

    try {
        const resp = await fetch("https://api.groq.com/openai/v1/chat/completions", {
            method: "POST",
            headers: {
                "Content-Type":"application/json",
                "Authorization":"Bearer " + apiKey
            },
            body: JSON.stringify({
                model: "llama-3.1-8b-instant",
                temperature: 0.7, // Un po' più basso per mantenere coerenza logica
                messages: apiMessages
            })
        });

        const data = await resp.json();
        if (!resp.ok) throw new Error(data.error?.message || 'API Error');

        const aiMsg = data.choices[0].message.content;

        // 4. Aggiungiamo la risposta dell'IA alla memoria
        // (Così al prossimo turno si ricorderà cosa ha risposto)
        publicChatHistory.push({ role: "assistant", content: aiMsg });

        // 5. Passiamo il testo al parser grafico
        handleAIResponse(aiMsg, mode);

    } catch(e) {
        addMsg("system", "⚠️ Errore Corte: " + e);
        // In caso di errore, rimuoviamo l'ultimo messaggio utente per non bloccare la logica
        publicChatHistory.pop();
    }
}


function getChatName(key) {
    // Gestione nomi standard
    const map = {
        nobility:"Lord Emeric", clergy:"Vescovo Aldebrando",
        militia:"Capitano Ronan", peasants:"Odric",
        burghers:"Maestro Bernard", merchants:"Ser Lothar",
        mystics:"Madre Elowen", outcasts:"Rasko",
        spouse: dynasty.spouse ? dynasty.spouse.name : "Consorte",
        auvrey:"Messo di Auvrey", falken:"Ambasciatrice Falken"
    };
    
    // Gestione dinamica Eredi
    if (key.startsWith('heir_')) {
        const idx = parseInt(key.split('_')[1]);
        return dynasty.heirs[idx] ? dynasty.heirs[idx].name : "Erede";
    }

    // Gestione dinamica Pretendenti (Chat pre-matrimonio)
    if (key.startsWith('suitor_')) {
        const idx = parseInt(key.split('_')[1]);
        return activeSuitorsList[idx] ? activeSuitorsList[idx].name : "Pretendente";
    }

    return map[key] || key;
}

function buildPrivatePrompt(factionKey, userText) {
    let systemPrompt = "";
    const name = getChatName(factionKey);
    const currentStats = generateKingdomSummary();

    // Istruzioni base per il parsing
    const logicInstructions = `
    REGOLE FONDAMENTALI DI COMPORTAMENTO:
    1. Sei un personaggio vivo, non un assistente.
    2. Valuta il tono dell'utente:
       - Se è gentile/adulatorio: Aumenta relazione.
       - Se è offensivo/inappropriato: Diminuisci relazione.
    3. FORMATO RISPOSTA (Obbligatorio):
       Scrivi la tua risposta discorsiva (dialogo).
       ALLA FINE, su una nuova riga, aggiungi SOLO questo tag tecnico invisibile all'utente:
       [REL: +X] o [REL: -X] (dove X è un numero da 1 a 10 in base all'impatto della frase).
       Se la conversazione sembra finita o in stallo, aggiungi anche: [STATUS: END].
    `;

    // --- 1. CASO CONSORTE ---
    if (factionKey === 'spouse' && dynasty.spouse) {
        systemPrompt = `
        Sei ${name}, consorte del Conte.
        ${logicInstructions}
        Il tuo obiettivo è proteggere la famiglia e i tuoi interessi di origine (${dynasty.spouse.originLabel}).
        Sii affettuoso ma esigente.
        `;
    }
    
    // --- 2. CASO PRETENDENTE (Corteggiamento) ---
    else if (factionKey.startsWith('suitor_')) {
        const idx = parseInt(factionKey.split('_')[1]);
        const suitor = activeSuitorsList[idx];
        
        systemPrompt = `
        Sei ${suitor.name}, un nobile che vuole sposare il Conte.
        Attuale Relazione: ${suitor.relation}/100.
        ${logicInstructions}
        
        OBIETTIVO: Farti sposare.
        Se la relazione supera 80, sii molto disponibile al matrimonio.
        Se è bassa, sii diffidente.
        `;
    }

    // --- 3. CASO FAZIONE STANDARD ---
    else {
        systemPrompt = `
        Sei ${name}. Rappresenti la tua fazione (${factionLabel(factionKey)}).
        Attuale Lealtà: ${factions[factionKey] || 50}.
        ${logicInstructions}
        Se il conte promette aiuto alla tua fazione, alza la relazione.
        `;
    }

    return { system: systemPrompt, user: userText };
}

/* ==================== CHAT PRIVATA ==================== */

async function callGroqPrivate(factionKey, userText) {

    if (!ensureApiKey()) {
        addPrivateMsg("system", "🔐 Chiave API mancante.");
        return;
    }

    const promptData = buildPrivatePrompt(factionKey, userText);
    
    // Recupera storico (assicurati che privateChats[factionKey] esista)
    if (!privateChats[factionKey]) privateChats[factionKey] = [];
    const history = privateChats[factionKey].slice(-6).map(msg => ({
        role: msg.from === "user" ? "user" : "assistant",
        content: msg.text // Nota: qui salviamo il testo pulito
    }));

    const apiMessages = [
        { role: "system", content: promptData.system },
        ...history,
        { role: "user", content: promptData.user }
    ];

    try {
        const resp = await fetch("https://api.groq.com/openai/v1/chat/completions", {
            method:"POST",
            headers:{
                "Content-Type":"application/json",
                "Authorization":"Bearer " + apiKey
            },
            body: JSON.stringify({
                model: "llama-3.1-8b-instant",
                temperature: 0.8,
                messages: apiMessages
            })
        });

        const data = await resp.json();
        if (!resp.ok) throw new Error('API Error');

        let rawMsg = data.choices[0].message.content;
        
        // --- PARSING DELLA RISPOSTA ---
        let cleanMsg = rawMsg;
        let relChange = 0;
        let suggestedEnd = false;

        // 1. Estrai cambio relazione [REL: +/-X]
        const relMatch = rawMsg.match(/\[REL:\s*([+-]?\d+)\]/i);
        if (relMatch) {
            relChange = parseInt(relMatch[1]);
            cleanMsg = cleanMsg.replace(relMatch[0], ""); // Rimuovi dal testo visibile
        }

        // 2. Estrai status fine [STATUS: END]
        if (rawMsg.includes("[STATUS: END]")) {
            suggestedEnd = true;
            cleanMsg = cleanMsg.replace("[STATUS: END]", "");
        }

        cleanMsg = cleanMsg.trim();

        // --- APPLICAZIONE EFFETTI ---
        if (relChange !== 0) {
            applyPrivateRelationChange(factionKey, relChange);
        }

        // Salvataggio e Display
        privateChats[factionKey].push({ from:"ai", text: cleanMsg });
        addPrivateMsg("ai", cleanMsg);

        // Se l'IA suggerisce di chiudere o se c'è un cambio relazione, mostra feedback
        if (relChange !== 0) {
            const sign = relChange > 0 ? "+" : "";
            const color = relChange > 0 ? "#6ada91" : "#ff7c7c";
            addPrivateMsg("system", `<span style="color:${color}">Rapporto ${sign}${relChange}</span>`);
        }

        if (suggestedEnd) {
            showPrivateActions(factionKey); // Mostra bottoni azione finale
        }

    } catch(e) {
        addPrivateMsg("system", "⚠️ Errore comunicazione: " + e);
    }
}


// Funzione helper per applicare i cambiamenti matematici
function applyPrivateRelationChange(key, delta) {
    // Caso Pretendente
    if (key.startsWith('suitor_')) {
        const idx = parseInt(key.split('_')[1]);
        const suitor = activeSuitorsList[idx];
        if (suitor) {
            suitor.relation = Math.max(0, Math.min(100, suitor.relation + delta));
            // Aggiorna UI se necessario (es. ricarica modale se aperto)
        }
    }
    // Caso Fazione / Personaggio Standard
    else {
        // Mappa chiave chat -> chiave fazione
        const map = {
            nobility:"nobility", clergy:"clergy", militia:"militia", 
            peasants:"peasants", burghers:"burghers", merchants:"merchants", 
            mystics:"mystics", outcasts:"outcasts"
        };
        
        // Se stiamo parlando con Lord Emeric (nobility), aggiorna la fazione nobility
        const factionKey = map[key] || key; // Fallback se la chiave è già quella giusta
        if (factions[factionKey] !== undefined) {
            factions[factionKey] = Math.max(0, Math.min(100, factions[factionKey] + delta));
        }
    }
}

function showPrivateActions(key) {
    const log = document.getElementById("private-chat-log");
    const actionsDiv = document.createElement("div");
    actionsDiv.className = "msg-actions";
    actionsDiv.style.marginTop = "15px";

    let html = `<div class="action-header">Concludi Colloquio</div>`;

    // Azioni Comuni
    html += `<button class="btn-sec" onclick="endPrivateChat('${key}', 'bye')">👋 Congeda / Arrivederci</button>`;

    // Azioni Specifiche per Pretendenti
    if (key.startsWith('suitor_')) {
        const idx = parseInt(key.split('_')[1]);
        const suitor = activeSuitorsList[idx];
        
        if (suitor.relation >= 60) {
             html += `<button class="btn-main" onclick="endPrivateChat('${key}', 'marry')">💍 Proponi Matrimonio</button>`;
        } else {
             html += `<button class="btn-sec" disabled style="opacity:0.5">💍 Proponi Matrimonio (Rapporto insufficiente)</button>`;
        }
        
        html += `<button class="btn-sec" onclick="giveGiftToSuitor(${idx})">🎁 Invia Regalo (+Relazione)</button>`;
    }

    actionsDiv.innerHTML = html;
    log.appendChild(actionsDiv);
    log.scrollTop = log.scrollHeight;
}

function endPrivateChat(key, action) {
    const log = document.getElementById("private-chat-log");
    
    if (action === 'bye') {
        addPrivateMsg("user", "Arrivederci.");
        setTimeout(() => {
            addPrivateMsg("system", "Il colloquio è terminato.");
            closePrivateChat();
        }, 800);
    }
    
    if (action === 'marry') {
        const idx = parseInt(key.split('_')[1]);
        addPrivateMsg("user", "Vuoi unire la tua casata alla mia?");
        setTimeout(() => {
            marrySuitorIndex(idx); // Funzione esistente
            closePrivateChat();
        }, 1000);
    }
}

/* ============================================================
   ======================= SUPER PROMPT =========================
   ============================================================ */

function getFeasibleActions() {
    const actions = [];
    const poor = county.gold < 50;

    // 1. Lista edifici costruibili con le risorse attuali
    const buildable = Object.entries(buildingData).filter(([key, data]) => {
        // Controllo rapido risorse (semplificato per il prompt)
        return county.gold >= data.cost.gold;
    });

    if (buildable.length > 0) {
        // Prendiamone 3 a caso per non intasare il prompt
        const examples = buildable.sort(() => 0.5 - Math.random()).slice(0, 3);
        examples.forEach(b => {
            actions.push(`COSTRUIRE ${b[1].name} (Costo: ${b[1].cost.gold} oro)`);
        });
    } else {
        actions.push("NESSUNA COSTRUZIONE POSSIBILE (Risorse insufficienti)");
    }

    // 2. Opzioni di emergenza se poveri
    if (poor) {
        actions.push("CHIEDERE AIUTO: Tassa straordinaria ai Mercanti (+ Oro, - Lealtà)");
        actions.push("CHIEDERE AIUTO: Requisire beni alla Chiesa (+ Oro, - Lealtà)");
    }

    return actions.join("\n- ");
}

function getDynamicActions(response = "") {
    const actions = [];
    const lowerResponse = response.toLowerCase();

    // Collega alla narrazione: aggiungi azioni basate su ciò che l'IA ha detto
    if (lowerResponse.includes("costruzione") || lowerResponse.includes("edificio") || lowerResponse.includes("costruire")) {
        // Edifici costruibili
        const buildable = Object.entries(buildingData).filter(([key, data]) => {
            return checkResources(data.cost);
        });

        buildable.slice(0, 3).forEach(([key, data]) => {  // Limita a 3
            const effects = [];
            if (data.effect) effects.push(data.effect);
            if (data.housing) effects.push(`+${data.housing} alloggi`);
            effects.push(`Lealtà contadini +5`);
            const effectDesc = effects.join(", ");
            actions.push({
                label: `🏗️ Costruisci ${data.name} (${data.cost.gold} oro) - ${effectDesc}`,
                code: `build_${key}`
            });
        });
    }

    if (lowerResponse.includes("oro") || lowerResponse.includes("tesoro") || lowerResponse.includes("soldi") || lowerResponse.includes("povero")) {
        if (county.gold < 50) {
            actions.push({
                label: "💰 Tassa straordinaria ai Mercanti - +50 oro, lealtà mercanti -10, felicità generale -2",
                code: "emergency_tax_merchants"
            });
            actions.push({
                label: "⛪ Requisire beni alla Chiesa - +30 oro, lealtà chiesa -15, morale nobili -3",
                code: "emergency_tax_church"
            });
        }
    }

    if (lowerResponse.includes("legge") || lowerResponse.includes("decreto") || lowerResponse.includes("regola")) {
        actions.push({
            label: "📜 Crea una nuova legge - Personalizza effetti su tasse, produzione o fazioni",
            code: "open_law_modal"
        });
    }

    if (lowerResponse.includes("milizia") || lowerResponse.includes("soldati") || lowerResponse.includes("sicurezza") || lowerResponse.includes("banditi")) {
        actions.push({
            label: "🎖️ Convoca la milizia - +10 milizia, sicurezza +5, -20 oro, lealtà contadini -2",
            code: "recruit_militia"
        });
    }

    return actions;
}

function generateKingdomSummary() {
    const s = []; // Array di stringhe per il sommario
    
    // 1. TEMPO E RICCHEZZA
    s.push(`Siamo nell'Anno ${worldTime.year}, durante la stagione di ${getSeason().label}.`);
    
    if (county.gold < 50) s.push("Le casse reali sono quasi vuote (CRISI ECONOMICA).");
    else if (county.gold > 500) s.push("Il regno è prospero e ricco.");
    
    // 2. STATO SOCIALE (Cibo e Salute)
    if (county.food < 25) s.push("⚠ GRAVE CARESTIA: Il popolo muore di fame.");
    else if (county.food < 50) s.push("Le scorte di cibo scarseggiano.");
    
    if (county.health < 30) s.push("⚠ PESTILENZA: La malattia si diffonde tra i vicoli.");
    if (county.security < 30) s.push("⚠ INSICUREZZA: I banditi scorrazzano impuniti.");

    // 3. FAZIONI (Chi ti odia?)
    const enemies = Object.entries(factions)
        .filter(([key, val]) => val < 35)
        .map(([key]) => factionLabel(key));
    
    if (enemies.length > 0) {
        s.push(`Fazioni ostili che tramano nell'ombra: ${enemies.join(", ")}.`);
    }

    // 4. EDIFICI IMPORTANTI (Cosa vede il Conte?)
    const majorBuildings = buildings
        .filter(b => b.stage === 'complete')
        .map(b => buildingData[b.type].name);
    
    if (majorBuildings.length > 0) {
        s.push(`Infrastrutture completate: ${majorBuildings.join(", ")}.`);
    }

    // 5. LEGGI ATTIVE
    if (activeLaws.length > 0) {
        const lawsNames = activeLaws.map(key => getLawDefinition(key).name);
        s.push(`Leggi in vigore: ${lawsNames.join(", ")}.`);
    }

    return s.join("\n");
}

function buildPrompt(userText, mode) {
    // 1. Calcola le azioni fattibili (economicamente)
    const feasibleOptions = getFeasibleActions();

    // 2. Genera il RIASSUNTO DEL REGNO (Memoria contestuale)
    const kingdomContext = generateKingdomSummary();

    // 3. Costruisci il System Prompt
    const systemText = `
SEI IL "MOTORE NARRATIVO" DI UN GIOCO DI GESTIONE MEDIEVALE.

=== RIASSUNTO DELLO STATO DEL REGNO (MEMORIA A LUNGO TERMINE) ===
${kingdomContext}
=================================================================

AMBIENTAZIONE: Sala della Corte.
RUOLI: L'Utente è il CONTE. Tu interpreti le FAZIONI e il NARRATORE.

OBIETTIVO:
Usa il "Riassunto del Regno" qui sopra per dare contesto. 
Esempio: Se c'è "GRAVE CARESTIA", i contadini devono implorare cibo e i nobili devono temere rivolte.

REGOLE FORMATTAZIONE (Output riga per riga):
- "SCENA: " -> Descrizione atmosferica.
- "NOME: " -> Dialogo personaggio.
- "AZIONI:" -> Lista opzioni finali.

AZIONI DA PROPORRE (Scegline 2 pertinenti):
${feasibleOptions}
`;

    return {
        system: systemText,
        user: userText
    };
}

function buildPrivatePrompt(factionKey, userText){
    const name = getChatName(factionKey);
    
    return {
        system: `
Tu sei ${name}. Non sei un'IA, sei un personaggio vivo in questo castello.
Parla in prima persona. Sii emotivo, manipolatore o servile in base alla tua lealtà (${factions[factionKey]}).
Usa dettagli sensoriali (la tua voce trema, batti il pugno sul tavolo, sussurri).

IMPORTANTE: Alla fine della tua risposta, se hai fatto una richiesta o esposto un problema, suggerisci implicitamente cosa dovrebbe fare il Conte (es. "Costruite quel mercato, mio signore, o moriremo di fame", "Firmate l'editto, ve ne prego").

Non usare liste puntate qui, usa solo il dialogo diretto.
`,
        user: userText
    };
}


/* ============================================================
   ======================== AI PARSING ==========================
   ============================================================ */

function handleAIResponse(response, mode) {
    // Rimuovi residui JSON
    response = response.replace(/\{[\s\S]*\}/g, "").trim();

    // ======================================================
    // 1. GESTIONE CONSIGLIERE (Barra Laterale)
    // ======================================================
    if (mode === "advice") {
        const feed = document.getElementById("advice-feed");
        if (!feed) return;

        // Rimuovi il messaggio "vuoto" se c'è
        const empty = feed.querySelector(".advice-empty");
        if (empty) empty.remove();

        // Crea la card del consiglio
        const card = document.createElement("div");
        card.className = "event-card";
        // Stile dorato specifico per Ser Dorian
        card.style.borderLeft = "3px solid #d4af37"; 
        card.style.background = "rgba(20, 20, 20, 0.9)";
        card.style.marginBottom = "8px";
        
        // Formattazione del testo (grassetto per i punti chiave)
        const formattedText = response.replace(/\*\*(.*?)\*\*/g, '<strong style="color:#d4af37">$1</strong>');

        card.innerHTML = `
            <div class="event-time" style="color:#666; font-size:0.7em; margin-bottom:4px;">${timestamp()} - Turno ${county.turn}</div>
            <div class="msg-text" style="font-size:0.9em; line-height:1.4;">${formattedText}</div>
        `;

        // Inserisci in cima
        feed.prepend(card);
        return; // <--- IMPORTANTE: Ferma qui la funzione!
    }

    // ======================================================
    // 2. GESTIONE CHAT PUBBLICA (Scene, Dialoghi, Azioni)
    // ======================================================
    
    const parts = response.split("AZIONI:");
    const scriptContent = parts[0].trim();
    const actionsContent = parts.length > 1 ? parts[1].trim() : "";
    const lines = scriptContent.split('\n').filter(line => line.trim() !== '');
    const chatLog = document.getElementById("chat-log");

    lines.forEach((line, index) => {
        setTimeout(() => {
            const cleanLine = line.trim();
            
            if (cleanLine.startsWith("SCENA:")) {
                const content = cleanLine.replace("SCENA:", "").trim();
                const div = document.createElement("div");
                div.className = "msg-scene";
                div.innerText = content;
                chatLog.appendChild(div);
            } 
            else if (cleanLine.includes(":")) {
                const splitIndex = cleanLine.indexOf(":");
                const name = cleanLine.substring(0, splitIndex).trim();
                const msg = cleanLine.substring(splitIndex + 1).trim();
                
                const div = document.createElement("div");
                div.className = "msg-char";
                div.innerHTML = `<span class="char-name">${name}</span><span class="char-text">${msg}</span>`;
                chatLog.appendChild(div);
            }
            else {
                const div = document.createElement("div");
                div.className = "msg-scene";
                div.innerText = cleanLine;
                chatLog.appendChild(div);
            }
            chatLog.scrollTop = chatLog.scrollHeight;

        }, index * 1200);
    });

    if (actionsContent) {
        setTimeout(() => {
            const { actions } = extractActionsFromRawText(actionsContent);
            
            const actionDiv = document.createElement("div");
            actionDiv.className = "msg-actions";
            actionDiv.innerHTML = `<div class="action-header">Ordini Disponibili</div>`;
            
            actions.forEach(act => {
                const btn = document.createElement("button");
                btn.className = "btn-sec";
                btn.style.width = "100%";
                btn.style.marginBottom = "5px";
                btn.style.textAlign = "left";
                btn.innerHTML = `<strong>${act.title}</strong>: ${act.desc}`;
                btn.onclick = () => {
                    document.getElementById("u-input").value = act.title;
                };
                actionDiv.appendChild(btn);
            });

            chatLog.appendChild(actionDiv);
            chatLog.scrollTop = chatLog.scrollHeight;
        }, lines.length * 1200 + 500);
    }

    // === BLOCCO DI AZIONI GENERATO IN AUTOMATICO ===
    setTimeout(() => {
        const dynamicActions = getDynamicActions(response);
        if (dynamicActions.length > 0) {
            appendActionsBlock(dynamicActions);
        }
    }, lines.length * 1200 + 1000);
}

function extractActionsFromRawText(text) {
    const actions = [];
    let remainingText = text;
    
    // Cerca righe che iniziano con "- **[title]**: desc"
    const actionRegex = /- \*\*\[([^\]]+)\]\*\*: (.+)/g;
    let match;
    while ((match = actionRegex.exec(text)) !== null) {
        const title = match[1].trim();
        const desc = match[2].trim();
        actions.push({ title, desc });
        remainingText = remainingText.replace(match[0], '').trim();
    }
    
    return { remainingText, actions };
}


/* ============================================================
   ============ GESTIONE SCHERMATE E AVVIO GIOCO ===============
   ============================================================ */

/* ============================================================
   =================== GRAFICA MAPPA "MEDIEVALE" ==============
   ============================================================ */

// Nuova Palette: Toni desaturati e naturali
const MEDIAEVAL_PALETTE = {
    paper: "#f4ecd8",         // Sfondo pergamena
    grid: "rgba(62, 39, 35, 0.1)", // Griglia stile matita leggera
    
    // Terreni
    plains: "#d8e2b6",        // Verde pallido / giallastro
    forest: "#8fac76",        // Verde salvia scuro
    hills: "#e6d6ad",         // Sabbia scura
    mountain: "#cfcfc4",      // Grigio pietra chiaro
    mountainPeak: "#8c8c8c",  // Grigio scuro per i picchi
    swamp: "#aeb58d",         // Verde marcio/grigiastro
    water: "#a4c4d6",         // Azzurro carta da zucchero
    waterDeep: "#89abbd",     // Dettagli acqua

    // Bordi proprietà
    borders: {
        count: "#d4af37",     // Oro
        nobility: "#8b0000",  // Rosso scuro inchiostro
        clergy: "#483d8b",    // Blu scuro ardesia
        commons: "#2f4f4f"    // Grigio ardesia scuro
    }
};

// Funzione per disegnare un "rumore" carta sopra la mappa
function drawPaperTexture(ctx, width, height) {
    const numGrains = (width * height) / 200; 
    ctx.fillStyle = "rgba(62, 39, 35, 0.03)";
    for (let i = 0; i < numGrains; i++) {
        const x = Math.random() * width;
        const y = Math.random() * height;
        const r = Math.random() * 2;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Disegna i dettagli specifici per ogni tipo di terreno
function drawTileVisuals(ctx, x, y, size, tile) {
    // 1. Sfondo base del tile
    ctx.fillStyle = MEDIAEVAL_PALETTE[tile.terrain] || "#fff";
    ctx.fillRect(x, y, size, size);

    // 2. Dettagli interni (Disegno a mano libera simulato)
    const cx = x + size / 2;
    const cy = y + size / 2;

    switch (tile.terrain) {
        case "forest":
            // Disegna 3 alberelli stilizzati (triangoli/cerchi)
            ctx.fillStyle = "#5e754a"; // Verde più scuro per le chiome
            drawTree(ctx, cx - 4, cy + 2, 3);
            drawTree(ctx, cx + 4, cy + 4, 4);
            drawTree(ctx, cx, cy - 4, 4);
            break;

        case "mountain":
            // Disegna un picco montuoso
            ctx.fillStyle = MEDIAEVAL_PALETTE.mountainPeak;
            ctx.beginPath();
            ctx.moveTo(x + 2, y + size - 2);
            ctx.lineTo(cx, y + 2);
            ctx.lineTo(x + size - 2, y + size - 2);
            ctx.fill();
            // Neve in cima
            ctx.fillStyle = "#fff";
            ctx.beginPath();
            ctx.moveTo(cx - 3, y + 10); // Punto sulla sinistra
            ctx.lineTo(cx, y + 2);      // Cima
            ctx.lineTo(cx + 3, y + 10); // Punto sulla destra
            ctx.fill();
            break;

        case "hills":
            // Disegna due curve morbide
            ctx.fillStyle = "#c2b280";
            ctx.beginPath();
            ctx.arc(cx - 3, cy + 4, 5, Math.PI, 0);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(cx + 3, cy + 2, 4, Math.PI, 0);
            ctx.fill();
            break;

        case "swamp":
            // Lineette orizzontali e colori scuri
            ctx.strokeStyle = "#6b705c";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + 4, y + size - 6); ctx.lineTo(x + 10, y + size - 6);
            ctx.moveTo(x + 12, y + 6); ctx.lineTo(x + 18, y + 6);
            ctx.moveTo(cx - 3, cy); ctx.lineTo(cx + 3, cy);
            ctx.stroke();
            break;

        case "lake":
        case "water":
            // Onde stilizzate
            ctx.strokeStyle = MEDIAEVAL_PALETTE.waterDeep;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(cx - 4, cy, 3, 0, Math.PI, false);
            ctx.arc(cx + 2, cy, 3, 0, Math.PI, false);
            ctx.stroke();
            break;
            
        case "plains":
            // Un piccolo ciuffo d'erba occasionale (non su tutti per pulizia)
            if ((x + y) % 3 === 0) {
                ctx.strokeStyle = "#889c6b";
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(cx, cy); ctx.lineTo(cx - 2, cy - 4);
                ctx.moveTo(cx, cy); ctx.lineTo(cx + 2, cy - 4);
                ctx.stroke();
            }
            break;
    }
}

function drawTree(ctx, x, y, r) {
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();
}

// Funzione Principale di Disegno Mappa
function drawCountyMap() {
    const canvas = document.getElementById("county-map");
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    
    // Assicura che worldMap sia caricato
    if (!worldMap || !worldMap.tiles || worldMap.tiles.length === 0) return;
    
    const tileSize = canvas.width / worldMap.width;

    // 1. Sfondo carta
    ctx.fillStyle = MEDIAEVAL_PALETTE.paper;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // 2. Disegna Terreno
    for (let y = 0; y < worldMap.height; y++) {
        for (let x = 0; x < worldMap.width; x++) {
            const tile = getTile(x, y);
            if (!tile) continue;
            drawTileVisuals(ctx, x * tileSize, y * tileSize, tileSize, tile);
        }
    }

    // 3. Texture Carta (Sopra il terreno, sotto l'UI)
    drawPaperTexture(ctx, canvas.width, canvas.height);

    // 4. Griglia leggera
    ctx.strokeStyle = MEDIAEVAL_PALETTE.grid;
    ctx.lineWidth = 0.5;
    ctx.beginPath();
    for (let i = 0; i <= worldMap.width; i++) {
        ctx.moveTo(i * tileSize, 0); ctx.lineTo(i * tileSize, canvas.height);
        ctx.moveTo(0, i * tileSize); ctx.lineTo(canvas.width, i * tileSize);
    }
    ctx.stroke();

    // 5. Bordi Proprietà (Stile inchiostro spesso)
    drawOwnershipBorders(ctx, tileSize);

    // 6. Strutture ed Edifici
    drawSettlements(ctx, tileSize);
    drawStructureMarkers(ctx, tileSize);
    
    // 7. Vignettatura finale
    drawVignette(ctx, canvas.width, canvas.height);
}

function drawOwnershipBorders(ctx, size) {
    // Linee più spesse e tratteggiate per sembrare confini politici
    ctx.setLineDash([4, 2]); 
    
    for (let y = 0; y < worldMap.height; y++) {
        for (let x = 0; x < worldMap.width; x++) {
            const tile = getTile(x, y);
            if (!tile || !tile.owner || tile.owner === 'wild') continue;

            const px = x * size;
            const py = y * size;
            const color = MEDIAEVAL_PALETTE.borders[tile.owner] || "rgba(0,0,0,0.5)";

            const neighbors = [
                {dx: 0, dy: -1}, {dx: 1, dy: 0}, {dx: 0, dy: 1}, {dx: -1, dy: 0}
            ];

            neighbors.forEach(n => {
                const nx = x + n.dx;
                const ny = y + n.dy;
                const nTile = getTile(nx, ny);
                
                // Disegna bordo se il vicino è diverso
                if (!nTile || nTile.owner !== tile.owner) {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    if (n.dx === 0 && n.dy === -1) { // Sopra
                        ctx.moveTo(px, py); ctx.lineTo(px + size, py);
                    } else if (n.dx === 1 && n.dy === 0) { // Destra
                        ctx.moveTo(px + size, py); ctx.lineTo(px + size, py + size);
                    } else if (n.dx === 0 && n.dy === 1) { // Sotto
                        ctx.moveTo(px, py + size); ctx.lineTo(px + size, py + size);
                    } else if (n.dx === -1 && n.dy === 0) { // Sinistra
                        ctx.moveTo(px, py); ctx.lineTo(px, py + size);
                    }
                    ctx.stroke();
                }
            });
        }
    }
    ctx.setLineDash([]); // Resetta tratteggio
}

// Aggiornamento icone strutture (più pulite)
function drawStructureMarkers(ctx, tileSize) {
    const center = tileSize / 2;

    // Helper per disegnare icone
    const drawIcon = (list, color, char) => {
        ctx.fillStyle = "rgba(255, 255, 255, 0.8)"; // Sfondo per leggibilità
        ctx.font = "14px Segoe UI Emoji"; 
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        
        list.forEach(s => {
            const x = s.x * tileSize + center;
            const y = s.y * tileSize + center;
            // Piccolo alone chiaro sotto l'icona
            ctx.beginPath();
            ctx.arc(x, y, 8, 0, Math.PI*2);
            ctx.fill();
            
            // Icona
            ctx.fillStyle = "#000"; // Colore testo
            ctx.fillText(char, x, y + 1);
        });
    }

    // Usa Emoji o caratteri invece di forme geometriche astratte
    drawIcon(structures.mines, "#333", "⛏️");
    drawIcon(structures.sawmills, "#228B22", "🪚");
    drawIcon(structures.quarries, "#696969", "🧱");
    drawIcon(structures.monasteries, "#800080", "⛪");
}

function drawSettlements(ctx, tileSize) {
    ctx.fillStyle = "#5D4037"; // Marrone scuro legno
    settlements.forEach(s => {
        const x = s.x * tileSize + tileSize / 2 - 4;
        const y = s.y * tileSize + tileSize / 2 - 4;
        // Casetta semplice
        ctx.beginPath();
        ctx.moveTo(x, y + 8);
        ctx.lineTo(x + 8, y + 8);
        ctx.lineTo(x + 8, y + 3);
        ctx.lineTo(x + 4, y); // Tetto
        ctx.lineTo(x, y + 3);
        ctx.fill();
    });
}

// Etichette migliorate con sfondo carta
function drawLabel(ctx, s, size, label, color) {
    const x = s.x * size + size / 2;
    const y = s.y * size + size / 2 - 18; 

    ctx.font = "bold 10px Georgia";
    const textWidth = ctx.measureText(label).width;
    
    // Sfondo etichetta
    ctx.fillStyle = "rgba(244, 236, 216, 0.9)"; // Color pergamena chiaro
    ctx.strokeStyle = "#8b7355";
    ctx.lineWidth = 1;
    
    // Rettangolo arrotondato (simulato)
    const pad = 4;
    ctx.fillRect(x - textWidth/2 - pad, y - 8, textWidth + pad*2, 12);
    ctx.strokeRect(x - textWidth/2 - pad, y - 8, textWidth + pad*2, 12);

    ctx.fillStyle = "#3e2723"; // Inchiostro scuro
    ctx.textAlign = "center";
    ctx.fillText(label, x, y + 1);
}

function drawVignette(ctx, width, height) {
    const gradient = ctx.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, Math.max(width, height) / 2);
    gradient.addColorStop(0, "rgba(0,0,0,0)");
    gradient.addColorStop(0.7, "rgba(0,0,0,0.1)");
    gradient.addColorStop(1, "rgba(0,0,0,0.3)");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);
}

function loginManual() {
    const key = document.getElementById("api-key-input").value.trim();
    if (!key) {
        updateApiKeyStatus("Inserisci una chiave valida.", false);
        return;
    }
    setApiKey(key);
    activateScreen("screen-editor");
}

function startGame() {
    if (!ensureApiKey()) {
        updateApiKeyStatus("Imposta la chiave API prima di iniziare.", false);
        activateScreen("screen-login");
        return;
    }

    const enteredHero = document.getElementById("hero-name").value.trim();
    const enteredDesc = document.getElementById("county-desc-init").value.trim();
    const advisorName = document.getElementById("adv-name").value.trim();
    const advisorTone = document.getElementById("adv-pers").value;

    resetGameState();

    heroName = enteredHero || "Il Conte";
    dynasty.ruler.name = heroName;
    county.desc = enteredDesc || "Una giovane contea in attesa del suo destino…";
    advisor.name = advisorName || "Consigliere di Corte";
    advisor.personality = advisorTone || personalitySettings.advisorTone;

    // Genera tutto
    generateWorldMap();
    generateSettlements();
    autogenerateStructures();
    drawCountyMap();
    drawRegionMap();

    updateUI();
    updateDynastyUI();

    activateScreen("screen-game");
    
    // Aggiorna nuovamente l'UI dopo che lo schermo è attivo
    setTimeout(() => updateUI(), 100);

    addMsg("ai", `📜 Benvenuto, ${heroName}. Il tuo regno attende le tue decisioni.`);
    if (personalitySettings && personalitySettings.notes) {
        addMsg("system", `🖋️ Appunti della corte: ${personalitySettings.notes}`);
    }

    autoSaveGame();
}

function switchTab(id, btn){
    document.querySelectorAll(".tab-view").forEach(t => t.classList.remove("active-tab"));
    document.getElementById(id).classList.add("active-tab");

    document.querySelectorAll(".hud-nav-bar button").forEach(b => b.classList.remove("active"));
    if (btn) btn.classList.add("active");

    if (id === 'tab-market') renderMarket();
    if (id === 'tab-dominio') updateUI();
}

/* ================= GESTIONE MODULO EDIFICI ================= */

function openBuildingModal() {
    const modal = document.getElementById("modal-buildings");
    const grid = document.getElementById("building-grid");
    if(!modal || !grid) return;

    grid.innerHTML = "";
    
    Object.keys(buildingData).forEach(key => {
        const b = buildingData[key];
        const canBuild = checkResources(b.cost); 
        
        // Creazione HTML Costi
        let costHtml = "";
        Object.entries(b.cost).forEach(([res, amount]) => {
            // === CORREZIONE QUI ===
            // Se la risorsa è gold, controlliamo county.gold, altrimenti county.resources
            let have = 0;
            if (res === 'gold' || res === 'oro') {
                have = county.gold || 0;
            } else {
                have = county.resources[res] || 0;
            }
            // ======================

            const missingClass = have < amount ? "missing" : "";
            costHtml += `<span class="cost-item ${missingClass}">
                ${resourceIcon(res)} ${amount}
            </span>`;
        });

        const card = document.createElement("div");
        card.className = "building-card-ui";
        card.innerHTML = `
            <div class="b-header">
                <span class="b-title">${b.name}</span>
                <span class="b-time">⏳ ${b.time} turni</span>
            </div>
            <div class="b-desc">${b.desc}</div>
            <div class="b-effect">✨ ${b.effect}</div>
            <div class="b-cost">${costHtml}</div>
            <button class="btn-main" 
                style="font-size:0.85em; padding:8px; margin-top:6px; ${canBuild ? '' : 'opacity:0.5; cursor:not-allowed;'}"
                onclick="${canBuild ? `orderBuilding('${key}')` : ''}">
                ${canBuild ? 'Avvia Cantiere' : 'Risorse Insufficienti'}
            </button>
        `;
        grid.appendChild(card);
    });

    modal.classList.add("active");
}

function closeBuildingModal() {
    document.getElementById("modal-buildings").classList.remove("active");
}

function resourceIcon(res) {
    const map = { gold:"💰", wood:"🌲", stone:"🪨", iron:"⛏️", copper:"🥉" };
    return map[res] || res;
}

function checkResources(cost) {
    for (let k in cost) {
        // SE il costo è "gold" o "oro", controlliamo il TESORO (county.gold)
        if (k === 'gold' || k === 'oro') {
            // Usa (county.gold || 0) per sicurezza
            if ((county.gold || 0) < cost[k]) return false;
        }
        // ALTRIMENTI controlliamo le RISORSE nel magazzino (county.resources)
        else {
            if ((county.resources[k] || 0) < cost[k]) return false;
        }
    }
    return true;
}

function orderBuilding(key) {
    const b = buildingData[key];
    if (!checkResources(b.cost)) return;

    // 1. Avvia la costruzione usando la funzione esistente
    startBuilding({
        type: key,
        x: 0, y: 0, // Costruzione astratta nel centro città
        turns: b.time,
        cost: b.cost
    });

    // 2. Notifica in chat pubblica simulando un ordine del giocatore
    const msg = `Ho ordinato la costruzione di: ${b.name}. I lavori iniziano immediatamente.`;
    publicChatHistory.push({ role: "user", content: msg }); // Aggiorna memoria IA
    addMsg("user", msg);
    
    // 3. Chiudi modale e aggiorna UI
    closeBuildingModal();
    updateUI();
}

function updateConstructionUI() {
    const container = document.getElementById("construction-feed");
    if (!container) return;

    // Filtra solo i cantieri attivi ("building")
    const activeProjects = buildings.filter(b => b.stage === "building");

    if (activeProjects.length === 0) {
        container.innerHTML = '<p class="event-empty">Nessun cantiere attivo al momento.</p>';
        return;
    }

    let html = "";
    activeProjects.forEach(b => {
        // Recuperiamo i dati originali per calcolare la %
        const bData = buildingData[b.type];
        const totalTurns = bData ? bData.time : b.turns_left; // Fallback
        
        // Calcolo progresso: (Totale - Rimanenti) / Totale
        // Nota: b.turns_left diminuisce ogni turno
        const completedTurns = totalTurns - b.turns_left;
        let pct = Math.round((completedTurns / totalTurns) * 100);
        pct = Math.max(5, Math.min(100, pct)); // Clamp grafico tra 5% e 100%

        const turnsLabel = b.turns_left === 1 ? "1 turno al termine" : `${b.turns_left} turni al termine`;

        html += `
            <div class="const-card">
                <div class="const-header">
                    <strong>${bData ? bData.name : "Edificio sconosciuto"}</strong>
                    <span style="color:var(--accent)">${pct}%</span>
                </div>
                <div class="const-progress-bg">
                    <div class="const-progress-fill" style="width: ${pct}%"></div>
                </div>
                <div class="const-meta">
                    <span>📍 (${b.x}, ${b.y})</span>
                    <span>⏳ ${turnsLabel}</span>
                </div>
            </div>
        `;
    });

    container.innerHTML = html;
}

function getResourceStats() {
    const stats = {};
    const lastEco = county.lastEconomy;
    if (!lastEco) {
        // Valori di default se non ancora calcolati
        RESOURCE_KEYS.forEach(key => {
            stats[key] = {
                production: Math.floor(Math.random() * 20) + 5,
                consumption: Math.floor(Math.random() * 15) + 5,
                net: Math.floor(Math.random() * 10) - 5
            };
        });
    } else {
        RESOURCE_KEYS.forEach(key => {
            const production = lastEco.production[key] || 0;
            const consumption = lastEco.deficits[key] || 0;
            const net = production - consumption;
            stats[key] = {
                production: production,
                consumption: consumption,
                net: net
            };
        });
    }
    return stats;
}

function renderResourceStats() {
    const container = document.getElementById("resource-stats");
    if (!container) return;

    const stats = getResourceStats();
    let html = `<div class="resource-stats-grid">`;

    RESOURCE_KEYS.forEach(key => {
        const s = stats[key];
        const icon = resourceIcon(key);
        const netClass = s.net > 0 ? 'positive' : s.net < 0 ? 'negative' : '';
        html += `
            <div class="resource-stat-item">
                <div class="resource-stat-header">
                    ${icon} ${resourceLabels[key] || key}
                </div>
                <div class="resource-stat-values">
                    <span>Prod: ${s.production}</span>
                    <span>Cons: ${s.consumption}</span>
                    <span class="${netClass}">Net: ${s.net > 0 ? '+' : ''}${s.net}</span>
                </div>
            </div>
        `;
    });

    html += `</tbody></table>`;
    container.innerHTML = html;
}

function getMarketPrices() {
    const prices = {
        wood: 5, stone: 8, iron: 15, copper: 12, gold: 1, // Base prices
        herbs: 4, grain: 3, livestock: 10, textiles: 20, luxuries: 50, arcane: 100
    };
    // Modifica basati su relazioni e accordi commerciali
    neighboringCounties.forEach(c => {
        const relation = c.relations || 50;
        let modifier = 1 + (50 - relation) / 100; // Più alta relazione, prezzi migliori (più bassi per comprare)
        if (c.tradeAgreement) {
            modifier *= 0.8; // Ulteriore sconto del 20% con accordo commerciale
        }
        Object.keys(prices).forEach(res => {
            prices[res] *= modifier;
        });
    });
    return prices;
}

/* ===================== NUOVE FUNZIONI MERCATO ===================== */

// Helper per leggere la quantità dall'input
function getQtyValue(id) {
    const el = document.getElementById(id);
    if (!el) return 1;
    const val = parseInt(el.value);
    return (isNaN(val) || val < 1) ? 1 : val;
}

function renderMarket() {
    const container = document.getElementById("market-content");
    if (!container) return;

    const prices = getMarketPrices();
    const stats = getResourceStats();
    const marketDynamics = calculateMarketDemand();

    // Intestazione
    let html = `<h4>Mercato Reale</h4>
    <p style="font-size:0.85em; color:#aaa; margin-bottom:15px;">
       Digita la quantità nella casella centrale per comprare o vendere in blocco.
    </p>`;

    html += `
        <table class="market-table">
            <thead>
                <tr>
                    <th>Risorsa</th>
                    <th>Stock</th>
                    <th>Fabbisogno</th>
                    <th>Domanda</th>
                    <th>Offerta</th>
                    <th>Compra (u)</th>
                    <th>Vendi (u)</th>
                    <th>Azioni</th>
                </tr>
            </thead>
            <tbody>
    `;

    RESOURCE_KEYS.forEach(key => {
        const have = county.resources[key] || 0;
        const demand = Math.round(marketDynamics.demand[key] || 0);
        const supply = Math.round(marketDynamics.supply[key] || 0);
        
        // Calcolo Prezzi
        let priceMultiplier = 1.0;
        if (demand > supply) priceMultiplier = 1.0 + (demand - supply) * 0.005; // Ridotto impatto per stabilità
        else if (supply > demand) priceMultiplier = Math.max(0.5, 1.0 - (supply - demand) * 0.005);
        
        const basePrice = prices[key];
        const buyPrice = Math.max(1, Math.round(basePrice * priceMultiplier * 1.3)); 
        const sellPrice = Math.max(1, Math.round(basePrice * priceMultiplier * 0.8)); 

        const fabbisogno = stats[key].consumption;
        const icon = resourceIcon(key);
        const inputId = `qty-${key}`;

        html += `
            <tr>
                <td>${icon} ${resourceLabels[key] || key}</td>
                <td><strong>${have}</strong></td>
                <td>${fabbisogno}</td>
                <td>${demand}</td>
                <td>${supply}</td>
                <td style="color:#ff7c7c">${buyPrice} 💰</td>
                <td style="color:#6ada91">${sellPrice} 💰</td>
                <td>
                    <div style="display:flex; align-items:center; justify-content:center; gap:4px; margin-bottom:4px;">
                        <button class="btn-sec" style="padding:2px 6px; font-size:0.7em;" onclick="document.getElementById('${inputId}').value=1">1</button>
                        <input id="${inputId}" type="number" class="market-qty-input" value="1" min="1">
                        <button class="btn-sec" style="padding:2px 6px; font-size:0.7em;" onclick="document.getElementById('${inputId}').value=10">10</button>
                    </div>
                    
                    <div style="display:flex; gap:6px; justify-content:center;">
                        <button class="btn-sec" style="border-color:#ff7c7c" 
                            onclick="buyResource('${key}', ${buyPrice}, getQtyValue('${inputId}'))">
                            Compra
                        </button>
                        <button class="btn-sec" style="border-color:#6ada91" 
                            onclick="sellResource('${key}', ${sellPrice}, getQtyValue('${inputId}'))" 
                            ${have > 0 ? '' : 'disabled'}>
                            Vendi
                        </button>
                    </div>
                </td>
            </tr>
        `;
    });

    html += `</tbody></table>`;
    
    // --- SEZIONE MERCATO INTERNO (SURPLUS / DEFICIT) ---
    // (Manteniamo la logica esistente per i riquadri sotto, che sono già abbastanza responsive, 
    // ma potresti voler aggiungere la logica bulk anche qui in futuro. Per ora lasciamoli semplici 
    // per non complicare troppo l'interfaccia).
    
    const surplus = [];
    const deficits = [];
    RESOURCE_KEYS.forEach(key => {
        if (stats[key].net > 0) surplus.push(key);
        if (stats[key].net < 0) deficits.push(key);
    });

    if (surplus.length > 0) {
        html += `<div class="market-section"><h5>Surplus - Risorse che Produciamo</h5>`;
        surplus.forEach(key => {
            const have = county.resources[key] || 0;
            const demand = Math.round(marketDynamics.demand[key] || 0);
            const supply = Math.round(marketDynamics.supply[key] || 0);
            const priceMultiplier = supply > demand ? 0.8 : 1.0; // Prezzi più bassi se surplus
            const sellPrice = Math.round(prices[key] * priceMultiplier * 0.6);
            const icon = resourceIcon(key);
            html += `
                <div class="market-item surplus">
                    <div class="market-header">
                        <span>${icon} ${resourceLabels[key] || key}</span>
                        <span>Hai: ${have}</span>
                    </div>
                    <div class="market-prices">
                        <button class="btn-sec" onclick="sellResource('${key}', ${sellPrice})" ${have > 0 ? '' : 'disabled'}>Vendi Interno - ${sellPrice}💰</button>
                    </div>
                    <div class="market-stats">
                        Surplus: +${stats[key].net} | Domanda: ${demand} | Offerta: ${supply}
                    </div>
                </div>
            `;
        });
        html += `</div>`;
    }

    if (deficits.length > 0) {
        html += `<div class="market-section"><h5>Deficit - Risorse che Ci Mancano</h5>`;
        deficits.forEach(key => {
            const have = county.resources[key] || 0;
            const demand = Math.round(marketDynamics.demand[key] || 0);
            const supply = Math.round(marketDynamics.supply[key] || 0);
            const priceMultiplier = demand > supply ? 1.2 : 1.0; // Prezzi più alti se deficit
            const buyPrice = Math.round(prices[key] * priceMultiplier * 1.4);
            const icon = resourceIcon(key);
            html += `
                <div class="market-item deficit">
                    <div class="market-header">
                        <span>${icon} ${resourceLabels[key] || key}</span>
                        <span>Hai: ${have}</span>
                    </div>
                    <div class="market-prices">
                        <button class="btn-sec" onclick="buyResource('${key}', ${buyPrice})">Compra Interno - ${buyPrice}💰</button>
                    </div>
                    <div class="market-stats">
                        Deficit: ${stats[key].net} | Domanda: ${demand} | Offerta: ${supply}
                    </div>
                </div>
            `;
        });
        html += `</div>`;
    }

    // Merci speciali dai regni vicini (solo con accordo commerciale)
    const tradePartners = neighboringCounties.filter(c => c.tradeAgreement);
    if (tradePartners.length > 0) {
        html += `<h4>Merci Speciali dai Regni Alleati</h4>`;
        tradePartners.forEach(c => {
            const special = c.specialResource;
            if (special) {
                const relationModifier = c.relations / 100; // 0-1
                const basePrice = prices[special] || 10;
                const buyPrice = Math.round(basePrice * 1.2 * (2 - relationModifier)); // Più economico con accordo
                const icon = resourceIcon(special);

                html += `
                    <div class="market-item special">
                        <div class="market-header">
                            <span>${icon} ${resourceLabels[special] || special} da ${c.name}</span>
                            <span>Accordo Commerciale</span>
                        </div>
                        <div class="market-prices">
                            <button class="btn-sec" onclick="buySpecialResource('${c.key}', '${special}', ${buyPrice})">Compra (1) - ${buyPrice}💰</button>
                        </div>
                        <div class="market-desc">
                            Risorsa pregiata da ${c.name}. Relazioni: ${c.relations > 50 ? 'Buone' : 'Tese'}. Prezzi ridotti grazie all'accordo.
                        </div>
                    </div>
                `;
            }
        });
    } else {
        html += `<h4>Merci Speciali</h4><p style="color: var(--text-soft); font-size: 0.9em;">Firma accordi commerciali in diplomazia per accedere alle merci speciali dei regni vicini.</p>`;
    }

    html += `</div>`;
    container.innerHTML = html;
}

function buyResource(res, unitPrice, qty) {
    if (qty < 1) qty = 1;
    const totalPrice = unitPrice * qty;

    if (county.gold >= totalPrice) {
        county.gold -= totalPrice;
        county.resources[res] = (county.resources[res] || 0) + qty;
        seasonalTransactions.marketPurchases += totalPrice;
        
        updateUI();
        renderMarket(); // Rerender per aggiornare stock e input
        
        addMsg("system", `🛒 Acquistati <strong>${qty}</strong> unità di ${resourceLabels[res] || res} per ${totalPrice} oro.`);
    } else {
        // Calcola quanti ne può comprare al massimo
        const maxAffordable = Math.floor(county.gold / unitPrice);
        if (maxAffordable > 0) {
            addMsg("system", `⚠️ Oro insufficiente per ${qty}. Puoi permettertene al massimo ${maxAffordable}.`);
        } else {
            addMsg("system", "⚠️ Oro insufficiente per l'acquisto.");
        }
    }
}

function sellResource(res, unitPrice, qty) {
    if (qty < 1) qty = 1;
    const have = county.resources[res] || 0;

    if (have >= qty) {
        const totalRevenue = unitPrice * qty;
        county.gold += totalRevenue;
        county.resources[res] -= qty;
        seasonalTransactions.marketSales += totalRevenue;
        
        updateUI();
        renderMarket();
        
        addMsg("system", `⚖️ Venduti <strong>${qty}</strong> unità di ${resourceLabels[res] || res} per ${totalRevenue} oro.`);
    } else {
        addMsg("system", `⚠️ Non hai abbastanza ${resourceLabels[res] || res} in magazzino (Disponibili: ${have}).`);
    }
}

function buySpecialResource(neighborKey, res, price) {
    if (county.gold >= price) {
        county.gold -= price;
        county.resources[res] = (county.resources[res] || 0) + 1;
        seasonalTransactions.specialPurchases += price;
        // Migliora leggermente relazioni
        const neighbor = neighboringCounties.find(c => c.key === neighborKey);
        if (neighbor) neighbor.relations = Math.min(100, neighbor.relations + 2);
        updateUI();
        renderMarket();
        addMsg("system", `Acquistato 1 ${resourceLabels[res] || res} speciale da ${neighbor.name} per ${price} oro. Relazioni migliorate.`);
    } else {
        addMsg("system", "Oro insufficiente per l'acquisto.");
    }
}

function drawRegionMap() {
    const canvas = document.getElementById("region-map");
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    const size = canvas.width / 8;

    // Sfondo carta antica
    ctx.fillStyle = "#e3d5b8"; 
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Disegna territori
    for (let y = 0; y < 8; y++) {
        for (let x = 0; x < 8; x++) {
            let owner = "wild";
            // Logica semplice per proprietari (uguale a prima ma con colori nuovi)
            if (y < 2) owner = "auvrey";
            else if (x > 5 && y > 5) owner = "falken";
            else if (rand(0,10) > 4) owner = "count";

            const px = x * size;
            const py = y * size;

            // Disegna solo bordi colorati e leggero riempimento per effetto mappa politica
            ctx.fillStyle = getRegionColor(owner, 0.3);
            ctx.fillRect(px, py, size, size);
            
            ctx.strokeStyle = getRegionColor(owner, 0.8);
            ctx.lineWidth = 1;
            ctx.strokeRect(px, py, size, size);
            
            // Disegna un simbolo per il proprietario
            if (Math.random() > 0.7 && owner !== 'wild') {
                ctx.font = "16px serif";
                ctx.textAlign = "center";
                ctx.fillStyle = "rgba(0,0,0,0.3)";
                const symbol = owner === 'count' ? '⚜️' : (owner === 'auvrey' ? '🦁' : '🦅');
                ctx.fillText(symbol, px + size/2, py + size/2 + 5);
            }
        }
    }
    
    drawNeighborPins(ctx);
    drawVignette(ctx, canvas.width, canvas.height);
}

function getRegionColor(owner, alpha) {
    const map = {
        count: `rgba(212, 175, 55, ${alpha})`,  // Oro
        auvrey: `rgba(180, 40, 40, ${alpha})`,  // Rosso scuro
        falken: `rgba(20, 60, 120, ${alpha})`,  // Blu scuro
        wild: `rgba(100, 100, 100, ${alpha})`   // Grigio neutro
    };
    return map[owner] || map.wild;
}

function drawNeighborPins(ctx) {
    const canvas = ctx.canvas;
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const radius = canvas.width * 0.35;

    neighboringCounties.forEach((c, idx) => {
        const angle = (idx / neighboringCounties.length) * Math.PI * 2;
        const x = centerX + Math.cos(angle) * radius;
        const y = centerY + Math.sin(angle) * radius;

        ctx.beginPath();
        ctx.fillStyle = getRegionColor(c.key, 1);
        ctx.arc(x, y, 12, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "#3e2723";
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.fillStyle = "#fff";
        ctx.font = "10px Georgia";
        ctx.textAlign = "center";
        ctx.fillText(c.name.split(" ")[0], x, y + 3);
    });
}

document.addEventListener("DOMContentLoaded", initStartScreen);

</script>

<div id="modal-budget" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Bilancio Stagionale</h3>
            <button class="close-btn" onclick="closeBudgetModal()">✕</button>
        </div>
        <div id="budget-content">
            <!-- Contenuto popolato da renderBudget() -->
        </div>
    </div>
</div>

</body>
</html>
